diff -urN gcc-10-20200216/libstdc++-v3/ChangeLog gcc-10-20200202/libstdc++-v3/ChangeLog
--- gcc-10-20200216/libstdc++-v3/ChangeLog	2020-02-16 23:32:14.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/ChangeLog	2020-02-02 23:32:19.000000000 +0100
@@ -1,366 +1,3 @@
-2020-02-16  Patrick Palka  <ppalka@redhat.com>
-
-	* include/bits/ranges_algo.h (__lexicographical_compare_fn::operator()):
-	Move code after an early exit constexpr if to under an else branch.
-	* include/bits/ranges_algobase.h (__equal_fn::operator()): Likewise.
-
-2020-02-15  Patrick Palka  <ppalka@redhat.com>
-
-	* include/bits/ranges_algo.h: Adjust whitespace and formatting.
-	* include/bits/ranges_algobase.h: Likewise.
-	* include/bits/ranges_uninitialized.h: Likewise.
-
-	* include/bits/ranges_algo.h: (adjacent_find, all_of, any_of,
-	binary_search, copy_if, count, count_if, equal_range, find, find_end,
-	find_first_of, find_if, find_if_not, for_each, generate, generate_n,
-	includes, inplace_merge, is_heap, is_heap_until, is_partitioned,
-	is_permutation, is_sorted, is_sorted_until, lexicographical_compare,
-	lower_bound, make_heap, max, max_element, merge, min, min_element,
-	minmax, minmax_element, mismatch, next_permutation, none_of,
-	nth_element, partial_sort, partial_sort_copy, partition, partition_copy,
-	partition_point, pop_heap, prev_permutation, push_heap, remove,
-	remove_copy, remove_copy_if, remove_if, replace, replace_copy,
-	replace_copy_if, replace_if, reverse, reverse_copy, rotate, rotate_copy,
-	search, search_n, set_difference, set_intersection,
-	set_symmetric_difference, set_union, shuffle, sort, sort_heap,
-	stable_partition, stable_sort, swap_ranges, transform, unique,
-	unique_copy, upper_bound): Convert into function objects.
-	* include/bits/ranges_algobase.h: (equal, copy, move, copy_n, fill_n,
-	fill, move_backward, copy_backward): Likewise.
-	* include/bits/ranges_uninitialized.h (uninitialized_default_construct,
-	uninitialized_default_construct_n, uninitialized_value_construct,
-	uninitialized_value_construct_n, uninitialized_copy,
-	uninitialized_copy_n, uninitialized_move, uninitialized_move_n,
-	uninitialized_fill, uninitialized_fill_n, construct_at, destroy_at,
-	destroy, destroy_n): Likewise.
-
-	* include/bits/ranges_algo.h (ranges::__find_end): Fold into ...
-	(ranges::find_end): ... here.
-	(ranges::__lexicographical_compare): Fold into ...
-	(ranges::lexicographical_compare): ... here.
-	* include/bits/ranges_algobase.h (ranges::__equal): Fold into ...
-	(ranges::equal): ... here.
-
-2020-02-15  Jonathan Wakely  <jwakely@redhat.com>
-
-	* include/bits/erase_if.h (__cpp_lib_erase_if): Define to 202002L.
-	* include/std/deque: Likewise.
-	* include/std/forward_list: Likewise.
-	* include/std/list: Likewise.
-	* include/std/string: Likewise.
-	* include/std/vector: Likewise.
-	* include/std/version: Likewise.
-	* testsuite/23_containers/deque/erasure.cc: Test for new value.
-	* testsuite/23_containers/forward_list/erasure.cc: Likewise.
-	* testsuite/23_containers/list/erasure.cc: Likewise.
-	* testsuite/23_containers/map/erasure.cc: Likewise.
-	* testsuite/23_containers/set/erasure.cc: Likewise.
-	* testsuite/23_containers/unordered_map/erasure.cc: Likewise.
-	* testsuite/23_containers/unordered_set/erasure.cc: Likewise.
-	* testsuite/23_containers/vector/erasure.cc: Likewise.
-
-2020-02-15  Jonathan Wakely  <jwakely@redhat.com>
-
-	* include/bits/random.h (uniform_random_bit_generator): Require min()
-	and max() to be constant expressions and min() to be less than max().
-	* testsuite/26_numerics/random/concept.cc: Check additional cases.
-	* testsuite/26_numerics/random/pr60037-neg.cc: Adjust dg-error lineno.
-
-2020-02-13  Patrick Palka  <ppalka@redhat.com>
-
-	* include/Makefile.am: Add <bits/ranges_uninitialized.h>.
-	* include/Makefile.in: Regenerate.
-	* include/bits/ranges_uninitialized.h: New header.
-	* include/std/memory: Include it.
-	* testsuite/20_util/specialized_algorithms/destroy/constrained.cc: New
-	test.
-	* .../uninitialized_copy/constrained.cc: New test.
-	* .../uninitialized_default_construct/constrained.cc: New test.
-	* .../uninitialized_fill/constrained.cc: New test.
-	* .../uninitialized_move/constrained.cc: New test.
-	* .../uninitialized_value_construct/constrained.cc: New test.
-
-	* include/Makefile.am: Add bits/ranges_algobase.h
-	* include/Makefile.in: Regenerate.
-	* bits/ranges_algo.h: Include <bits/ranges_algobase.h> and refactor
-	existing #includes.
-	(__detail::__is_normal_iterator, __detail::is_reverse_iterator,
-	__detail::__is_move_iterator, copy_result, move_result,
-	__equal, equal, copy_result, move_result, move_backward_result,
-	copy_backward_result, __copy_or_move_backward, __copy_or_move, copy,
-	move, copy_backward, move_backward, copy_n_result, copy_n, fill_n,
-	fill): Split out into ...
-	* bits/range_algobase.h: ... this new header.
-
-2020-02-12  Patrick Palka  <ppalka@redhat.com>
-
-	LWG 3389 and LWG 3390
-	* include/bits/stl_iterator.h (move_move_iterator): Use std::move when
-	constructing the move_iterator with __i.
-	(counted_iterator::counted_iterator): Use std::move when initializing
-	M_current with __i.
-	* testsuite/24_iterators/counted_iterator/lwg3389.cc: New test.
-	* testsuite/24_iterators/move_iterator/lwg3390.cc: New test.
-
-2020-02-12  Sandra Loosemore  <sandra@codesourcery.com>
-
-	PR libstdc++/79193
-	PR libstdc++/88999
-
-	* configure: Regenerated.
-
-2020-02-12  Fran√ßois Dumont  <fdumont@gcc.gnu.org>
-
-	* include/bits/hashtable.h
-	(_Hashtable<>(_Hashtable&&, std::allocator_type&)): Add
-	missing std namespace qualification to forward call.
-
-2020-02-09  Jonathan Wakely  <jwakely@redhat.com>
-
-	* testsuite/20_util/function_objects/range.cmp/equal_to.cc: Fix
-	comment.
-	* testsuite/20_util/function_objects/range.cmp/less.ccL Likewise.
-
-	* include/std/ranges: Fix non-ASCII characters in comment.
-
-	* include/bits/range_cmp.h (__detail::__eq_builtin_ptr_cmp): Require
-	equality comparison to be valid and return bool.
-	(__detail::__less_builtin_ptr_cmp): Likewise for less-than comparison.
-	* testsuite/20_util/function_objects/range.cmp/equal_to.cc: Check
-	type with ambiguous conversion to fundamental types.
-	* testsuite/20_util/function_objects/range.cmp/less.cc: Likewise.
-
-2020-02-07  Jonathan Wakely  <jwakely@redhat.com>
-
-	* include/bits/iterator_concepts.h (iter_difference_t, iter_value_t):
-	Use remove_cvref_t.
-	(readable_traits): Rename to indirectly_readable_traits.
-	(readable): Rename to indirectly_readable.
-	(writable): Rename to indirectly_writable.
-	(__detail::__iter_exchange_move): Do not use remove_reference_t.
-	(indirectly_swappable): Adjust requires expression parameter types.
-	expression.
-	* include/bits/ranges_algo.h (ranges::transform, ranges::replace)
-	(ranges::replace_if, ranges::generate_n, ranges::generate)
-	(ranges::remove): Use new name for writable.
-	* include/bits/stl_iterator.h (__detail::__common_iter_has_arrow):
-	Use new name for readable.
-	* include/ext/pointer.h (readable_traits<_Pointer_adapter<P>>): Use
-	new name for readable_traits.
-	* testsuite/24_iterators/associated_types/readable.traits.cc: Likewise.
-	* testsuite/24_iterators/indirect_callable/projected.cc: Adjust for
-	new definition of indirectly_readable.
-
-	* include/bits/stl_iterator.h (__detail::__common_iter_ptr): Change
-	to take parameters of common_iterator, instead of the common_iterator
-	type itself. Fix argument for __common_iter_has_arrow constraint.
-	(iterator_traits<common_iterator<I, S>>::pointer): Adjust.
-
-2020-02-07  Jonathan Wakely  <jwakely@redhat.com>
-
-	* include/std/ranges (iota_view): Add braces to prevent -Wempty-body
-	warning.
-	(basic_istream_view::_Iterator::operator++()): Add missing return.
-
-2020-02-07  Patrick Palka  <ppalka@redhat.com>
-
-	* include/bits/ranges_algo.h: Remove extraneous &&.
-
-	* include/std/ranges (ranges::__detail::__stream_extractable,
-	ranges::basic_istream_view, ranges::istream_view): Define.
-	* testsuite/std/ranges/istream_view: New test.
-
-	Implement C++20 range adaptors
-	* include/std/ranges: Include <bits/refwrap.h> and <tuple>.
-	(subrange::_S_store_size): Mark as const instead of constexpr to
-	avoid what seems to be a bug in GCC.
-	(__detail::__box): Give it defaulted copy and move constructors.
-	(ranges::views::_Single::operator()): Mark constexpr.
-	(ranges::views::_Iota::operator()): Mark constexpr.
-	(__detail::Empty): Define.
-	(ranges::views::__closure::_RangeAdaptor,
-	ranges::views::__closure::_RangeAdaptorClosure, ref_view, all_view,
-	ranges::views::all, ranges::__detail::find_if,
-	ranges::__detail::find_if_not, ranges::__detail::mismatch,
-	ranges::detail::min, filter_view, ranges::views::filter, transform_view,
-	ranges::views::transform, take_view, ranges::views::take,
-	take_while_view, ranges::views::take_while, drop_view,
-	ranges::views::drop, join_view, ranges::views::join,
-	__detail::require_constant, __detail::tiny_range, split_view,
-	ranges::views::split, ranges::views::_Counted, ranges::views::counted,
-	common_view, ranges::views::common, reverse_view,
-	ranges::views::reverse,
-	ranges::views::__detail::__is_reversible_subrange,
-	ranges::views::__detail::__is_reverse_view, reverse_view,
-	ranges::views::reverse, __detail::__has_tuple_element, elements_view,
-	ranges::views::elements, ranges::views::keys, ranges::views::values):
-	Define.
-	(views): Alias for ranges::views.
-	(tuple_size<ranges::subrange<>>, tuple_element<0, ranges::subrange>,
-	tuple_element<1, ranges::subrange>): New partial specializations.
-	* testsuite/std/ranges/adaptors/all.cc: New test.
-	* testsuite/std/ranges/adaptors/common.cc: Likewise.
-	* testsuite/std/ranges/adaptors/counted.cc: Likewise.
-	* testsuite/std/ranges/adaptors/drop.cc: Likewise.
-	* testsuite/std/ranges/adaptors/drop_while.cc: Likewise.
-	* testsuite/std/ranges/adaptors/elements.cc: Likewise.
-	* testsuite/std/ranges/adaptors/filter.cc: Likewise.
-	* testsuite/std/ranges/adaptors/join.cc: Likewise.
-	* testsuite/std/ranges/adaptors/reverse.cc: Likewise.
-	* testsuite/std/ranges/adaptors/split.cc: Likewise.
-	* testsuite/std/ranges/adaptors/take.cc: Likewise.
-	* testsuite/std/ranges/adaptors/take_while.cc: Likewise.
-	* testsuite/std/ranges/adaptors/transform.cc: Likewise.
-
-2020-02-07  Jonathan Wakely  <jwakely@redhat.com>
-
-	* libsupc++/compare (__cmp_cat::type): Define typedef for underlying
-	type of enumerations and comparison category types.
-	(__cmp_cat::_Ord, __cmp_cat::_Ncmp): Add underlying type.
-	(__cmp_cat::_Ncmp::unordered): Change value to 2.
-	(partial_ordering::_M_value, weak_ordering::_M_value)
-	(strong_ordering::_M_value): Change type to __cmp_cat::type.
-	(partial_ordering::_M_is_ordered): Remove data member.
-	(partial_ordering): Use second bit of _M_value for unordered. Adjust
-	comparison operators.
-	(weak_ordering::operator partial_ordering): Simplify to remove
-	branches.
-	(operator<=>(unspecified, weak_ordering)): Likewise.
-	(strong_ordering::operator partial_ordering): Likewise.
-	(strong_ordering::operator weak_ordering): Likewise.
-	(operator<=>(unspecified, strong_ordering)): Likewise.
-	* testsuite/18_support/comparisons/categories/partialord.cc: New test.
-	* testsuite/18_support/comparisons/categories/strongord.cc: New test.
-	* testsuite/18_support/comparisons/categories/weakord.cc: New test.
-
-	* include/std/ranges (iota_view::_Iterator): Fix typo in name of
-	__cpp_lib_three_way_comparison macro and use deduced return type for
-	operator<=>.
-	* testsuite/std/ranges/iota/iterator.cc: New test.
-
-2020-02-07  Patrick Palka  <ppalka@redhat.com>
-	    Jonathan Wakely  <jwakely@redhat.com>
-
-	Implement C++20 constrained algorithms
-	* include/Makefile.am: Add new header.
-	* include/Makefile.in: Regenerate.
-	* include/std/algorithm: Include <bits/ranges_algo.h>.
-	* include/bits/ranges_algo.h: New file.
-	* testsuite/25_algorithms/adjacent_find/constrained.cc: New test.
-	* testsuite/25_algorithms/all_of/constrained.cc: New test.
-	* testsuite/25_algorithms/any_of/constrained.cc: New test.
-	* testsuite/25_algorithms/binary_search/constrained.cc: New test.
-	* testsuite/25_algorithms/copy/constrained.cc: New test.
-	* testsuite/25_algorithms/copy_backward/constrained.cc: New test.
-	* testsuite/25_algorithms/copy_if/constrained.cc: New test.
-	* testsuite/25_algorithms/copy_n/constrained.cc: New test.
-	* testsuite/25_algorithms/count/constrained.cc: New test.
-	* testsuite/25_algorithms/count_if/constrained.cc: New test.
-	* testsuite/25_algorithms/equal/constrained.cc: New test.
-	* testsuite/25_algorithms/equal_range/constrained.cc: New test.
-	* testsuite/25_algorithms/fill/constrained.cc: New test.
-	* testsuite/25_algorithms/fill_n/constrained.cc: New test.
-	* testsuite/25_algorithms/find/constrained.cc: New test.
-	* testsuite/25_algorithms/find_end/constrained.cc: New test.
-	* testsuite/25_algorithms/find_first_of/constrained.cc: New test.
-	* testsuite/25_algorithms/find_if/constrained.cc: New test.
-	* testsuite/25_algorithms/find_if_not/constrained.cc: New test.
-	* testsuite/25_algorithms/for_each/constrained.cc: New test.
-	* testsuite/25_algorithms/generate/constrained.cc: New test.
-	* testsuite/25_algorithms/generate_n/constrained.cc: New test.
-	* testsuite/25_algorithms/heap/constrained.cc: New test.
-	* testsuite/25_algorithms/includes/constrained.cc: New test.
-	* testsuite/25_algorithms/inplace_merge/constrained.cc: New test.
-	* testsuite/25_algorithms/is_partitioned/constrained.cc: New test.
-	* testsuite/25_algorithms/is_permutation/constrained.cc: New test.
-	* testsuite/25_algorithms/is_sorted/constrained.cc: New test.
-	* testsuite/25_algorithms/is_sorted_until/constrained.cc: New test.
-	* testsuite/25_algorithms/lexicographical_compare/constrained.cc: New
-	test.
-	* testsuite/25_algorithms/lower_bound/constrained.cc: New test.
-	* testsuite/25_algorithms/max/constrained.cc: New test.
-	* testsuite/25_algorithms/max_element/constrained.cc: New test.
-	* testsuite/25_algorithms/merge/constrained.cc: New test.
-	* testsuite/25_algorithms/min/constrained.cc: New test.
-	* testsuite/25_algorithms/min_element/constrained.cc: New test.
-	* testsuite/25_algorithms/minmax/constrained.cc: New test.
-	* testsuite/25_algorithms/minmax_element/constrained.cc: New test.
-	* testsuite/25_algorithms/mismatch/constrained.cc: New test.
-	* testsuite/25_algorithms/move/constrained.cc: New test.
-	* testsuite/25_algorithms/move_backward/constrained.cc: New test.
-	* testsuite/25_algorithms/next_permutation/constrained.cc: New test.
-	* testsuite/25_algorithms/none_of/constrained.cc: New test.
-	* testsuite/25_algorithms/nth_element/constrained.cc: New test.
-	* testsuite/25_algorithms/partial_sort/constrained.cc: New test.
-	* testsuite/25_algorithms/partial_sort_copy/constrained.cc: New test.
-	* testsuite/25_algorithms/partition/constrained.cc: New test.
-	* testsuite/25_algorithms/partition_copy/constrained.cc: New test.
-	* testsuite/25_algorithms/partition_point/constrained.cc: New test.
-	* testsuite/25_algorithms/prev_permutation/constrained.cc: New test.
-	* testsuite/25_algorithms/remove/constrained.cc: New test.
-	* testsuite/25_algorithms/remove_copy/constrained.cc: New test.
-	* testsuite/25_algorithms/remove_copy_if/constrained.cc: New test.
-	* testsuite/25_algorithms/remove_if/constrained.cc: New test.
-	* testsuite/25_algorithms/replace/constrained.cc: New test.
-	* testsuite/25_algorithms/replace_copy/constrained.cc: New test.
-	* testsuite/25_algorithms/replace_copy_if/constrained.cc: New test.
-	* testsuite/25_algorithms/replace_if/constrained.cc: New test.
-	* testsuite/25_algorithms/reverse/constrained.cc: New test.
-	* testsuite/25_algorithms/reverse_copy/constrained.cc: New test.
-	* testsuite/25_algorithms/rotate/constrained.cc: New test.
-	* testsuite/25_algorithms/rotate_copy/constrained.cc: New test.
-	* testsuite/25_algorithms/search/constrained.cc: New test.
-	* testsuite/25_algorithms/search_n/constrained.cc: New test.
-	* testsuite/25_algorithms/set_difference/constrained.cc: New test.
-	* testsuite/25_algorithms/set_intersection/constrained.cc: New test.
-	* testsuite/25_algorithms/set_symmetric_difference/constrained.cc: New
-	test.
-	* testsuite/25_algorithms/set_union/constrained.cc: New test.
-	* testsuite/25_algorithms/shuffle/constrained.cc: New test.
-	* testsuite/25_algorithms/sort/constrained.cc: New test.
-	* testsuite/25_algorithms/stable_partition/constrained.cc: New test.
-	* testsuite/25_algorithms/stable_sort/constrained.cc: New test.
-	* testsuite/25_algorithms/swap_ranges/constrained.cc: New test.
-	* testsuite/25_algorithms/transform/constrained.cc: New test.
-	* testsuite/25_algorithms/unique/constrained.cc: New test.
-	* testsuite/25_algorithms/unique_copy/constrained.cc: New test.
-	* testsuite/25_algorithms/upper_bound/constrained.cc: New test.
-
-2020-02-06  Jonathan Wakely  <jwakely@redhat.com>
-
-	* include/bits/stl_iterator.h (__detail::__common_iter_ptr): Fix PR
-	number in comment. Fix indentation.
-
-	* include/bits/stl_algobase.h (__iter_swap, __iter_swap<true>): Remove
-	redundant _GLIBCXX20_CONSTEXPR.
-
-	* include/std/ranges (viewable_range): Replace decay_t with
-	remove_cvref_t (LWG 3375).
-
-2020-02-05  Jonathan Wakely  <jwakely@redhat.com>
-
-	* include/bits/iterator_concepts.h (iter_reference_t)
-	(iter_rvalue_reference_t, iter_common_reference_t, indirect_result_t):
-	Remove workarounds for PR c++/67704.
-	* testsuite/24_iterators/aliases.cc: New test.
-
-2020-02-05  Patrick Palka  <ppalka@redhat.com>
-
-	* include/bits/stl_iterator.h (move_iterator::move_iterator): Move __i
-	when initializing _M_current.
-	(move_iterator::base): Split into two overloads differing in
-	ref-qualifiers as in P1207R4 for C++20.
-
-2020-02-04  Jonathan Wakely  <jwakely@redhat.com>
-
-	* include/std/functional (_GLIBCXX_NOT_FN_CALL_OP): Un-define after
-	use.
-
-	PR libstdc++/93562
-	* include/bits/unique_ptr.h (__uniq_ptr_impl::swap): Define.
-	(unique_ptr::swap, unique_ptr<T[], D>::swap): Call it.
-	* testsuite/20_util/unique_ptr/modifiers/93562.cc: New test.
-
 2020-02-01  Andrew Burgess  <andrew.burgess@embecosm.com>
 
 	* configure: Regenerate.
diff -urN gcc-10-20200216/libstdc++-v3/configure gcc-10-20200202/libstdc++-v3/configure
--- gcc-10-20200216/libstdc++-v3/configure	2020-02-16 23:32:14.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/configure	2020-02-02 23:32:19.000000000 +0100
@@ -4130,11 +4130,11 @@
 
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <stdio.h>
+
 int
 main ()
 {
-printf ("hello world\n");
+
   ;
   return 0;
 }
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/erase_if.h gcc-10-20200202/libstdc++-v3/include/bits/erase_if.h
--- gcc-10-20200216/libstdc++-v3/include/bits/erase_if.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/erase_if.h	2020-02-02 23:32:19.000000000 +0100
@@ -39,7 +39,7 @@
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus > 201703L
-# define __cpp_lib_erase_if 202002L
+# define __cpp_lib_erase_if 201900L
 #endif
 
   namespace __detail
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/hashtable.h gcc-10-20200202/libstdc++-v3/include/bits/hashtable.h
--- gcc-10-20200216/libstdc++-v3/include/bits/hashtable.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/hashtable.h	2020-02-02 23:32:19.000000000 +0100
@@ -1371,7 +1371,7 @@
 	  using _Fwd_Ht = typename
 	    conditional<__move_if_noexcept_cond<value_type>::value,
 			const _Hashtable&, _Hashtable&&>::type;
-	  _M_assign(std::forward<_Fwd_Ht>(__ht), __alloc_gen);
+	  _M_assign(forward<_Fwd_Ht>(__ht), __alloc_gen);
 	  __ht.clear();
 	}
     }
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/iterator_concepts.h gcc-10-20200202/libstdc++-v3/include/bits/iterator_concepts.h
--- gcc-10-20200216/libstdc++-v3/include/bits/iterator_concepts.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/iterator_concepts.h	2020-02-02 23:32:19.000000000 +0100
@@ -70,10 +70,17 @@
 	{
 	  { *__t } -> __can_reference;
 	};
+
+    // FIXME: needed due to PR c++/67704
+    template<__detail::__dereferenceable _Tp>
+      struct __iter_ref
+      {
+	using type = decltype(*std::declval<_Tp&>());
+      };
   } // namespace __detail
 
-  template<__detail::__dereferenceable _Tp>
-    using iter_reference_t = decltype(*std::declval<_Tp&>());
+  template<typename _Tp>
+    using iter_reference_t = typename __detail::__iter_ref<_Tp>::type;
 
   namespace ranges
   {
@@ -120,11 +127,26 @@
     } // inline namespace __cust
   } // namespace ranges
 
-  template<__detail::__dereferenceable _Tp>
-    requires requires(_Tp& __t)
-    { { ranges::iter_move(__t) } -> __detail::__can_reference; }
+  namespace __detail
+  {
+    // FIXME: needed due to PR c++/67704
+    template<__detail::__dereferenceable _Tp>
+      struct __iter_rvalue_ref
+      { };
+
+    template<__detail::__dereferenceable _Tp>
+      requires requires(_Tp& __t)
+      {
+	{ ranges::iter_move(__t) } -> __detail::__can_reference;
+      }
+      struct __iter_rvalue_ref<_Tp>
+      { using type = decltype(ranges::iter_move(std::declval<_Tp&>())); };
+
+  } // namespace __detail
+
+  template<typename _Tp>
     using iter_rvalue_reference_t
-      = decltype(ranges::iter_move(std::declval<_Tp&>()));
+      = typename __detail::__iter_rvalue_ref<_Tp>::type;
 
   template<typename> struct incrementable_traits { };
 
@@ -173,14 +195,11 @@
     // ITER_TRAITS
     template<typename _Iter, typename _Tp = _Iter>
       using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;
-
-    template<typename _Tp>
-      using __iter_diff_t = typename
-	__iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
   } // namespace __detail
 
   template<typename _Tp>
-    using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;
+    using iter_difference_t = typename
+      __detail::__iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
 
   namespace __detail
   {
@@ -191,41 +210,35 @@
       { using value_type = remove_cv_t<_Tp>; };
   } // namespace __detail
 
-  template<typename> struct indirectly_readable_traits { };
+  template<typename> struct readable_traits { };
 
   template<typename _Tp>
-    struct indirectly_readable_traits<_Tp*>
+    struct readable_traits<_Tp*>
     : __detail::__cond_value_type<_Tp>
     { };
 
   template<typename _Iter> requires is_array_v<_Iter>
-    struct indirectly_readable_traits<_Iter>
+    struct readable_traits<_Iter>
     { using value_type = remove_cv_t<remove_extent_t<_Iter>>; };
 
   template<typename _Iter>
-    struct indirectly_readable_traits<const _Iter>
-    : indirectly_readable_traits<_Iter>
+    struct readable_traits<const _Iter>
+    : readable_traits<_Iter>
     { };
 
   template<typename _Tp> requires requires { typename _Tp::value_type; }
-    struct indirectly_readable_traits<_Tp>
+    struct readable_traits<_Tp>
     : __detail::__cond_value_type<typename _Tp::value_type>
     { };
 
   template<typename _Tp> requires requires { typename _Tp::element_type; }
-    struct indirectly_readable_traits<_Tp>
+    struct readable_traits<_Tp>
     : __detail::__cond_value_type<typename _Tp::element_type>
     { };
 
-  namespace __detail
-  {
-    template<typename _Tp>
-      using __iter_value_t = typename
-	__iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
-  } // namespace __detail
-
   template<typename _Tp>
-    using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;
+    using iter_value_t = typename
+      __detail::__iter_traits<_Tp, readable_traits<_Tp>>::value_type;
 
   namespace __detail
   {
@@ -244,11 +257,11 @@
 	&& requires(_Iter __it)
 	{
 	  typename incrementable_traits<_Iter>::difference_type;
-	  typename indirectly_readable_traits<_Iter>::value_type;
+	  typename readable_traits<_Iter>::value_type;
 	  typename common_reference_t<iter_reference_t<_Iter>&&,
-		   typename indirectly_readable_traits<_Iter>::value_type&>;
+		   typename readable_traits<_Iter>::value_type&>;
 	  typename common_reference_t<decltype(*__it++)&&,
-		   typename indirectly_readable_traits<_Iter>::value_type&>;
+		   typename readable_traits<_Iter>::value_type&>;
 	  requires signed_integral<typename incrementable_traits<_Iter>::difference_type>;
 	};
 
@@ -257,7 +270,7 @@
 	&& constructible_from<_Iter>
 	&& is_lvalue_reference_v<iter_reference_t<_Iter>>
 	&& same_as<remove_cvref_t<iter_reference_t<_Iter>>,
-		   typename indirectly_readable_traits<_Iter>::value_type>
+		   typename readable_traits<_Iter>::value_type>
 	&& requires(_Iter __it)
 	{
 	  {  __it++ } -> convertible_to<const _Iter&>;
@@ -299,7 +312,6 @@
     template<typename _Iter>
       concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;
 
-    // FIXME: These have to be at namespace-scope because of PR 92103.
     template<typename _Iter, bool __use_arrow = false>
       struct __ptr
       { using type = void; };
@@ -386,7 +398,7 @@
     {
       using iterator_category = typename __detail::__cat<_Iterator>::type;
       using value_type
-	= typename indirectly_readable_traits<_Iterator>::value_type;
+	= typename readable_traits<_Iterator>::value_type;
       using difference_type
 	= typename incrementable_traits<_Iterator>::difference_type;
       using pointer	      = typename __detail::__ptr<_Iterator, true>::type;
@@ -439,15 +451,15 @@
     // ITER_CONCEPT
     template<typename _Iter>
       using __iter_concept = typename __iter_concept_impl<_Iter>::type;
+  } // namespace __detail
 
+  /// Requirements for types that are readable by applying operator*.
   template<typename _In>
-    concept __indirectly_readable_impl = requires(const _In __in)
+    concept readable = requires
       {
 	typename iter_value_t<_In>;
 	typename iter_reference_t<_In>;
 	typename iter_rvalue_reference_t<_In>;
-	{ *__in } -> same_as<iter_reference_t<_In>>;
-	{ ranges::iter_move(__in) } -> same_as<iter_rvalue_reference_t<_In>>;
       }
       && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&>
       && common_reference_with<iter_reference_t<_In>&&,
@@ -455,20 +467,22 @@
       && common_reference_with<iter_rvalue_reference_t<_In>&&,
 			       const iter_value_t<_In>&>;
 
+  namespace __detail
+  {
+    // FIXME: needed due to PR c++/67704
+    template<readable _Tp>
+      struct __iter_common_ref
+      : common_reference<iter_reference_t<_Tp>, iter_value_t<_Tp>&>
+      { };
   } // namespace __detail
 
-  /// Requirements for types that are readable by applying operator*.
-  template<typename _In>
-    concept indirectly_readable
-      = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;
-
-  template<indirectly_readable _Tp>
+  template<typename _Tp>
     using iter_common_reference_t
-      = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;
+      = typename __detail::__iter_common_ref<_Tp>::type;
 
   /// Requirements for writing a value into an iterator's referenced object.
   template<typename _Out, typename _Tp>
-    concept indirectly_writable = requires(_Out&& __o, _Tp&& __t)
+    concept writable = requires(_Out&& __o, _Tp&& __t)
       {
 	*__o = std::forward<_Tp>(__t);
 	*std::forward<_Out>(__o) = std::forward<_Tp>(__t);
@@ -540,13 +554,13 @@
 
   template<typename _Iter>
     concept input_iterator = input_or_output_iterator<_Iter>
-      && indirectly_readable<_Iter>
+      && readable<_Iter>
       && requires { typename __detail::__iter_concept<_Iter>; }
       && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;
 
   template<typename _Iter, typename _Tp>
     concept output_iterator = input_or_output_iterator<_Iter>
-      && indirectly_writable<_Iter, _Tp>
+      && writable<_Iter, _Tp>
       && requires(_Iter __i, _Tp&& __t) { *__i++ = std::forward<_Tp>(__t); };
 
   template<typename _Iter>
@@ -596,7 +610,7 @@
   // [indirectcallable.indirectinvocable], indirect callables
 
   template<typename _Fn, typename _Iter>
-    concept indirectly_unary_invocable = indirectly_readable<_Iter>
+    concept indirectly_unary_invocable = readable<_Iter>
       && copy_constructible<_Fn> && invocable<_Fn&, iter_value_t<_Iter>&>
       && invocable<_Fn&, iter_reference_t<_Iter>>
       && invocable<_Fn&, iter_common_reference_t<_Iter>>
@@ -604,7 +618,7 @@
 			       invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;
 
   template<typename _Fn, typename _Iter>
-    concept indirectly_regular_unary_invocable = indirectly_readable<_Iter>
+    concept indirectly_regular_unary_invocable = readable<_Iter>
       && copy_constructible<_Fn>
       && regular_invocable<_Fn&, iter_value_t<_Iter>&>
       && regular_invocable<_Fn&, iter_reference_t<_Iter>>
@@ -613,14 +627,13 @@
 			       invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;
 
   template<typename _Fn, typename _Iter>
-    concept indirect_unary_predicate = indirectly_readable<_Iter>
+    concept indirect_unary_predicate = readable<_Iter>
       && copy_constructible<_Fn> && predicate<_Fn&, iter_value_t<_Iter>&>
       && predicate<_Fn&, iter_reference_t<_Iter>>
       && predicate<_Fn&, iter_common_reference_t<_Iter>>;
 
   template<typename _Fn, typename _I1, typename _I2>
-    concept indirect_binary_predicate
-      = indirectly_readable<_I1> && indirectly_readable<_I2>
+    concept indirect_binary_predicate = readable<_I1> && readable<_I2>
       && copy_constructible<_Fn>
       && predicate<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
       && predicate<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
@@ -630,8 +643,7 @@
 		   iter_common_reference_t<_I2>>;
 
   template<typename _Fn, typename _I1, typename _I2 = _I1>
-    concept indirect_equivalence_relation
-      = indirectly_readable<_I1> && indirectly_readable<_I2>
+    concept indirect_equivalence_relation = readable<_I1> && readable<_I2>
       && copy_constructible<_Fn>
       && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
       && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
@@ -642,8 +654,7 @@
 			      iter_common_reference_t<_I2>>;
 
   template<typename _Fn, typename _I1, typename _I2 = _I1>
-    concept indirect_strict_weak_order
-      = indirectly_readable<_I1> && indirectly_readable<_I2>
+    concept indirect_strict_weak_order = readable<_I1> && readable<_I2>
       && copy_constructible<_Fn>
       && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
       && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
@@ -652,14 +663,27 @@
       && strict_weak_order<_Fn&, iter_common_reference_t<_I1>,
 			   iter_common_reference_t<_I2>>;
 
+  namespace __detail
+  {
+    // FIXME: needed due to PR c++/67704
+    template<typename _Fn, typename... _Is>
+      struct __indirect_result
+      { };
+
+    template<typename _Fn, typename... _Is>
+      requires (readable<_Is> && ...)
+	&& invocable<_Fn, iter_reference_t<_Is>...>
+      struct __indirect_result<_Fn, _Is...>
+      : invoke_result<_Fn, iter_reference_t<_Is>...>
+      { };
+  } // namespace __detail
+
   template<typename _Fn, typename... _Is>
-    requires (indirectly_readable<_Is> && ...)
-      && invocable<_Fn, iter_reference_t<_Is>...>
-    using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;
+    using indirect_result_t = typename
+      __detail::__indirect_result<_Fn, _Is...>::type;
 
   /// [projected], projected
-  template<indirectly_readable _Iter,
-	   indirectly_regular_unary_invocable<_Iter> _Proj>
+  template<readable _Iter, indirectly_regular_unary_invocable<_Iter> _Proj>
     struct projected
     {
       using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
@@ -676,24 +700,23 @@
   /// [alg.req.ind.move], concept `indirectly_movable`
 
   template<typename _In, typename _Out>
-    concept indirectly_movable = indirectly_readable<_In>
-      && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;
+    concept indirectly_movable = readable<_In>
+      && writable<_Out, iter_rvalue_reference_t<_In>>;
 
   template<typename _In, typename _Out>
     concept indirectly_movable_storable = indirectly_movable<_In, _Out>
-      && indirectly_writable<_Out, iter_value_t<_In>>
-      && movable<iter_value_t<_In>>
+      && writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>>
       && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
       && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;
 
   /// [alg.req.ind.copy], concept `indirectly_copyable`
   template<typename _In, typename _Out>
-    concept indirectly_copyable = indirectly_readable<_In>
-      && indirectly_writable<_Out, iter_reference_t<_In>>;
+    concept indirectly_copyable = readable<_In>
+      && writable<_Out, iter_reference_t<_In>>;
 
   template<typename _In, typename _Out>
     concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
-      && indirectly_writable<_Out, const iter_value_t<_In>&>
+      && writable<_Out, const iter_value_t<_In>&>
       && copyable<iter_value_t<_In>>
       && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
       && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;
@@ -714,12 +737,12 @@
 	};
 
     template<typename _Xp, typename _Yp>
-      constexpr iter_value_t<_Xp>
+      constexpr iter_value_t<remove_reference_t<_Xp>>
       __iter_exchange_move(_Xp&& __x, _Yp&& __y)
-      noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x)))
+      noexcept(noexcept(iter_value_t<remove_reference_t<_Xp>>(iter_move(__x)))
 	       && noexcept(*__x = iter_move(__y)))
       {
-	iter_value_t<_Xp> __old_value(iter_move(__x));
+	iter_value_t<remove_reference_t<_Xp>> __old_value(iter_move(__x));
 	*__x = iter_move(__y);
 	return __old_value;
       }
@@ -734,9 +757,8 @@
 	  if constexpr (__adl_iswap<_Tp, _Up>)
 	    return noexcept(iter_swap(std::declval<_Tp>(),
 				      std::declval<_Up>()));
-	  else if constexpr (indirectly_readable<_Tp>
-	      && indirectly_readable<_Up>
-	      && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
+	  else if constexpr (readable<_Tp> && readable<_Up>
+	    && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 	    return noexcept(ranges::swap(*std::declval<_Tp>(),
 					 *std::declval<_Up>()));
 	  else
@@ -748,8 +770,8 @@
     public:
       template<typename _Tp, typename _Up>
 	requires __adl_iswap<_Tp, _Up>
-	|| (indirectly_readable<remove_reference_t<_Tp>>
-	    && indirectly_readable<remove_reference_t<_Up>>
+	|| (readable<remove_reference_t<_Tp>>
+	    && readable<remove_reference_t<_Up>>
 	    && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 	|| (indirectly_movable_storable<_Tp, _Up>
 	    && indirectly_movable_storable<_Up, _Tp>)
@@ -759,9 +781,8 @@
 	{
 	  if constexpr (__adl_iswap<_Tp, _Up>)
 	    iter_swap(static_cast<_Tp&&>(__e1), static_cast<_Up&&>(__e2));
-	  else if constexpr (indirectly_readable<_Tp>
-	      && indirectly_readable<_Up>
-	      && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
+	  else if constexpr (readable<_Tp> && readable<_Up>
+	    && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 	    ranges::swap(*__e1, *__e2);
 	  else
 	    *__e1 = __iter_exchange_move(__e2, __e1);
@@ -778,9 +799,8 @@
 
   /// [alg.req.ind.swap], concept `indirectly_swappable`
   template<typename _I1, typename _I2 = _I1>
-    concept indirectly_swappable
-      = indirectly_readable<_I1> && indirectly_readable<_I2>
-      && requires(const _I1 __i1, const _I2 __i2)
+    concept indirectly_swappable = readable<_I1> && readable<_I2>
+      && requires(_I1& __i1, _I2& __i2)
       {
 	ranges::iter_swap(__i1, __i1);
 	ranges::iter_swap(__i2, __i2);
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/random.h gcc-10-20200202/libstdc++-v3/include/bits/random.h
--- gcc-10-20200216/libstdc++-v3/include/bits/random.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/random.h	2020-02-02 23:32:19.000000000 +0100
@@ -60,7 +60,6 @@
       {
 	{ _Gen::min() } -> same_as<invoke_result_t<_Gen&>>;
 	{ _Gen::max() } -> same_as<invoke_result_t<_Gen&>>;
-	requires bool_constant<(_Gen::min() < _Gen::max())>::value;
       };
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/range_cmp.h gcc-10-20200202/libstdc++-v3/include/bits/range_cmp.h
--- gcc-10-20200216/libstdc++-v3/include/bits/range_cmp.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/range_cmp.h	2020-02-02 23:32:19.000000000 +0100
@@ -62,8 +62,7 @@
     // BUILTIN-PTR-CMP(T, ==, U)
     template<typename _Tp, typename _Up>
       concept __eq_builtin_ptr_cmp
-	= requires (_Tp&& __t, _Up&& __u) { { __t == __u } -> same_as<bool>; }
-	  && convertible_to<_Tp, const volatile void*>
+	= convertible_to<_Tp, const volatile void*>
 	  && convertible_to<_Up, const volatile void*>
 	  && (! requires(_Tp&& __t, _Up&& __u)
 	      { operator==(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
@@ -74,8 +73,7 @@
     // BUILTIN-PTR-CMP(T, <, U)
     template<typename _Tp, typename _Up>
       concept __less_builtin_ptr_cmp
-	= requires (_Tp&& __t, _Up&& __u) { { __t < __u } -> same_as<bool>; }
-	  && convertible_to<_Tp, const volatile void*>
+	= convertible_to<_Tp, const volatile void*>
 	  && convertible_to<_Up, const volatile void*>
 	  && (! requires(_Tp&& __t, _Up&& __u)
 	      { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/ranges_algobase.h gcc-10-20200202/libstdc++-v3/include/bits/ranges_algobase.h
--- gcc-10-20200216/libstdc++-v3/include/bits/ranges_algobase.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/ranges_algobase.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,589 +0,0 @@
-// Core algorithmic facilities -*- C++ -*-
-
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// Under Section 7 of GPL version 3, you are granted additional
-// permissions described in the GCC Runtime Library Exception, version
-// 3.1, as published by the Free Software Foundation.
-
-// You should have received a copy of the GNU General Public License and
-// a copy of the GCC Runtime Library Exception along with this program;
-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
-// <http://www.gnu.org/licenses/>.
-
-/** @file bits/ranges_algobase.h
- *  This is an internal header file, included by other library headers.
- *  Do not attempt to use it directly. @headername{algorithm}
- */
-
-#ifndef _RANGES_ALGOBASE_H
-#define _RANGES_ALGOBASE_H 1
-
-#if __cplusplus > 201703L
-
-#include <cmath>
-#include <compare>
-#include <iterator>
-// #include <bits/range_concepts.h>
-#include <ranges>
-#include <bits/invoke.h>
-#include <bits/cpp_type_traits.h> // __is_byte
-
-#if __cpp_lib_concepts
-namespace std _GLIBCXX_VISIBILITY(default)
-{
-_GLIBCXX_BEGIN_NAMESPACE_VERSION
-namespace ranges
-{
-  namespace __detail
-  {
-    template<typename _Tp>
-      constexpr inline bool __is_normal_iterator = false;
-
-    template<typename _Iterator, typename _Container>
-      constexpr inline bool
-	__is_normal_iterator<__gnu_cxx::__normal_iterator<_Iterator,
-							  _Container>> = true;
-
-    template<typename _Tp>
-      constexpr inline bool __is_reverse_iterator = false;
-
-    template<typename _Iterator>
-      constexpr inline bool
-	__is_reverse_iterator<reverse_iterator<_Iterator>> = true;
-
-    template<typename _Tp>
-      constexpr inline bool __is_move_iterator = false;
-
-    template<typename _Iterator>
-      constexpr inline bool
-	__is_move_iterator<move_iterator<_Iterator>> = true;
-  } // namespace __detail
-
-  struct __equal_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
-      constexpr bool
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	// TODO: implement more specializations to at least have parity with
-	// std::equal.
-	if constexpr (__detail::__is_normal_iterator<_Iter1>
-		      || __detail::__is_normal_iterator<_Iter2>)
-	  return (*this)(std::__niter_base(std::move(__first1)),
-			 std::__niter_base(std::move(__last1)),
-			 std::__niter_base(std::move(__first2)),
-			 std::__niter_base(std::move(__last2)),
-			 std::move(__pred),
-			 std::move(__proj1), std::move(__proj2));
-	else if constexpr (sized_sentinel_for<_Sent1, _Iter1>
-			   && sized_sentinel_for<_Sent2, _Iter2>)
-	  {
-	    auto __d1 = ranges::distance(__first1, __last1);
-	    auto __d2 = ranges::distance(__first2, __last2);
-	    if (__d1 != __d2)
-	      return false;
-
-	    using _ValueType1 = iter_value_t<_Iter1>;
-	    using _ValueType2 = iter_value_t<_Iter2>;
-	    constexpr bool __use_memcmp
-	      = ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>)
-		 && is_same_v<_ValueType1, _ValueType2>
-		 && is_pointer_v<_Iter1>
-		 && is_pointer_v<_Iter2>
-		 && is_same_v<_Pred, ranges::equal_to>
-		 && is_same_v<_Proj1, identity>
-		 && is_same_v<_Proj2, identity>);
-	    if constexpr (__use_memcmp)
-	      {
-		if (const size_t __len = (__last1 - __first1))
-		  return !std::__memcmp(__first1, __first2, __len);
-		return true;
-	      }
-	    else
-	      {
-		for (; __first1 != __last1; ++__first1, (void)++__first2)
-		  if (!(bool)std::__invoke(__pred,
-					   std::__invoke(__proj1, *__first1),
-					   std::__invoke(__proj2, *__first2)))
-		    return false;
-		return true;
-	      }
-	  }
-	else
-	  {
-	    for (; __first1 != __last1 && __first2 != __last2;
-		 ++__first1, (void)++__first2)
-	      if (!(bool)std::__invoke(__pred,
-				       std::__invoke(__proj1, *__first1),
-				       std::__invoke(__proj2, *__first2)))
-		return false;
-	    return __first1 == __last1 && __first2 == __last2;
-	  }
-      }
-
-    template<input_range _Range1, input_range _Range2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
-				     _Pred, _Proj1, _Proj2>
-      constexpr bool
-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__pred),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __equal_fn equal{};
-
-  template<typename _Iter, typename _Out>
-    struct copy_result
-    {
-      [[no_unique_address]] _Iter in;
-      [[no_unique_address]] _Out out;
-
-      template<typename _Iter2, typename _Out2>
-	requires convertible_to<const _Iter&, _Iter2>
-	  && convertible_to<const _Out&, _Out2>
-	operator copy_result<_Iter2, _Out2>() const &
-	{ return {in, out}; }
-
-      template<typename _Iter2, typename _Out2>
-	requires convertible_to<_Iter, _Iter2>
-	  && convertible_to<_Out, _Out2>
-	operator copy_result<_Iter2, _Out2>() &&
-	{ return {std::move(in), std::move(out)}; }
-    };
-
-  template<typename _Iter, typename _Out>
-    using move_result = copy_result<_Iter, _Out>;
-
-  template<typename _Iter1, typename _Iter2>
-    using move_backward_result = copy_result<_Iter1, _Iter2>;
-
-  template<typename _Iter1, typename _Iter2>
-    using copy_backward_result = copy_result<_Iter1, _Iter2>;
-
-  template<bool _IsMove,
-	   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
-	   bidirectional_iterator _Out>
-    requires (_IsMove
-	      ? indirectly_movable<_Iter, _Out>
-	      : indirectly_copyable<_Iter, _Out>)
-    constexpr conditional_t<_IsMove,
-			    move_backward_result<_Iter, _Out>,
-			    copy_backward_result<_Iter, _Out>>
-    __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result);
-
-  template<bool _IsMove,
-	   input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	   weakly_incrementable _Out>
-    requires (_IsMove
-	      ? indirectly_movable<_Iter, _Out>
-	      : indirectly_copyable<_Iter, _Out>)
-    constexpr conditional_t<_IsMove,
-			    move_result<_Iter, _Out>,
-			    copy_result<_Iter, _Out>>
-    __copy_or_move(_Iter __first, _Sent __last, _Out __result)
-    {
-      // TODO: implement more specializations to be at least on par with
-      // std::copy/std::move.
-      constexpr bool __normal_iterator_p
-	= (__detail::__is_normal_iterator<_Iter>
-	   || __detail::__is_normal_iterator<_Out>);
-      constexpr bool __reverse_p
-	= (__detail::__is_reverse_iterator<_Iter>
-	   && __detail::__is_reverse_iterator<_Out>);
-      constexpr bool __move_iterator_p = __detail::__is_move_iterator<_Iter>;
-      if constexpr (__move_iterator_p)
-	{
-	  auto [__in, __out]
-	    = ranges::__copy_or_move<true>(std::move(__first).base(),
-					   std::move(__last).base(),
-					   std::move(__result));
-	  return {move_iterator{std::move(__in)}, std::move(__out)};
-	}
-      else if constexpr (__reverse_p)
-	{
-	  auto [__in,__out]
-	    = ranges::__copy_or_move_backward<_IsMove>(__last.base(),
-						       __first.base(),
-						       __result.base());
-	  return {reverse_iterator{std::move(__in)},
-		  reverse_iterator{std::move(__out)}};
-	}
-      else if constexpr (__normal_iterator_p)
-	{
-	  auto [__in,__out]
-	    = ranges::__copy_or_move<_IsMove>(std::__niter_base(__first),
-					      std::__niter_base(__last),
-					      std::__niter_base(__result));
-	  return {std::__niter_wrap(__first, std::move(__in)),
-		  std::__niter_wrap(__result, std::move(__out))};
-	}
-      else if constexpr (sized_sentinel_for<_Sent, _Iter>)
-	{
-	  using _ValueTypeI = iter_value_t<_Iter>;
-	  using _ValueTypeO = iter_value_t<_Out>;
-	  constexpr bool __use_memmove
-	    = (is_trivially_copyable_v<_ValueTypeI>
-	       && is_same_v<_ValueTypeI, _ValueTypeO>
-	       && is_pointer_v<_Iter>
-	       && is_pointer_v<_Out>);
-
-	  if constexpr (__use_memmove)
-	    {
-	      static_assert(_IsMove
-			    ? is_move_assignable_v<_ValueTypeI>
-			    : is_copy_assignable_v<_ValueTypeI>);
-	      auto __num = __last - __first;
-	      if (__num)
-		std::__memmove<_IsMove>(__result, __first, __num);
-	      return {__first + __num, __result + __num};
-	    }
-	  else
-	    {
-	      for (auto __n = __last - __first; __n > 0; --__n)
-		{
-		  if constexpr (_IsMove)
-		    *__result = std::move(*__first);
-		  else
-		    *__result = *__first;
-		  ++__first;
-		  ++__result;
-		}
-	      return {std::move(__first), std::move(__result)};
-	    }
-	}
-      else
-	{
-	  while (__first != __last)
-	    {
-	      if constexpr (_IsMove)
-		*__result = std::move(*__first);
-	      else
-		*__result = *__first;
-	      ++__first;
-	      ++__result;
-	    }
-	  return {std::move(__first), std::move(__result)};
-	}
-    }
-
-  struct __copy_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out>
-      requires indirectly_copyable<_Iter, _Out>
-      constexpr copy_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result) const
-      {
-	return ranges::__copy_or_move<false>(std::move(__first),
-					     std::move(__last),
-					     std::move(__result));
-      }
-
-    template<input_range _Range, weakly_incrementable _Out>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr copy_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result));
-      }
-  };
-
-  inline constexpr __copy_fn copy{};
-
-  struct __move_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out>
-      requires indirectly_movable<_Iter, _Out>
-      constexpr move_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result) const
-      {
-	return ranges::__copy_or_move<true>(std::move(__first),
-					    std::move(__last),
-					    std::move(__result));
-      }
-
-    template<input_range _Range, weakly_incrementable _Out>
-      requires indirectly_movable<iterator_t<_Range>, _Out>
-      constexpr move_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result));
-      }
-  };
-
-  inline constexpr __move_fn move{};
-
-  template<bool _IsMove,
-	   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
-	   bidirectional_iterator _Out>
-    requires (_IsMove
-	      ? indirectly_movable<_Iter, _Out>
-	      : indirectly_copyable<_Iter, _Out>)
-    constexpr conditional_t<_IsMove,
-			    move_backward_result<_Iter, _Out>,
-			    copy_backward_result<_Iter, _Out>>
-    __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result)
-    {
-      // TODO: implement more specializations to be at least on par with
-      // std::copy_backward/std::move_backward.
-      constexpr bool __normal_iterator_p
-	= (__detail::__is_normal_iterator<_Iter>
-	   || __detail::__is_normal_iterator<_Out>);
-      constexpr bool __reverse_p
-	= (__detail::__is_reverse_iterator<_Iter>
-	   && __detail::__is_reverse_iterator<_Out>);
-      if constexpr (__reverse_p)
-	{
-	  auto [__in,__out]
-	    = ranges::__copy_or_move<_IsMove>(__last.base(),
-					      __first.base(),
-					      __result.base());
-	  return {reverse_iterator{std::move(__in)},
-		  reverse_iterator{std::move(__out)}};
-	}
-      else if constexpr (__normal_iterator_p)
-	{
-	  auto [__in,__out]
-	    = ranges::__copy_or_move_backward<_IsMove>
-	      (std::__niter_base(__first),
-	       std::__niter_base(__last),
-	       std::__niter_base(__result));
-	  return {std::__niter_wrap(__first, std::move(__in)),
-		  std::__niter_wrap(__result, std::move(__out))};
-	}
-      else if constexpr (sized_sentinel_for<_Sent, _Iter>)
-	{
-	  using _ValueTypeI = iter_value_t<_Iter>;
-	  using _ValueTypeO = iter_value_t<_Out>;
-	  constexpr bool __use_memmove
-	    = (is_trivially_copyable_v<_ValueTypeI>
-	       && is_same_v<_ValueTypeI, _ValueTypeO>
-	       && is_pointer_v<_Iter>
-	       && is_pointer_v<_Out>);
-	  if constexpr (__use_memmove)
-	    {
-	      static_assert(_IsMove
-			    ? is_move_assignable_v<_ValueTypeI>
-			    : is_copy_assignable_v<_ValueTypeI>);
-	      auto __num = __last - __first;
-	      if (__num)
-		std::__memmove<_IsMove>(__result - __num, __first, __num);
-	      return {__first + __num, __result - __num};
-	    }
-	  else
-	    {
-	      auto __lasti = ranges::next(__first, __last);
-	      auto __tail = __lasti;
-
-	      for (auto __n = __last - __first; __n > 0; --__n)
-		{
-		  --__tail;
-		  --__result;
-		  if constexpr (_IsMove)
-		    *__result = std::move(*__tail);
-		  else
-		    *__result = *__tail;
-		}
-	      return {std::move(__lasti), std::move(__result)};
-	    }
-	}
-      else
-	{
-	  auto __lasti = ranges::next(__first, __last);
-	  auto __tail = __lasti;
-
-	  while (__first != __tail)
-	    {
-	      --__tail;
-	      --__result;
-	      if constexpr (_IsMove)
-		*__result = std::move(*__tail);
-	      else
-		*__result = *__tail;
-	    }
-	  return {std::move(__lasti), std::move(__result)};
-	}
-    }
-
-  struct __copy_backward_fn
-  {
-    template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     bidirectional_iterator _Iter2>
-      requires indirectly_copyable<_Iter1, _Iter2>
-      constexpr copy_backward_result<_Iter1, _Iter2>
-      operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result) const
-      {
-	return ranges::__copy_or_move_backward<false>(std::move(__first),
-						      std::move(__last),
-						      std::move(__result));
-      }
-
-    template<bidirectional_range _Range, bidirectional_iterator _Iter>
-      requires indirectly_copyable<iterator_t<_Range>, _Iter>
-      constexpr copy_backward_result<safe_iterator_t<_Range>, _Iter>
-      operator()(_Range&& __r, _Iter __result) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result));
-      }
-  };
-
-  inline constexpr __copy_backward_fn copy_backward{};
-
-  struct __move_backward_fn
-  {
-    template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     bidirectional_iterator _Iter2>
-      requires indirectly_movable<_Iter1, _Iter2>
-      constexpr move_backward_result<_Iter1, _Iter2>
-      operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result) const
-      {
-	return ranges::__copy_or_move_backward<true>(std::move(__first),
-						     std::move(__last),
-						     std::move(__result));
-      }
-
-    template<bidirectional_range _Range, bidirectional_iterator _Iter>
-      requires indirectly_movable<iterator_t<_Range>, _Iter>
-      constexpr move_backward_result<safe_iterator_t<_Range>, _Iter>
-      operator()(_Range&& __r, _Iter __result) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result));
-      }
-  };
-
-  inline constexpr __move_backward_fn move_backward{};
-
-  template<typename _Iter, typename _Out>
-    using copy_n_result = copy_result<_Iter, _Out>;
-
-  struct __copy_n_fn
-  {
-    template<input_iterator _Iter, weakly_incrementable _Out>
-      requires indirectly_copyable<_Iter, _Out>
-      constexpr copy_n_result<_Iter, _Out>
-      operator()(_Iter __first, iter_difference_t<_Iter> __n,
-		 _Out __result) const
-      {
-	if constexpr (random_access_iterator<_Iter>)
-	  return ranges::copy(__first, __first + __n, std::move(__result));
-	else
-	  {
-	    for (; __n > 0; --__n, (void)++__result, (void)++__first)
-	      *__result = *__first;
-	    return {std::move(__first), std::move(__result)};
-	  }
-      }
-  };
-
-  inline constexpr __copy_n_fn copy_n{};
-
-  struct __fill_n_fn
-  {
-    template<typename _Tp, output_iterator<const _Tp&> _Out>
-      constexpr _Out
-      operator()(_Out __first, iter_difference_t<_Out> __n,
-		 const _Tp& __value) const
-      {
-	// TODO: implement more specializations to be at least on par with
-	// std::fill_n
-	if (__n <= 0)
-	  return __first;
-
-	// TODO: is __is_byte the best condition?
-	if constexpr (is_pointer_v<_Out> && __is_byte<_Tp>::__value)
-	  {
-	    __builtin_memset(__first, static_cast<unsigned char>(__value), __n);
-	    return __first + __n;
-	  }
-	else if constexpr (is_scalar_v<_Tp>)
-	  {
-	    const auto __tmp = __value;
-	    for (; __n > 0; --__n, (void)++__first)
-	      *__first = __tmp;
-	    return __first;
-	  }
-	else
-	  {
-	    for (; __n > 0; --__n, (void)++__first)
-	      *__first = __value;
-	    return __first;
-	  }
-      }
-  };
-
-  inline constexpr __fill_n_fn fill_n{};
-
-  struct __fill_fn
-  {
-    template<typename _Tp,
-	     output_iterator<const _Tp&> _Out, sentinel_for<_Out> _Sent>
-      constexpr _Out
-      operator()(_Out __first, _Sent __last, const _Tp& __value) const
-      {
-	// TODO: implement more specializations to be at least on par with
-	// std::fill
-	if constexpr (sized_sentinel_for<_Sent, _Out>)
-	  {
-	    const auto __len = __last - __first;
-	    return ranges::fill_n(__first, __len, __value);
-	  }
-	else if constexpr (is_scalar_v<_Tp>)
-	  {
-	    const auto __tmp = __value;
-	    for (; __first != __last; ++__first)
-	      *__first = __tmp;
-	    return __first;
-	  }
-	else
-	  {
-	    for (; __first != __last; ++__first)
-	      *__first = __value;
-	    return __first;
-	  }
-      }
-
-    template<typename _Tp, output_range<const _Tp&> _Range>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, const _Tp& __value) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r), __value);
-      }
-  };
-
-  inline constexpr __fill_fn fill{};
-}
-_GLIBCXX_END_NAMESPACE_VERSION
-} // namespace std
-#endif // concepts
-#endif // C++20
-#endif // _RANGES_ALGOBASE_H
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/ranges_algo.h gcc-10-20200202/libstdc++-v3/include/bits/ranges_algo.h
--- gcc-10-20200216/libstdc++-v3/include/bits/ranges_algo.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/ranges_algo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,3536 +0,0 @@
-// Core algorithmic facilities -*- C++ -*-
-
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// Under Section 7 of GPL version 3, you are granted additional
-// permissions described in the GCC Runtime Library Exception, version
-// 3.1, as published by the Free Software Foundation.
-
-// You should have received a copy of the GNU General Public License and
-// a copy of the GCC Runtime Library Exception along with this program;
-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
-// <http://www.gnu.org/licenses/>.
-
-/** @file bits/ranges_algo.h
- *  This is an internal header file, included by other library headers.
- *  Do not attempt to use it directly. @headername{algorithm}
- */
-
-#ifndef _RANGES_ALGO_H
-#define _RANGES_ALGO_H 1
-
-#if __cplusplus > 201703L
-
-#include <bits/ranges_algobase.h>
-#include <bits/random.h> // concept uniform_random_bit_generator
-
-#if __cpp_lib_concepts
-namespace std _GLIBCXX_VISIBILITY(default)
-{
-_GLIBCXX_BEGIN_NAMESPACE_VERSION
-namespace ranges
-{
-  namespace __detail
-  {
-    template<typename _Comp, typename _Proj>
-      constexpr auto
-      __make_comp_proj(_Comp& __comp, _Proj& __proj)
-      {
-	return [&] (auto&& __lhs, auto&& __rhs) -> bool {
-	  using _TL = decltype(__lhs);
-	  using _TR = decltype(__rhs);
-	  return std::__invoke(__comp,
-			       std::__invoke(__proj, std::forward<_TL>(__lhs)),
-			       std::__invoke(__proj, std::forward<_TR>(__rhs)));
-	};
-      }
-
-    template<typename _Pred, typename _Proj>
-      constexpr auto
-      __make_pred_proj(_Pred& __pred, _Proj& __proj)
-      {
-	return [&] <typename _Tp> (_Tp&& __arg) -> bool {
-	  return std::__invoke(__pred,
-			       std::__invoke(__proj, std::forward<_Tp>(__arg)));
-	};
-      }
-  } // namespace __detail
-
-  struct __all_of_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr bool
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (!(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    return false;
-	return true;
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr bool
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __all_of_fn all_of{};
-
-  struct __any_of_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr bool
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    return true;
-	return false;
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr bool
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __any_of_fn any_of{};
-
-  struct __none_of_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr bool
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    return false;
-	return true;
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr bool
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __none_of_fn none_of{};
-
-  template<typename _Iter, typename _Fp>
-    struct for_each_result
-    {
-      [[no_unique_address]] _Iter in;
-      [[no_unique_address]] _Fp fun;
-
-      template<typename _Iter2, typename _F2p>
-	requires convertible_to<const _Iter&, _Iter2>
-	  && convertible_to<const _Fp&, _F2p>
-	operator for_each_result<_Iter2, _F2p>() const &
-	{ return {in, fun}; }
-
-      template<typename _Iter2, typename _F2p>
-	requires convertible_to<_Iter, _Iter2> && convertible_to<_Fp, _F2p>
-	operator for_each_result<_Iter2, _F2p>() &&
-	{ return {std::move(in), std::move(fun)}; }
-    };
-
-  struct __for_each_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirectly_unary_invocable<projected<_Iter, _Proj>> _Fun>
-      constexpr for_each_result<_Iter, _Fun>
-      operator()(_Iter __first, _Sent __last, _Fun __f, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  std::__invoke(__f, std::__invoke(__proj, *__first));
-	return { std::move(__first), std::move(__f) };
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirectly_unary_invocable<projected<iterator_t<_Range>, _Proj>>
-	       _Fun>
-      constexpr for_each_result<safe_iterator_t<_Range>, _Fun>
-      operator()(_Range&& __r, _Fun __f, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__f), std::move(__proj));
-      }
-  };
-
-  inline constexpr __for_each_fn for_each{};
-
-  struct __find_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
-	     typename _Proj = identity>
-      requires indirect_binary_predicate<ranges::equal_to,
-					 projected<_Iter, _Proj>, const _Tp*>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp& __value, _Proj __proj = {}) const
-      {
-	while (__first != __last
-	    && !(std::__invoke(__proj, *__first) == __value))
-	  ++__first;
-	return __first;
-      }
-
-    template<input_range _Range, typename _Tp, typename _Proj = identity>
-      requires indirect_binary_predicate<ranges::equal_to,
-					 projected<iterator_t<_Range>, _Proj>,
-					 const _Tp*>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __find_fn find{};
-
-  struct __find_if_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	while (__first != __last
-	    && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	  ++__first;
-	return __first;
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __find_if_fn find_if{};
-
-  struct __find_if_not_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	while (__first != __last
-	    && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	  ++__first;
-	return __first;
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __find_if_not_fn find_if_not{};
-
-  struct __find_first_of_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
-      constexpr _Iter1
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	for (; __first1 != __last1; ++__first1)
-	  for (auto __iter = __first2; __iter != __last2; ++__iter)
-	    if (std::__invoke(__pred,
-			      std::__invoke(__proj1, *__first1),
-			      std::__invoke(__proj2, *__iter)))
-	      return __first1;
-	return __first1;
-      }
-
-    template<input_range _Range1, forward_range _Range2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
-				     _Pred, _Proj1, _Proj2>
-      constexpr safe_iterator_t<_Range1>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__pred),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __find_first_of_fn find_first_of{};
-
-  struct __count_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, typename _Proj = identity>
-      requires indirect_binary_predicate<ranges::equal_to,
-					 projected<_Iter, _Proj>,
-					 const _Tp*>
-      constexpr iter_difference_t<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp& __value, _Proj __proj = {}) const
-      {
-	iter_difference_t<_Iter> __n = 0;
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__proj, *__first) == __value)
-	    ++__n;
-	return __n;
-      }
-
-    template<input_range _Range, typename _Tp, typename _Proj = identity>
-      requires indirect_binary_predicate<ranges::equal_to,
-					 projected<iterator_t<_Range>, _Proj>,
-					 const _Tp*>
-      constexpr range_difference_t<_Range>
-      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __count_fn count{};
-
-  struct __count_if_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr iter_difference_t<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	iter_difference_t<_Iter> __n = 0;
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    ++__n;
-	return __n;
-      }
-
-    template<input_range _Range,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr range_difference_t<_Range>
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __count_if_fn count_if{};
-
-  template<typename _Iter1, typename _Iter2>
-    struct mismatch_result
-    {
-      [[no_unique_address]] _Iter1 in1;
-      [[no_unique_address]] _Iter2 in2;
-
-      template<typename _IIter1, typename _IIter2>
-	requires convertible_to<const _Iter1&, _IIter1>
-	  && convertible_to<const _Iter2&, _IIter2>
-	operator mismatch_result<_IIter1, _IIter2>() const &
-	{ return {in1, in2}; }
-
-      template<typename _IIter1, typename _IIter2>
-	requires convertible_to<_Iter1, _IIter1>
-	  && convertible_to<_Iter2, _IIter2>
-	operator mismatch_result<_IIter1, _IIter2>() &&
-	{ return {std::move(in1), std::move(in2)}; }
-    };
-
-  struct __mismatch_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
-      constexpr mismatch_result<_Iter1, _Iter2>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	while (__first1 != __last1 && __first2 != __last2
-	       && (bool)std::__invoke(__pred,
-				      std::__invoke(__proj1, *__first1),
-				      std::__invoke(__proj2, *__first2)))
-	{
-	  ++__first1;
-	  ++__first2;
-	}
-	return { std::move(__first1), std::move(__first2) };
-      }
-
-    template<input_range _Range1, input_range _Range2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
-				     _Pred, _Proj1, _Proj2>
-      constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__pred),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __mismatch_fn mismatch{};
-
-  struct __search_fn
-  {
-    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
-      constexpr subrange<_Iter1>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	if (__first1 == __last1 || __first2 == __last2)
-	  return {__first1, __first1};
-
-	for (;;)
-	  {
-	    for (;;)
-	      {
-		if (__first1 == __last1)
-		  return {__first1, __first1};
-		if (std::__invoke(__pred,
-				  std::__invoke(__proj1, *__first1),
-				  std::__invoke(__proj2, *__first2)))
-		  break;
-		++__first1;
-	      }
-	    auto __cur1 = __first1;
-	    auto __cur2 = __first2;
-	    for (;;)
-	      {
-		if (++__cur2 == __last2)
-		  return {__first1, ++__cur1};
-		if (++__cur1 == __last1)
-		  return {__cur1, __cur1};
-		if (!(bool)std::__invoke(__pred,
-					 std::__invoke(__proj1, *__cur1),
-					 std::__invoke(__proj2, *__cur2)))
-		  {
-		    ++__first1;
-		    break;
-		  }
-	      }
-	  }
-      }
-
-    template<forward_range _Range1, forward_range _Range2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
-				     _Pred, _Proj1, _Proj2>
-      constexpr safe_subrange_t<_Range1>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__pred),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __search_fn search{};
-
-  struct __search_n_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
-	     typename _Pred = ranges::equal_to, typename _Proj = identity>
-      requires indirectly_comparable<_Iter, const _Tp*, _Pred, _Proj>
-      constexpr subrange<_Iter>
-      operator()(_Iter __first, _Sent __last, iter_difference_t<_Iter> __count,
-		 const _Tp& __value, _Pred __pred = {}, _Proj __proj = {}) const
-      {
-	if (__count <= 0)
-	  return {__first, __first};
-
-	auto __value_comp = [&] <typename _Rp> (_Rp&& __arg) {
-	    return std::__invoke(__pred, std::forward<_Rp>(__arg), __value);
-	};
-	if (__count == 1)
-	  {
-	    __first = ranges::find_if(std::move(__first), __last,
-				      std::move(__value_comp),
-				      std::move(__proj));
-	    if (__first == __last)
-	      return {__first, __first};
-	    else
-	      {
-		auto __end = __first;
-		return {__first, ++__end};
-	      }
-	  }
-
-	if constexpr (sized_sentinel_for<_Sent, _Iter>)
-	  {
-	    auto __tail_size = __last - __first;
-	    auto __remainder = __count;
-
-	    while (__remainder <= __tail_size)
-	      {
-		__first += __remainder;
-		__tail_size -= __remainder;
-		auto __backtrack = __first;
-		while (__value_comp(std::__invoke(__proj, *--__backtrack)))
-		  {
-		    if (--__remainder == 0)
-		      return {__first - __count, __first};
-		  }
-	      }
-	    auto __i = __first + __tail_size;
-	    return {__i, __i};
-	  }
-	else
-	  {
-	    __first = ranges::find_if(__first, __last, __value_comp, __proj);
-	    while (__first != __last)
-	      {
-		auto __n = __count;
-		auto __i = __first;
-		++__i;
-		while (__i != __last && __n != 1
-		       && __value_comp(std::__invoke(__proj, *__i)))
-		  {
-		    ++__i;
-		    --__n;
-		  }
-		if (__n == 1)
-		  return {__first, __i};
-		if (__i == __last)
-		  return {__i, __i};
-		__first = ranges::find_if(++__i, __last, __value_comp, __proj);
-	      }
-	    return {__first, __first};
-	  }
-      }
-
-    template<forward_range _Range, typename _Tp,
-	     typename _Pred = ranges::equal_to, typename _Proj = identity>
-      requires indirectly_comparable<iterator_t<_Range>, const _Tp*,
-				     _Pred, _Proj>
-      constexpr safe_subrange_t<_Range>
-      operator()(_Range&& __r, range_difference_t<_Range> __count,
-	       const _Tp& __value, _Pred __pred = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__count), __value,
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __search_n_fn search_n{};
-
-  struct __find_end_fn
-  {
-    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
-      constexpr subrange<_Iter1>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	if constexpr (bidirectional_iterator<_Iter1>
-		      && bidirectional_iterator<_Iter2>)
-	  {
-	    auto __i1 = ranges::next(__first1, __last1);
-	    auto __i2 = ranges::next(__first2, __last2);
-	    auto __rresult
-	      = ranges::search(reverse_iterator<_Iter1>{__i1},
-			       reverse_iterator<_Iter1>{__first1},
-			       reverse_iterator<_Iter2>{__i2},
-			       reverse_iterator<_Iter2>{__first2},
-			       std::move(__pred),
-			       std::move(__proj1), std::move(__proj2));
-	    auto __result_first = ranges::end(__rresult).base();
-	    auto __result_last = ranges::begin(__rresult).base();
-	    if (__result_last == __first1)
-	      return {__i1, __i1};
-	    else
-	      return {__result_first, __result_last};
-	  }
-	else
-	  {
-	    auto __i = ranges::next(__first1, __last1);
-	    if (__first2 == __last2)
-	      return {__i, __i};
-
-	    auto __result_begin = __i;
-	    auto __result_end = __i;
-	    for (;;)
-	      {
-		auto __new_range = ranges::search(__first1, __last1,
-						  __first2, __last2,
-						  __pred, __proj1, __proj2);
-		auto __new_result_begin = ranges::begin(__new_range);
-		auto __new_result_end = ranges::end(__new_range);
-		if (__new_result_begin == __last1)
-		  return {__result_begin, __result_end};
-		else
-		  {
-		    __result_begin = __new_result_begin;
-		    __result_end = __new_result_end;
-		    __first1 = __result_begin;
-		    ++__first1;
-		  }
-	      }
-	  }
-      }
-
-    template<forward_range _Range1, forward_range _Range2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
-				     _Pred, _Proj1, _Proj2>
-      constexpr safe_subrange_t<_Range1>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__pred),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __find_end_fn find_end{};
-
-  struct __adjacent_find_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_binary_predicate<projected<_Iter, _Proj>,
-				       projected<_Iter, _Proj>> _Pred
-	       = ranges::equal_to>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return __first;
-	auto __next = __first;
-	for (; ++__next != __last; __first = __next)
-	  {
-	    if (std::__invoke(__pred,
-			      std::__invoke(__proj, *__first),
-			      std::__invoke(__proj, *__next)))
-	      return __first;
-	  }
-	return __next;
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_binary_predicate<
-	       projected<iterator_t<_Range>, _Proj>,
-	       projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Pred __pred = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __adjacent_find_fn adjacent_find{};
-
-  struct __is_permutation_fn
-  {
-    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Proj1 = identity, typename _Proj2 = identity,
-	     indirect_equivalence_relation<projected<_Iter1, _Proj1>,
-					   projected<_Iter2, _Proj2>> _Pred
-	       = ranges::equal_to>
-      constexpr bool
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	constexpr bool __sized_iters
-	  = (sized_sentinel_for<_Sent1, _Iter1>
-	     && sized_sentinel_for<_Sent2, _Iter2>);
-	if constexpr (__sized_iters)
-	  {
-	    auto __d1 = ranges::distance(__first1, __last1);
-	    auto __d2 = ranges::distance(__first2, __last2);
-	    if (__d1 != __d2)
-	      return false;
-	  }
-
-	// Efficiently compare identical prefixes:  O(N) if sequences
-	// have the same elements in the same order.
-	for (; __first1 != __last1 && __first2 != __last2;
-	     ++__first1, (void)++__first2)
-	  if (!(bool)std::__invoke(__pred,
-				   std::__invoke(__proj1, *__first1),
-				   std::__invoke(__proj2, *__first2)))
-	      break;
-
-	if constexpr (__sized_iters)
-	  {
-	    if (__first1 == __last1)
-	      return true;
-	  }
-	else
-	  {
-	    auto __d1 = ranges::distance(__first1, __last1);
-	    auto __d2 = ranges::distance(__first2, __last2);
-	    if (__d1 == 0 && __d2 == 0)
-	      return true;
-	    if (__d1 != __d2)
-	      return false;
-	  }
-
-	for (auto __scan = __first1; __scan != __last1; ++__scan)
-	  {
-	    auto __proj_scan = std::__invoke(__proj1, *__scan);
-	    auto __comp_scan = [&] <typename _Tp> (_Tp&& __arg) {
-	      return std::__invoke(__pred, __proj_scan,
-				   std::forward<_Tp>(__arg));
-	    };
-	    if (__scan != ranges::find_if(__first1, __scan,
-					  __comp_scan, __proj1))
-	      continue; // We've seen this one before.
-
-	    auto __matches = ranges::count_if(__first2, __last2,
-					      __comp_scan, __proj2);
-	    if (__matches == 0
-		|| ranges::count_if(__scan, __last1,
-				    __comp_scan, __proj1) != __matches)
-	      return false;
-	  }
-	return true;
-      }
-
-    template<forward_range _Range1, forward_range _Range2,
-	     typename _Proj1 = identity, typename _Proj2 = identity,
-	     indirect_equivalence_relation<
-	       projected<iterator_t<_Range1>, _Proj1>,
-	       projected<iterator_t<_Range2>, _Proj2>> _Pred = ranges::equal_to>
-      constexpr bool
-      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__pred),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __is_permutation_fn is_permutation{};
-
-  template<typename _Iter, typename _Out>
-    using copy_if_result = copy_result<_Iter, _Out>;
-
-  struct __copy_if_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out, typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      requires indirectly_copyable<_Iter, _Out>
-      constexpr copy_if_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    {
-	      *__result = *__first;
-	      ++__result;
-	    }
-	return {std::move(__first), std::move(__result)};
-      }
-
-    template<input_range _Range, weakly_incrementable _Out,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr copy_if_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __copy_if_fn copy_if{};
-
-  template<typename _Iter1, typename _Iter2>
-    using swap_ranges_result = mismatch_result<_Iter1, _Iter2>;
-
-  struct __swap_ranges_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2>
-      requires indirectly_swappable<_Iter1, _Iter2>
-      constexpr swap_ranges_result<_Iter1, _Iter2>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2) const
-      {
-	for (; __first1 != __last1 && __first2 != __last2;
-	     ++__first1, (void)++__first2)
-	  ranges::iter_swap(__first1, __first2);
-	return {std::move(__first1), std::move(__first2)};
-      }
-
-    template<input_range _Range1, input_range _Range2>
-      requires indirectly_swappable<iterator_t<_Range1>, iterator_t<_Range2>>
-      constexpr swap_ranges_result<safe_iterator_t<_Range1>,
-				   safe_iterator_t<_Range2>>
-      operator()(_Range1&& __r1, _Range2&& __r2) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2));
-      }
-  };
-
-  inline constexpr __swap_ranges_fn swap_ranges{};
-
-  template<typename _Iter, typename _Out>
-    using unary_transform_result = copy_result<_Iter, _Out>;
-
-  template<typename _Iter1, typename _Iter2, typename _Out>
-    struct binary_transform_result
-    {
-      [[no_unique_address]] _Iter1 in1;
-      [[no_unique_address]] _Iter2 in2;
-      [[no_unique_address]] _Out  out;
-
-      template<typename _IIter1, typename _IIter2, typename _OOut>
-	requires convertible_to<const _Iter1&, _IIter1>
-	  && convertible_to<const _Iter2&, _IIter2>
-	  && convertible_to<const _Out&, _OOut>
-	operator binary_transform_result<_IIter1, _IIter2, _OOut>() const &
-	{ return {in1, in2, out}; }
-
-      template<typename _IIter1, typename _IIter2, typename _OOut>
-	requires convertible_to<_Iter1, _IIter1>
-	  && convertible_to<_Iter2, _IIter2>
-	  && convertible_to<_Out, _OOut>
-	operator binary_transform_result<_IIter1, _IIter2, _OOut>() &&
-	{ return {std::move(in1), std::move(in2), std::move(out)}; }
-    };
-
-  struct __transform_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out,
-	     copy_constructible _Fp, typename _Proj = identity>
-      requires indirectly_writable<_Out,
-				   indirect_result_t<_Fp&,
-				     projected<_Iter, _Proj>>>
-      constexpr unary_transform_result<_Iter, _Out>
-      operator()(_Iter __first1, _Sent __last1, _Out __result,
-		 _Fp __op, _Proj __proj = {}) const
-      {
-	for (; __first1 != __last1; ++__first1, (void)++__result)
-	  *__result = std::__invoke(__op, std::__invoke(__proj, *__first1));
-	return {std::move(__first1), std::move(__result)};
-      }
-
-    template<input_range _Range, weakly_incrementable _Out,
-	     copy_constructible _Fp, typename _Proj = identity>
-      requires indirectly_writable<_Out,
-				   indirect_result_t<_Fp&,
-				     projected<iterator_t<_Range>, _Proj>>>
-      constexpr unary_transform_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result, _Fp __op, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result),
-		       std::move(__op), std::move(__proj));
-      }
-
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     weakly_incrementable _Out, copy_constructible _Fp,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_writable<_Out,
-				   indirect_result_t<_Fp&,
-				     projected<_Iter1, _Proj1>,
-				     projected<_Iter2, _Proj2>>>
-      constexpr binary_transform_result<_Iter1, _Iter2, _Out>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2,
-		 _Out __result, _Fp __binary_op,
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	for (; __first1 != __last1 && __first2 != __last2;
-	     ++__first1, (void)++__first2, ++__result)
-	  *__result = std::__invoke(__binary_op,
-				    std::__invoke(__proj1, *__first1),
-				    std::__invoke(__proj2, *__first2));
-	return {std::move(__first1), std::move(__first2), std::move(__result)};
-      }
-
-    template<input_range _Range1, input_range _Range2,
-	     weakly_incrementable _Out, copy_constructible _Fp,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_writable<_Out,
-				   indirect_result_t<_Fp&,
-				     projected<iterator_t<_Range1>, _Proj1>,
-				     projected<iterator_t<_Range2>, _Proj2>>>
-      constexpr binary_transform_result<safe_iterator_t<_Range1>,
-					safe_iterator_t<_Range2>, _Out>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Out __result, _Fp __binary_op,
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__result), std::move(__binary_op),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __transform_fn transform{};
-
-  struct __replace_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp1, typename _Tp2, typename _Proj = identity>
-      requires indirectly_writable<_Iter, const _Tp2&>
-	&& indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>,
-				     const _Tp1*>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp1& __old_value, const _Tp2& __new_value,
-		 _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__proj, *__first) == __old_value)
-	    *__first = __new_value;
-	return __first;
-      }
-
-    template<input_range _Range,
-	     typename _Tp1, typename _Tp2, typename _Proj = identity>
-      requires indirectly_writable<iterator_t<_Range>, const _Tp2&>
-	&& indirect_binary_predicate<ranges::equal_to,
-				     projected<iterator_t<_Range>, _Proj>,
-				     const _Tp1*>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r,
-		 const _Tp1& __old_value, const _Tp2& __new_value,
-		 _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __old_value, __new_value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __replace_fn replace{};
-
-  struct __replace_if_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      requires indirectly_writable<_Iter, const _Tp&>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, const _Tp& __new_value, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    *__first = __new_value;
-	return std::move(__first);
-      }
-
-    template<input_range _Range, typename _Tp, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires indirectly_writable<iterator_t<_Range>, const _Tp&>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r,
-		 _Pred __pred, const _Tp& __new_value, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), __new_value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __replace_if_fn replace_if{};
-
-  template<typename _Iter, typename _Out>
-    using replace_copy_result = copy_result<_Iter, _Out>;
-
-  struct __replace_copy_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp1, typename _Tp2, output_iterator<const _Tp2&> _Out,
-	     typename _Proj = identity>
-      requires indirectly_copyable<_Iter, _Out>
-	&& indirect_binary_predicate<ranges::equal_to,
-				     projected<_Iter, _Proj>, const _Tp1*>
-      constexpr replace_copy_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result,
-		 const _Tp1& __old_value, const _Tp2& __new_value,
-		 _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first, (void)++__result)
-	  if (std::__invoke(__proj, *__first) == __old_value)
-	    *__result = __new_value;
-	  else
-	    *__result = *__first;
-	return {std::move(__first), std::move(__result)};
-      }
-
-    template<input_range _Range, typename _Tp1, typename _Tp2,
-	     output_iterator<const _Tp2&> _Out, typename _Proj = identity>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-	&& indirect_binary_predicate<ranges::equal_to,
-				     projected<iterator_t<_Range>, _Proj>,
-				     const _Tp1*>
-      constexpr replace_copy_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result,
-		 const _Tp1& __old_value, const _Tp2& __new_value,
-		 _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result), __old_value,
-		       __new_value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __replace_copy_fn replace_copy{};
-
-  template<typename _Iter, typename _Out>
-    using replace_copy_if_result = copy_result<_Iter, _Out>;
-
-  struct __replace_copy_if_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, output_iterator<const _Tp&> _Out,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      requires indirectly_copyable<_Iter, _Out>
-      constexpr replace_copy_if_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result,
-		 _Pred __pred, const _Tp& __new_value, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first, (void)++__result)
-	  if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    *__result = __new_value;
-	  else
-	    *__result = *__first;
-	return {std::move(__first), std::move(__result)};
-      }
-
-    template<input_range _Range,
-	     typename _Tp, output_iterator<const _Tp&> _Out,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr replace_copy_if_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result,
-		 _Pred __pred, const _Tp& __new_value, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result), std::move(__pred),
-		       __new_value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __replace_copy_if_fn replace_copy_if{};
-
-  struct __generate_n_fn
-  {
-    template<input_or_output_iterator _Out, copy_constructible _Fp>
-      requires invocable<_Fp&>
-	&& indirectly_writable<_Out, invoke_result_t<_Fp&>>
-      constexpr _Out
-      operator()(_Out __first, iter_difference_t<_Out> __n, _Fp __gen) const
-      {
-	for (; __n > 0; --__n, (void)++__first)
-	  *__first = std::__invoke(__gen);
-	return __first;
-      }
-  };
-
-  inline constexpr __generate_n_fn generate_n{};
-
-  struct __generate_fn
-  {
-    template<input_or_output_iterator _Out, sentinel_for<_Out> _Sent,
-	     copy_constructible _Fp>
-      requires invocable<_Fp&>
-	&& indirectly_writable<_Out, invoke_result_t<_Fp&>>
-      constexpr _Out
-      operator()(_Out __first, _Sent __last, _Fp __gen) const
-      {
-	for (; __first != __last; ++__first)
-	  *__first = std::__invoke(__gen);
-	return __first;
-      }
-
-    template<typename _Range, copy_constructible _Fp>
-      requires invocable<_Fp&> && output_range<_Range, invoke_result_t<_Fp&>>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Fp __gen) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__gen));
-      }
-  };
-
-  inline constexpr __generate_fn generate{};
-
-  struct __remove_if_fn
-  {
-    template<permutable _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr subrange<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	__first = ranges::find_if(__first, __last, __pred, __proj);
-	if (__first == __last)
-	  return {__first, __first};
-
-	auto __result = __first;
-	++__first;
-	for (; __first != __last; ++__first)
-	  if (!(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    {
-	      *__result = std::move(*__first);
-	      ++__result;
-	    }
-
-	return {__result, __first};
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __remove_if_fn remove_if{};
-
-  struct __remove_fn
-  {
-    template<permutable _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, typename _Proj = identity>
-      requires indirect_binary_predicate<ranges::equal_to,
-					 projected<_Iter, _Proj>,
-					 const _Tp*>
-      constexpr subrange<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp& __value, _Proj __proj = {}) const
-      {
-	auto __pred = [&] (auto&& __arg) {
-	  return std::forward<decltype(__arg)>(__arg) == __value;
-	};
-	return ranges::remove_if(__first, __last,
-				 std::move(__pred), std::move(__proj));
-      }
-
-    template<forward_range _Range, typename _Tp, typename _Proj = identity>
-      requires permutable<iterator_t<_Range>>
-	&& indirect_binary_predicate<ranges::equal_to,
-				     projected<iterator_t<_Range>, _Proj>,
-				     const _Tp*>
-      constexpr safe_subrange_t<_Range>
-      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __remove_fn remove{};
-
-  template<typename _Iter, typename _Out>
-    using remove_copy_if_result = copy_result<_Iter, _Out>;
-
-  struct __remove_copy_if_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out, typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      requires indirectly_copyable<_Iter, _Out>
-      constexpr remove_copy_if_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (!(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    {
-	      *__result = *__first;
-	      ++__result;
-	    }
-	return {std::move(__first), std::move(__result)};
-      }
-
-    template<input_range _Range, weakly_incrementable _Out,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr remove_copy_if_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __remove_copy_if_fn remove_copy_if{};
-
-  template<typename _Iter, typename _Out>
-    using remove_copy_result = copy_result<_Iter, _Out>;
-
-  struct __remove_copy_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out, typename _Tp, typename _Proj = identity>
-      requires indirectly_copyable<_Iter, _Out>
-	&& indirect_binary_predicate<ranges::equal_to,
-				     projected<_Iter, _Proj>,
-				     const _Tp*>
-      constexpr remove_copy_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result,
-		 const _Tp& __value, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (!(std::__invoke(__proj, *__first) == __value))
-	    {
-	      *__result = *__first;
-	      ++__result;
-	    }
-	return {std::move(__first), std::move(__result)};
-      }
-
-    template<input_range _Range, weakly_incrementable _Out,
-	     typename _Tp, typename _Proj = identity>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-	&& indirect_binary_predicate<ranges::equal_to,
-				     projected<iterator_t<_Range>, _Proj>,
-				     const _Tp*>
-      constexpr remove_copy_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result,
-		 const _Tp& __value, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result), __value, std::move(__proj));
-      }
-  };
-
-  inline constexpr __remove_copy_fn remove_copy{};
-
-  struct __unique_fn
-  {
-    template<permutable _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_equivalence_relation<
-	       projected<_Iter, _Proj>> _Comp = ranges::equal_to>
-      constexpr subrange<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	__first = ranges::adjacent_find(__first, __last, __comp, __proj);
-	if (__first == __last)
-	  return {__first, __first};
-
-	auto __dest = __first;
-	++__first;
-	while (++__first != __last)
-	  if (!(bool)std::__invoke(__comp,
-				   std::__invoke(__proj, *__dest),
-				   std::__invoke(__proj, *__first)))
-	    *++__dest = std::move(*__first);
-	return {++__dest, __first};
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_equivalence_relation<
-	       projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
-      requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __unique_fn unique{};
-
-  template<typename _Iter, typename _Out>
-    using unique_copy_result = copy_result<_Iter, _Out>;
-
-  struct __unique_copy_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out, typename _Proj = identity,
-	     indirect_equivalence_relation<
-	       projected<_Iter, _Proj>> _Comp = ranges::equal_to>
-      requires indirectly_copyable<_Iter, _Out>
-	&& (forward_iterator<_Iter>
-	    || (input_iterator<_Out>
-		&& same_as<iter_value_t<_Iter>, iter_value_t<_Out>>)
-	    || indirectly_copyable_storable<_Iter, _Out>)
-      constexpr unique_copy_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return {std::move(__first), std::move(__result)};
-
-	// TODO: perform a closer comparison with reference implementations
-	if constexpr (forward_iterator<_Iter>)
-	  {
-	    auto __next = __first;
-	    *__result = *__next;
-	    while (++__next != __last)
-	      if (!(bool)std::__invoke(__comp,
-				       std::__invoke(__proj, *__first),
-				       std::__invoke(__proj, *__next)))
-		{
-		  __first = __next;
-		  *++__result = *__first;
-		}
-	    return {__next, std::move(++__result)};
-	  }
-	else if constexpr (input_iterator<_Out>
-			   && same_as<iter_value_t<_Iter>, iter_value_t<_Out>>)
-	  {
-	    *__result = *__first;
-	    while (++__first != __last)
-	      if (!(bool)std::__invoke(__comp,
-				       std::__invoke(__proj, *__result),
-				       std::__invoke(__proj, *__first)))
-		  *++__result = *__first;
-	    return {std::move(__first), std::move(++__result)};
-	  }
-	else // indirectly_copyable_storable<_Iter, _Out>
-	  {
-	    auto __value = *__first;
-	    *__result = __value;
-	    while (++__first != __last)
-	      {
-		if (!(bool)std::__invoke(__comp,
-					 std::__invoke(__proj, *__first),
-					 std::__invoke(__proj, __value)))
-		  {
-		    __value = *__first;
-		    *++__result = __value;
-		  }
-	      }
-	    return {std::move(__first), std::move(++__result)};
-	  }
-      }
-
-    template<input_range _Range,
-	     weakly_incrementable _Out, typename _Proj = identity,
-	     indirect_equivalence_relation<
-	       projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-	&& (forward_iterator<iterator_t<_Range>>
-	    || (input_iterator<_Out>
-		&& same_as<range_value_t<_Range>, iter_value_t<_Out>>)
-	    || indirectly_copyable_storable<iterator_t<_Range>, _Out>)
-      constexpr unique_copy_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __unique_copy_fn unique_copy{};
-
-  struct __reverse_fn
-  {
-    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent>
-      requires permutable<_Iter>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last) const
-      {
-	auto __i = ranges::next(__first, __last);
-	auto __tail = __i;
-
-	if constexpr (random_access_iterator<_Iter>)
-	  {
-	    if (__first != __last)
-	      {
-		--__tail;
-		while (__first < __tail)
-		  {
-		    ranges::iter_swap(__first, __tail);
-		    ++__first;
-		    --__tail;
-		  }
-	      }
-	    return __i;
-	  }
-	else
-	  {
-	    for (;;)
-	      if (__first == __tail || __first == --__tail)
-		break;
-	      else
-		{
-		  ranges::iter_swap(__first, __tail);
-		  ++__first;
-		}
-	    return __i;
-	  }
-      }
-
-    template<bidirectional_range _Range>
-      requires permutable<iterator_t<_Range>>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r));
-      }
-  };
-
-  inline constexpr __reverse_fn reverse{};
-
-  template<typename _Iter, typename _Out>
-    using reverse_copy_result = copy_result<_Iter, _Out>;
-
-  struct __reverse_copy_fn
-  {
-    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out>
-      requires indirectly_copyable<_Iter, _Out>
-      constexpr reverse_copy_result<_Iter, _Out>
-      operator()(_Iter __first, _Sent __last, _Out __result) const
-      {
-	auto __i = ranges::next(__first, __last);
-	auto __tail = __i;
-	while (__first != __tail)
-	  {
-	    --__tail;
-	    *__result = *__tail;
-	    ++__result;
-	  }
-	return {__i, __result};
-      }
-
-    template<bidirectional_range _Range, weakly_incrementable _Out>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr reverse_copy_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, _Out __result) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__result));
-      }
-  };
-
-  inline constexpr __reverse_copy_fn reverse_copy{};
-
-  struct __rotate_fn
-  {
-    template<permutable _Iter, sentinel_for<_Iter> _Sent>
-      constexpr subrange<_Iter>
-      operator()(_Iter __first, _Iter __middle, _Sent __last) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	if (__first == __middle)
-	  return {__lasti, __lasti};
-	if (__last == __middle)
-	  return {std::move(__first), std::move(__lasti)};
-
-	if constexpr (random_access_iterator<_Iter>)
-	  {
-	    auto __n = __lasti - __first;
-	    auto __k = __middle - __first;
-
-	    if (__k == __n - __k)
-	      {
-		ranges::swap_ranges(__first, __middle, __middle, __middle + __k);
-		return {std::move(__middle), std::move(__lasti)};
-	      }
-
-	    auto __p = __first;
-	    auto __ret = __first + (__lasti - __middle);
-
-	    for (;;)
-	      {
-		if (__k < __n - __k)
-		  {
-		    // TODO: is_pod is deprecated, but this condition is
-		    // consistent with the STL implementation.
-		    if constexpr (__is_pod(iter_value_t<_Iter>))
-		      if (__k == 1)
-			{
-			  auto __t = std::move(*__p);
-			  ranges::move(__p + 1, __p + __n, __p);
-			  *(__p + __n - 1) = std::move(__t);
-			  return {std::move(__ret), std::move(__lasti)};
-			}
-		    auto __q = __p + __k;
-		    for (decltype(__n) __i = 0; __i < __n - __k; ++ __i)
-		      {
-			ranges::iter_swap(__p, __q);
-			++__p;
-			++__q;
-		      }
-		    __n %= __k;
-		    if (__n == 0)
-		      return {std::move(__ret), std::move(__lasti)};
-		    ranges::swap(__n, __k);
-		    __k = __n - __k;
-		  }
-		else
-		  {
-		    __k = __n - __k;
-		    // TODO: is_pod is deprecated, but this condition is
-		    // consistent with the STL implementation.
-		    if constexpr (__is_pod(iter_value_t<_Iter>))
-		      if (__k == 1)
-			{
-			  auto __t = std::move(*(__p + __n - 1));
-			  ranges::move_backward(__p, __p + __n - 1, __p + __n);
-			  *__p = std::move(__t);
-			  return {std::move(__ret), std::move(__lasti)};
-			}
-		    auto __q = __p + __n;
-		    __p = __q - __k;
-		    for (decltype(__n) __i = 0; __i < __n - __k; ++ __i)
-		      {
-			--__p;
-			--__q;
-			ranges::iter_swap(__p, __q);
-		      }
-		    __n %= __k;
-		    if (__n == 0)
-		      return {std::move(__ret), std::move(__lasti)};
-		    std::swap(__n, __k);
-		  }
-	      }
-	  }
-	else if constexpr (bidirectional_iterator<_Iter>)
-	  {
-	    auto __tail = __lasti;
-
-	    ranges::reverse(__first, __middle);
-	    ranges::reverse(__middle, __tail);
-
-	    while (__first != __middle && __middle != __tail)
-	      {
-		ranges::iter_swap(__first, --__tail);
-		++__first;
-	      }
-
-	    if (__first == __middle)
-	      {
-		ranges::reverse(__middle, __tail);
-		return {std::move(__tail), std::move(__lasti)};
-	      }
-	    else
-	      {
-		ranges::reverse(__first, __middle);
-		return {std::move(__first), std::move(__lasti)};
-	      }
-	  }
-	else
-	  {
-	    auto __first2 = __middle;
-	    do
-	      {
-		ranges::iter_swap(__first, __first2);
-		++__first;
-		++__first2;
-		if (__first == __middle)
-		  __middle = __first2;
-	      } while (__first2 != __last);
-
-	    auto __ret = __first;
-
-	    __first2 = __middle;
-
-	    while (__first2 != __last)
-	      {
-		ranges::iter_swap(__first, __first2);
-		++__first;
-		++__first2;
-		if (__first == __middle)
-		  __middle = __first2;
-		else if (__first2 == __last)
-		  __first2 = __middle;
-	      }
-	    return {std::move(__ret), std::move(__lasti)};
-	  }
-      }
-
-    template<forward_range _Range>
-      requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
-      operator()(_Range&& __r, iterator_t<_Range> __middle) const
-      {
-	return (*this)(ranges::begin(__r), std::move(__middle),
-		       ranges::end(__r));
-      }
-  };
-
-  inline constexpr __rotate_fn rotate{};
-
-  template<typename _Iter, typename _Out>
-    using rotate_copy_result = copy_result<_Iter, _Out>;
-
-  struct __rotate_copy_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out>
-      requires indirectly_copyable<_Iter, _Out>
-      constexpr rotate_copy_result<_Iter, _Out>
-      operator()(_Iter __first, _Iter __middle, _Sent __last,
-		 _Out __result) const
-      {
-	auto __copy1 = ranges::copy(__middle,
-				    std::move(__last),
-				    std::move(__result));
-	auto __copy2 = ranges::copy(std::move(__first),
-				    std::move(__middle),
-				    std::move(__copy1.out));
-	return { std::move(__copy1.in), std::move(__copy2.out) };
-      }
-
-    template<forward_range _Range, weakly_incrementable _Out>
-      requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr rotate_copy_result<safe_iterator_t<_Range>, _Out>
-      operator()(_Range&& __r, iterator_t<_Range> __middle, _Out __result) const
-      {
-	return (*this)(ranges::begin(__r), std::move(__middle),
-		       ranges::end(__r), std::move(__result));
-      }
-  };
-
-  inline constexpr __rotate_copy_fn rotate_copy{};
-
-#ifdef _GLIBCXX_USE_C99_STDINT_TR1
-  struct __shuffle_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Gen>
-      requires permutable<_Iter>
-	&& uniform_random_bit_generator<remove_reference_t<_Gen>>
-      _Iter
-      operator()(_Iter __first, _Sent __last, _Gen&& __g) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::shuffle(std::move(__first), __lasti, std::forward<_Gen>(__g));
-	return __lasti;
-      }
-
-    template<random_access_range _Range, typename _Gen>
-      requires permutable<iterator_t<_Range>>
-	&& uniform_random_bit_generator<remove_reference_t<_Gen>>
-      safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Gen&& __g) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::forward<_Gen>(__g));
-      }
-  };
-
-  inline constexpr __shuffle_fn shuffle{};
-#endif
-
-  struct __push_heap_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::push_heap(__first, __lasti,
-		       __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __push_heap_fn push_heap{};
-
-  struct __pop_heap_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::pop_heap(__first, __lasti,
-		      __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __pop_heap_fn pop_heap{};
-
-  struct __make_heap_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::make_heap(__first, __lasti,
-		       __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __make_heap_fn make_heap{};
-
-  struct __sort_heap_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::sort_heap(__first, __lasti,
-		       __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __sort_heap_fn sort_heap{};
-
-  struct __is_heap_until_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	iter_difference_t<_Iter> __n = ranges::distance(__first, __last);
-	iter_difference_t<_Iter> __parent = 0, __child = 1;
-	for (; __child < __n; ++__child)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj, *(__first + __parent)),
-			    std::__invoke(__proj, *(__first + __child))))
-	    return __first + __child;
-	  else if ((__child & 1) == 0)
-	    ++__parent;
-
-	return __first + __n;
-      }
-
-    template<random_access_range _Range,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __is_heap_until_fn is_heap_until{};
-
-  struct __is_heap_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (__last
-		== ranges::is_heap_until(__first, __last,
-					 std::move(__comp),
-					 std::move(__proj)));
-      }
-
-    template<random_access_range _Range,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __is_heap_fn is_heap{};
-
-  struct __sort_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::sort(std::move(__first), __lasti,
-		  __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __sort_fn sort{};
-
-  struct __stable_sort_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::stable_sort(std::move(__first), __lasti,
-			 __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __stable_sort_fn stable_sort{};
-
-  struct __partial_sort_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr _Iter
-      operator()(_Iter __first, _Iter __middle, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __middle)
-	  return ranges::next(__first, __last);
-
-	ranges::make_heap(__first, __middle, __comp, __proj);
-	auto __i = __middle;
-	for (; __i != __last; ++__i)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj, *__i),
-			    std::__invoke(__proj, *__first)))
-	    {
-	      ranges::pop_heap(__first, __middle, __comp, __proj);
-	      ranges::iter_swap(__middle-1, __i);
-	      ranges::push_heap(__first, __middle, __comp, __proj);
-	    }
-	ranges::sort_heap(__first, __middle, __comp, __proj);
-
-	return __i;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, iterator_t<_Range> __middle,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), std::move(__middle),
-		       ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __partial_sort_fn partial_sort{};
-
-  template<typename _Iter, typename _Out>
-    using partial_sort_copy_result = copy_result<_Iter, _Out>;
-
-  struct __partial_sort_copy_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     random_access_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_copyable<_Iter1, _Iter2>
-	&& sortable<_Iter2, _Comp, _Proj2>
-	&& indirect_strict_weak_order<_Comp,
-				      projected<_Iter1, _Proj1>,
-				      projected<_Iter2, _Proj2>>
-      constexpr partial_sort_copy_result<_Iter1, _Iter2>
-      operator()(_Iter1 __first, _Sent1 __last,
-		 _Iter2 __result_first, _Sent2 __result_last,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	if (__result_first == __result_last)
-	  {
-	    // TODO: Eliminating the variable __lasti triggers an ICE.
-	    auto __lasti = ranges::next(std::move(__first),
-					std::move(__last));
-	    return {std::move(__lasti), std::move(__result_first)};
-	  }
-
-	auto __result_real_last = __result_first;
-	while (__first != __last && __result_real_last != __result_last)
-	  {
-	    *__result_real_last = *__first;
-	    ++__result_real_last;
-	    ++__first;
-	  }
-
-	ranges::make_heap(__result_first, __result_real_last, __comp, __proj2);
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj1, *__first),
-			    std::__invoke(__proj2, *__result_first)))
-	    {
-	      ranges::pop_heap(__result_first, __result_real_last,
-			       __comp, __proj2);
-	      *(__result_real_last-1) = *__first;
-	      ranges::push_heap(__result_first, __result_real_last,
-				__comp, __proj2);
-	    }
-	ranges::sort_heap(__result_first, __result_real_last, __comp, __proj2);
-
-	return {std::move(__first), std::move(__result_real_last)};
-      }
-
-    template<input_range _Range1, random_access_range _Range2,
-	     typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_copyable<iterator_t<_Range1>, iterator_t<_Range2>>
-	&& sortable<iterator_t<_Range2>, _Comp, _Proj2>
-	&& indirect_strict_weak_order<_Comp,
-				      projected<iterator_t<_Range1>, _Proj1>,
-				      projected<iterator_t<_Range2>, _Proj2>>
-      constexpr partial_sort_copy_result<safe_iterator_t<_Range1>,
-					 safe_iterator_t<_Range2>>
-      operator()(_Range1&& __r, _Range2&& __out, _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       ranges::begin(__out), ranges::end(__out),
-		       std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __partial_sort_copy_fn partial_sort_copy{};
-
-  struct __is_sorted_until_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return __first;
-
-	auto __next = __first;
-	for (++__next; __next != __last; __first = __next, (void)++__next)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj, *__next),
-			    std::__invoke(__proj, *__first)))
-	    return __next;
-	return __next;
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __is_sorted_until_fn is_sorted_until{};
-
-  struct __is_sorted_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return true;
-
-	auto __next = __first;
-	for (++__next; __next != __last; __first = __next, (void)++__next)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj, *__next),
-			    std::__invoke(__proj, *__first)))
-	    return false;
-	return true;
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __is_sorted_fn is_sorted{};
-
-  struct __nth_element_fn
-  {
-    template<random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr _Iter
-      operator()(_Iter __first, _Iter __nth, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::nth_element(std::move(__first), std::move(__nth), __lasti,
-			 __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<random_access_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, iterator_t<_Range> __nth,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), std::move(__nth),
-		       ranges::end(__r), std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __nth_element_fn nth_element{};
-
-  struct __lower_bound_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*, projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __len = ranges::distance(__first, __last);
-
-	while (__len > 0)
-	  {
-	    auto __half = __len / 2;
-	    auto __middle = __first;
-	    ranges::advance(__middle, __half);
-	    if (std::__invoke(__comp, std::__invoke(__proj, *__middle), __value))
-	      {
-		__first = __middle;
-		++__first;
-		__len = __len - __half - 1;
-	      }
-	    else
-	      __len = __half;
-	  }
-	return __first;
-      }
-
-    template<forward_range _Range, typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*,
-					projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r,
-		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __value, std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __lower_bound_fn lower_bound{};
-
-  struct __upper_bound_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*, projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __len = ranges::distance(__first, __last);
-
-	while (__len > 0)
-	  {
-	    auto __half = __len / 2;
-	    auto __middle = __first;
-	    ranges::advance(__middle, __half);
-	    if (std::__invoke(__comp, __value, std::__invoke(__proj, *__middle)))
-	      __len = __half;
-	    else
-	      {
-		__first = __middle;
-		++__first;
-		__len = __len - __half - 1;
-	      }
-	  }
-	return __first;
-      }
-
-    template<forward_range _Range, typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*,
-					projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r,
-		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __value, std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __upper_bound_fn upper_bound{};
-
-  struct __equal_range_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*, projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr subrange<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __len = ranges::distance(__first, __last);
-
-	while (__len > 0)
-	  {
-	    auto __half = __len / 2;
-	    auto __middle = __first;
-	    ranges::advance(__middle, __half);
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, *__middle),
-			      __value))
-	      {
-		__first = __middle;
-		++__first;
-		__len = __len - __half - 1;
-	      }
-	    else if (std::__invoke(__comp,
-				   __value,
-				   std::__invoke(__proj, *__middle)))
-	      __len = __half;
-	    else
-	      {
-		auto __left
-		  = ranges::lower_bound(__first, __middle,
-					__value, __comp, __proj);
-		ranges::advance(__first, __len);
-		auto __right
-		  = ranges::upper_bound(++__middle, __first,
-					__value, __comp, __proj);
-		return {__left, __right};
-	      }
-	  }
-	return {__first, __first};
-      }
-
-    template<forward_range _Range,
-	     typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*,
-					projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr safe_subrange_t<_Range>
-      operator()(_Range&& __r, const _Tp& __value,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __value, std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __equal_range_fn equal_range{};
-
-  struct __binary_search_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*, projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Iter __first, _Sent __last,
-		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __i = ranges::lower_bound(__first, __last, __value, __comp, __proj);
-	if (__i == __last)
-	  return false;
-	return !(bool)std::__invoke(__comp, __value,
-				    std::__invoke(__proj, *__i));
-      }
-
-    template<forward_range _Range,
-	     typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<const _Tp*,
-					projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Range&& __r, const _Tp& __value, _Comp __comp = {},
-		 _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       __value, std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __binary_search_fn binary_search{};
-
-  struct __is_partitioned_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr bool
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	__first = ranges::find_if_not(std::move(__first), __last,
-				      __pred, __proj);
-	if (__first == __last)
-	  return true;
-	++__first;
-	return ranges::none_of(std::move(__first), std::move(__last),
-			       std::move(__pred), std::move(__proj));
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr bool
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __is_partitioned_fn is_partitioned{};
-
-  struct __partition_fn
-  {
-    template<permutable _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr subrange<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	if constexpr (bidirectional_iterator<_Iter>)
-	  {
-	    auto __lasti = ranges::next(__first, __last);
-	    auto __tail = __lasti;
-	    for (;;)
-	      {
-		for (;;)
-		  if (__first == __tail)
-		    return {std::move(__first), std::move(__lasti)};
-		  else if (std::__invoke(__pred,
-					 std::__invoke(__proj, *__first)))
-		    ++__first;
-		  else
-		    break;
-		--__tail;
-		for (;;)
-		  if (__first == __tail)
-		    return {std::move(__first), std::move(__lasti)};
-		  else if (!(bool)std::__invoke(__pred,
-						std::__invoke(__proj, *__tail)))
-		    --__tail;
-		  else
-		    break;
-		ranges::iter_swap(__first, __tail);
-		++__first;
-	      }
-	  }
-	else
-	  {
-	    if (__first == __last)
-	      return {std::move(__first), std::move(__first)};
-
-	    while (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	      if (++__first == __last)
-		return {std::move(__first), std::move(__first)};
-
-	    auto __next = __first;
-	    while (++__next != __last)
-	      if (std::__invoke(__pred, std::__invoke(__proj, *__next)))
-		{
-		  ranges::iter_swap(__first, __next);
-		  ++__first;
-		}
-
-	    return {std::move(__first), std::move(__next)};
-	  }
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __partition_fn partition{};
-
-  struct __stable_partition_fn
-  {
-    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      requires permutable<_Iter>
-      subrange<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	auto __middle
-	  = std::stable_partition(std::move(__first), __lasti,
-				  __detail::__make_pred_proj(__pred, __proj));
-	return {std::move(__middle), std::move(__lasti)};
-      }
-
-    template<bidirectional_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires permutable<iterator_t<_Range>>
-      safe_subrange_t<_Range>
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __stable_partition_fn stable_partition{};
-
-  template<typename _Iter, typename _Out1, typename _O2>
-    struct partition_copy_result
-    {
-      [[no_unique_address]] _Iter  in;
-      [[no_unique_address]] _Out1 out1;
-      [[no_unique_address]] _O2 out2;
-
-      template<typename _IIter, typename _OOut1, typename _OOut2>
-	requires convertible_to<const _Iter&, _IIter>
-	  && convertible_to<const _Out1&, _OOut1>
-	  && convertible_to<const _O2&, _OOut2>
-	operator partition_copy_result<_IIter, _OOut1, _OOut2>() const &
-	{ return {in, out1, out2}; }
-
-      template<typename _IIter, typename _OOut1, typename _OOut2>
-	requires convertible_to<_Iter, _IIter>
-	  && convertible_to<_Out1, _OOut1>
-	  && convertible_to<_O2, _OOut2>
-	operator partition_copy_result<_IIter, _OOut1, _OOut2>() &&
-	{ return {std::move(in), std::move(out1), std::move(out2)}; }
-    };
-
-  struct __partition_copy_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     weakly_incrementable _Out1, weakly_incrementable _O2,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      requires indirectly_copyable<_Iter, _Out1>
-	&& indirectly_copyable<_Iter, _O2>
-      constexpr partition_copy_result<_Iter, _Out1, _O2>
-      operator()(_Iter __first, _Sent __last,
-		 _Out1 __out_true, _O2 __out_false,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	for (; __first != __last; ++__first)
-	  if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	    {
-	      *__out_true = *__first;
-	      ++__out_true;
-	    }
-	  else
-	    {
-	      *__out_false = *__first;
-	      ++__out_false;
-	    }
-
-	return {std::move(__first),
-		std::move(__out_true), std::move(__out_false)};
-      }
-
-    template<input_range _Range, weakly_incrementable _Out1,
-	     weakly_incrementable _O2,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      requires indirectly_copyable<iterator_t<_Range>, _Out1>
-	&& indirectly_copyable<iterator_t<_Range>, _O2>
-      constexpr partition_copy_result<safe_iterator_t<_Range>, _Out1, _O2>
-      operator()(_Range&& __r, _Out1 out_true, _O2 out_false,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(out_true), std::move(out_false),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __partition_copy_fn partition_copy{};
-
-  struct __partition_point_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Pred __pred, _Proj __proj = {}) const
-      {
-	auto __len = ranges::distance(__first, __last);
-
-	while (__len > 0)
-	  {
-	    auto __half = __len / 2;
-	    auto __middle = __first;
-	    ranges::advance(__middle, __half);
-	    if (std::__invoke(__pred, std::__invoke(__proj, *__middle)))
-	      {
-		__first = __middle;
-		++__first;
-		__len = __len - __half - 1;
-	      }
-	    else
-	      __len = __half;
-	  }
-	return __first;
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
-	       _Pred>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__pred), std::move(__proj));
-      }
-  };
-
-  inline constexpr __partition_point_fn partition_point{};
-
-  template<typename _Iter1, typename _Iter2, typename _Out>
-    using merge_result = binary_transform_result<_Iter1, _Iter2, _Out>;
-
-  struct __merge_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     weakly_incrementable _Out, typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
-      constexpr merge_result<_Iter1, _Iter2, _Out>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Out __result,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	while (__first1 != __last1 && __first2 != __last2)
-	  {
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj2, *__first2),
-			      std::__invoke(__proj1, *__first1)))
-	      {
-		*__result = *__first2;
-		++__first2;
-	      }
-	    else
-	      {
-		*__result = *__first1;
-		++__first1;
-	      }
-	    ++__result;
-	  }
-	auto __copy1 = ranges::copy(std::move(__first1), std::move(__last1),
-				    std::move(__result));
-	auto __copy2 = ranges::copy(std::move(__first2), std::move(__last2),
-				    std::move(__copy1.out));
-	return { std::move(__copy1.in), std::move(__copy2.in),
-		 std::move(__copy2.out) };
-      }
-
-    template<input_range _Range1, input_range _Range2, weakly_incrementable _Out,
-	     typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
-			 _Comp, _Proj1, _Proj2>
-      constexpr merge_result<safe_iterator_t<_Range1>,
-			     safe_iterator_t<_Range2>,
-			     _Out>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__result), std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __merge_fn merge{};
-
-  struct __inplace_merge_fn
-  {
-    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less,
-	     typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      _Iter
-      operator()(_Iter __first, _Iter __middle, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __lasti = ranges::next(__first, __last);
-	std::inplace_merge(std::move(__first), std::move(__middle), __lasti,
-			   __detail::__make_comp_proj(__comp, __proj));
-	return __lasti;
-      }
-
-    template<bidirectional_range _Range,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      safe_iterator_t<_Range>
-      operator()(_Range&& __r, iterator_t<_Range> __middle,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), std::move(__middle),
-		       ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __inplace_merge_fn inplace_merge{};
-
-  struct __includes_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Proj1 = identity, typename _Proj2 = identity,
-	     indirect_strict_weak_order<projected<_Iter1, _Proj1>,
-					projected<_Iter2, _Proj2>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	while (__first1 != __last1 && __first2 != __last2)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj2, *__first2),
-			    std::__invoke(__proj1, *__first1)))
-	    return false;
-	  else if (std::__invoke(__comp,
-				 std::__invoke(__proj1, *__first1),
-				 std::__invoke(__proj2, *__first2)))
-	    ++__first1;
-	  else
-	    {
-	      ++__first1;
-	      ++__first2;
-	    }
-
-	return __first2 == __last2;
-      }
-
-    template<input_range _Range1, input_range _Range2,
-	     typename _Proj1 = identity, typename _Proj2 = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>,
-					projected<iterator_t<_Range2>, _Proj2>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Range1&& __r1, _Range2&& __r2, _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __includes_fn includes{};
-
-  template<typename _Iter1, typename _Iter2, typename _Out>
-    using set_union_result = binary_transform_result<_Iter1, _Iter2, _Out>;
-
-  struct __set_union_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     weakly_incrementable _Out, typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
-      constexpr set_union_result<_Iter1, _Iter2, _Out>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2,
-		 _Out __result, _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	while (__first1 != __last1 && __first2 != __last2)
-	  {
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj1, *__first1),
-			      std::__invoke(__proj2, *__first2)))
-	      {
-		*__result = *__first1;
-		++__first1;
-	      }
-	    else if (std::__invoke(__comp,
-				   std::__invoke(__proj2, *__first2),
-				   std::__invoke(__proj1, *__first1)))
-	      {
-		*__result = *__first2;
-		++__first2;
-	      }
-	    else
-	      {
-		*__result = *__first1;
-		++__first1;
-		++__first2;
-	      }
-	    ++__result;
-	  }
-	auto __copy1 = ranges::copy(std::move(__first1), std::move(__last1),
-				    std::move(__result));
-	auto __copy2 = ranges::copy(std::move(__first2), std::move(__last2),
-				    std::move(__copy1.out));
-	return {std::move(__copy1.in), std::move(__copy2.in),
-		std::move(__copy2.out)};
-      }
-
-    template<input_range _Range1, input_range _Range2, weakly_incrementable _Out,
-	     typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
-			 _Comp, _Proj1, _Proj2>
-      constexpr set_union_result<safe_iterator_t<_Range1>,
-				 safe_iterator_t<_Range2>, _Out>
-      operator()(_Range1&& __r1, _Range2&& __r2,
-		 _Out __result, _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__result), std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __set_union_fn set_union{};
-
-  template<typename _Iter1, typename _Iter2, typename _Out>
-    using set_intersection_result
-      = binary_transform_result<_Iter1, _Iter2, _Out>;
-
-  struct __set_intersection_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     weakly_incrementable _Out, typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
-      constexpr set_intersection_result<_Iter1, _Iter2, _Out>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Out __result,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	while (__first1 != __last1 && __first2 != __last2)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj1, *__first1),
-			    std::__invoke(__proj2, *__first2)))
-	    ++__first1;
-	  else if (std::__invoke(__comp,
-				 std::__invoke(__proj2, *__first2),
-				 std::__invoke(__proj1, *__first1)))
-	    ++__first2;
-	  else
-	    {
-	      *__result = *__first1;
-	      ++__first1;
-	      ++__first2;
-	      ++__result;
-	    }
-	// TODO: Eliminating these variables triggers an ICE.
-	auto __last1i = ranges::next(std::move(__first1), std::move(__last1));
-	auto __last2i = ranges::next(std::move(__first2), std::move(__last2));
-	return {std::move(__last1i), std::move(__last2i), std::move(__result)};
-      }
-
-    template<input_range _Range1, input_range _Range2, weakly_incrementable _Out,
-	     typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
-			 _Comp, _Proj1, _Proj2>
-      constexpr set_intersection_result<safe_iterator_t<_Range1>,
-					safe_iterator_t<_Range2>, _Out>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__result), std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __set_intersection_fn set_intersection{};
-
-  template<typename _Iter, typename _Out>
-    using set_difference_result = copy_result<_Iter, _Out>;
-
-  struct __set_difference_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     weakly_incrementable _Out, typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
-      constexpr set_difference_result<_Iter1, _Out>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2, _Out __result,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	while (__first1 != __last1 && __first2 != __last2)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj1, *__first1),
-			    std::__invoke(__proj2, *__first2)))
-	    {
-	      *__result = *__first1;
-	      ++__first1;
-	      ++__result;
-	    }
-	  else if (std::__invoke(__comp,
-				 std::__invoke(__proj2, *__first2),
-				 std::__invoke(__proj1, *__first1)))
-	    ++__first2;
-	  else
-	    {
-	      ++__first1;
-	      ++__first2;
-	    }
-	return ranges::copy(std::move(__first1), std::move(__last1),
-			    std::move(__result));
-      }
-
-    template<input_range _Range1, input_range _Range2, weakly_incrementable _Out,
-	     typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
-			 _Comp, _Proj1, _Proj2>
-      constexpr set_difference_result<safe_iterator_t<_Range1>, _Out>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__result), std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __set_difference_fn set_difference{};
-
-  template<typename _Iter1, typename _Iter2, typename _Out>
-    using set_symmetric_difference_result
-      = binary_transform_result<_Iter1, _Iter2, _Out>;
-
-  struct __set_symmetric_difference_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     weakly_incrementable _Out, typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
-      constexpr set_symmetric_difference_result<_Iter1, _Iter2, _Out>
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2,
-		 _Out __result, _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	while (__first1 != __last1 && __first2 != __last2)
-	  if (std::__invoke(__comp,
-			    std::__invoke(__proj1, *__first1),
-			    std::__invoke(__proj2, *__first2)))
-	    {
-	      *__result = *__first1;
-	      ++__first1;
-	      ++__result;
-	    }
-	  else if (std::__invoke(__comp,
-				 std::__invoke(__proj2, *__first2),
-				 std::__invoke(__proj1, *__first1)))
-	    {
-	      *__result = *__first2;
-	      ++__first2;
-	      ++__result;
-	    }
-	  else
-	    {
-	      ++__first1;
-	      ++__first2;
-	    }
-	auto __copy1 = ranges::copy(std::move(__first1), std::move(__last1),
-				    std::move(__result));
-	auto __copy2 = ranges::copy(std::move(__first2), std::move(__last2),
-				    std::move(__copy1.out));
-	return {std::move(__copy1.in), std::move(__copy2.in),
-		std::move(__copy2.out)};
-      }
-
-    template<input_range _Range1, input_range _Range2, weakly_incrementable _Out,
-	     typename _Comp = ranges::less,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
-			 _Comp, _Proj1, _Proj2>
-      constexpr set_symmetric_difference_result<safe_iterator_t<_Range1>,
-						safe_iterator_t<_Range2>,
-						_Out>
-      operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__result), std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __set_symmetric_difference_fn set_symmetric_difference{};
-
-  struct __min_fn
-  {
-    template<typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr const _Tp&
-      operator()(const _Tp& __a, const _Tp& __b,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (std::__invoke(std::move(__comp),
-			  std::__invoke(__proj, __b),
-			  std::__invoke(__proj, __a)))
-	  return __b;
-	else
-	  return __a;
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      requires indirectly_copyable_storable<iterator_t<_Range>,
-					    range_value_t<_Range>*>
-      constexpr range_value_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __first = ranges::begin(__r);
-	auto __last = ranges::end(__r);
-	__glibcxx_assert(__first != __last);
-	auto __result = *__first;
-	while (++__first != __last)
-	  {
-	    auto __tmp = *__first;
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, __tmp),
-			      std::__invoke(__proj, __result)))
-	      __result = std::move(__tmp);
-	  }
-	return __result;
-      }
-
-    template<copyable _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Tp
-      operator()(initializer_list<_Tp> __r,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::subrange(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __min_fn min{};
-
-  struct __max_fn
-  {
-    template<typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr const _Tp&
-      operator()(const _Tp& __a, const _Tp& __b,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (std::__invoke(std::move(__comp),
-			  std::__invoke(__proj, __a),
-			  std::__invoke(__proj, __b)))
-	  return __b;
-	else
-	  return __a;
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      requires indirectly_copyable_storable<iterator_t<_Range>,
-					    range_value_t<_Range>*>
-      constexpr range_value_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __first = ranges::begin(__r);
-	auto __last = ranges::end(__r);
-	__glibcxx_assert(__first != __last);
-	auto __result = *__first;
-	while (++__first != __last)
-	  {
-	    auto __tmp = *__first;
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, __result),
-			      std::__invoke(__proj, __tmp)))
-	      __result = std::move(__tmp);
-	  }
-	return __result;
-      }
-
-    template<copyable _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Tp
-      operator()(initializer_list<_Tp> __r,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::subrange(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __max_fn max{};
-
-  template<typename _Tp>
-    struct minmax_result
-    {
-      [[no_unique_address]] _Tp min;
-      [[no_unique_address]] _Tp max;
-
-      template<typename _Tp2>
-	requires convertible_to<const _Tp&, _Tp2>
-	operator minmax_result<_Tp2>() const &
-	{ return {min, max}; }
-
-      template<typename _Tp2>
-	requires convertible_to<_Tp, _Tp2>
-	operator minmax_result<_Tp2>() &&
-	{ return {std::move(min), std::move(max)}; }
-    };
-
-  struct __minmax_fn
-  {
-    template<typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr minmax_result<const _Tp&>
-      operator()(const _Tp& __a, const _Tp& __b,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (std::__invoke(std::move(__comp),
-			  std::__invoke(__proj, __b),
-			  std::__invoke(__proj, __a)))
-	  return {__b, __a};
-	else
-	  return {__a, __b};
-      }
-
-    template<input_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      requires indirectly_copyable_storable<iterator_t<_Range>,
-      range_value_t<_Range>*>
-      constexpr minmax_result<range_value_t<_Range>>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	auto __first = ranges::begin(__r);
-	auto __last = ranges::end(__r);
-	__glibcxx_assert(__first != __last);
-	minmax_result<range_value_t<_Range>> __result = {*__first, *__first};
-	while (++__first != __last)
-	  {
-	    auto __tmp = *__first;
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, __tmp),
-			      std::__invoke(__proj, __result.min)))
-	      __result.min = std::move(__tmp);
-	    if (!(bool)std::__invoke(__comp,
-				     std::__invoke(__proj, __tmp),
-				     std::__invoke(__proj, __result.max)))
-	      __result.max = std::move(__tmp);
-	  }
-	return __result;
-      }
-
-    template<copyable _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr minmax_result<_Tp>
-      operator()(initializer_list<_Tp> __r,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::subrange(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __minmax_fn minmax{};
-
-  struct __min_element_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return __first;
-
-	auto __i = __first;
-	while (++__i != __last)
-	  {
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, *__i),
-			      std::__invoke(__proj, *__first)))
-	      __first = __i;
-	  }
-	return __first;
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __min_element_fn min_element{};
-
-  struct __max_element_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return __first;
-
-	auto __i = __first;
-	while (++__i != __last)
-	  {
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, *__first),
-			      std::__invoke(__proj, *__i)))
-	      __first = __i;
-	  }
-	return __first;
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __max_element_fn max_element{};
-
-  template<typename _Iter>
-    using minmax_element_result = minmax_result<_Iter>;
-
-  struct __minmax_element_fn
-  {
-    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_strict_weak_order<projected<_Iter, _Proj>>
-	       _Comp = ranges::less>
-      constexpr minmax_element_result<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return {__first, __first};
-
-	minmax_element_result<_Iter> __result = {__first, __first};
-	auto __i = __first;
-	while (++__i != __last)
-	  {
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, *__i),
-			      std::__invoke(__proj, *__result.min)))
-	      __result.min = __i;
-	    if (!(bool)std::__invoke(__comp,
-				     std::__invoke(__proj, *__i),
-				     std::__invoke(__proj, *__result.max)))
-	      __result.max = __i;
-	  }
-	return __result;
-      }
-
-    template<forward_range _Range, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
-	       _Comp = ranges::less>
-      constexpr minmax_element_result<safe_iterator_t<_Range>>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __minmax_element_fn minmax_element{};
-
-  struct __lexicographical_compare_fn
-  {
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Proj1 = identity, typename _Proj2 = identity,
-	     indirect_strict_weak_order<projected<_Iter1, _Proj1>,
-					projected<_Iter2, _Proj2>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Iter1 __first1, _Sent1 __last1,
-		 _Iter2 __first2, _Sent2 __last2,
-		 _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	if constexpr (__detail::__is_normal_iterator<_Iter1>
-		      || __detail::__is_normal_iterator<_Iter2>)
-	  return (*this)(std::__niter_base(std::move(__first1)),
-			 std::__niter_base(std::move(__last1)),
-			 std::__niter_base(std::move(__first2)),
-			 std::__niter_base(std::move(__last2)),
-			 std::move(__comp),
-			 std::move(__proj1), std::move(__proj2));
-	else
-	  {
-	    constexpr bool __sized_iters
-	      = (sized_sentinel_for<_Sent1, _Iter1>
-		 && sized_sentinel_for<_Sent2, _Iter2>);
-	    if constexpr (__sized_iters)
-	      {
-		auto __d1 = ranges::distance(__first1, __last1);
-		auto __d2 = ranges::distance(__first2, __last2);
-
-		using _ValueType1 = iter_value_t<_Iter1>;
-		using _ValueType2 = iter_value_t<_Iter2>;
-		constexpr bool __use_memcmp
-		  = ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>)
-		     && is_same_v<_ValueType1, _ValueType2>
-		     && is_pointer_v<_Iter1>
-		     && is_pointer_v<_Iter2>
-		     && (is_same_v<_Comp, ranges::less>
-			 || is_same_v<_Comp, ranges::greater>)
-		     && is_same_v<_Proj1, identity>
-		     && is_same_v<_Proj2, identity>);
-		if constexpr (__use_memcmp)
-		  {
-		    if (const auto __len = std::min(__d1, __d2))
-		      {
-			const auto __c
-			  = std::__memcmp(__first1, __first2, __len);
-			if constexpr (is_same_v<_Comp, ranges::less>)
-			  {
-			    if (__c < 0)
-			      return true;
-			    if (__c > 0)
-			      return false;
-			  }
-			else if constexpr (is_same_v<_Comp, ranges::greater>)
-			  {
-			    if (__c > 0)
-			      return true;
-			    if (__c < 0)
-			      return false;
-			  }
-			else
-			  __builtin_unreachable();
-		      }
-		    return (__last1 - __first1 < __last2 - __first2);
-		  }
-	      }
-
-	    for (; __first1 != __last1 && __first2 != __last2;
-		 ++__first1, (void) ++__first2)
-	      {
-		if (std::__invoke(__comp,
-				  std::__invoke(__proj1, *__first1),
-				  std::__invoke(__proj2, *__first2)))
-		  return true;
-		if (std::__invoke(__comp,
-				  std::__invoke(__proj2, *__first2),
-				  std::__invoke(__proj1, *__first1)))
-		  return false;
-	      }
-	    return __first1 == __last1 && __first2 != __last2;
-	  }
-      }
-
-    template<input_range _Range1, input_range _Range2,
-	     typename _Proj1 = identity, typename _Proj2 = identity,
-	     indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>,
-					projected<iterator_t<_Range2>, _Proj2>>
-	       _Comp = ranges::less>
-      constexpr bool
-      operator()(_Range1&& __r1, _Range2&& __r2, _Comp __comp = {},
-		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
-      {
-	return (*this)(ranges::begin(__r1), ranges::end(__r1),
-		       ranges::begin(__r2), ranges::end(__r2),
-		       std::move(__comp),
-		       std::move(__proj1), std::move(__proj2));
-      }
-  };
-
-  inline constexpr __lexicographical_compare_fn lexicographical_compare;
-
-  template<typename _Iter>
-    struct next_permutation_result
-    {
-      bool found;
-      _Iter in;
-    };
-
-  struct __next_permutation_fn
-  {
-    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr next_permutation_result<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return {false, std::move(__first)};
-
-	auto __i = __first;
-	++__i;
-	if (__i == __last)
-	  return {false, std::move(__i)};
-
-	auto __lasti = ranges::next(__first, __last);
-	__i = __lasti;
-	--__i;
-
-	for (;;)
-	  {
-	    auto __ii = __i;
-	    --__i;
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, *__i),
-			      std::__invoke(__proj, *__ii)))
-	      {
-		auto __j = __lasti;
-		while (!(bool)std::__invoke(__comp,
-					    std::__invoke(__proj, *__i),
-					    std::__invoke(__proj, *--__j)))
-		  ;
-		ranges::iter_swap(__i, __j);
-		ranges::reverse(__ii, __last);
-		return {true, std::move(__lasti)};
-	      }
-	    if (__i == __first)
-	      {
-		ranges::reverse(__first, __last);
-		return {false, std::move(__lasti)};
-	      }
-	  }
-      }
-
-    template<bidirectional_range _Range, typename _Comp = ranges::less,
-	     typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr next_permutation_result<safe_iterator_t<_Range>>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __next_permutation_fn next_permutation{};
-
-  template<typename _Iter>
-    using prev_permutation_result = next_permutation_result<_Iter>;
-
-  struct __prev_permutation_fn
-  {
-    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Comp = ranges::less, typename _Proj = identity>
-      requires sortable<_Iter, _Comp, _Proj>
-      constexpr prev_permutation_result<_Iter>
-      operator()(_Iter __first, _Sent __last,
-		 _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	if (__first == __last)
-	  return {false, std::move(__first)};
-
-	auto __i = __first;
-	++__i;
-	if (__i == __last)
-	  return {false, std::move(__i)};
-
-	auto __lasti = ranges::next(__first, __last);
-	__i = __lasti;
-	--__i;
-
-	for (;;)
-	  {
-	    auto __ii = __i;
-	    --__i;
-	    if (std::__invoke(__comp,
-			      std::__invoke(__proj, *__ii),
-			      std::__invoke(__proj, *__i)))
-	      {
-		auto __j = __lasti;
-		while (!(bool)std::__invoke(__comp,
-					    std::__invoke(__proj, *--__j),
-					    std::__invoke(__proj, *__i)))
-		  ;
-		ranges::iter_swap(__i, __j);
-		ranges::reverse(__ii, __last);
-		return {true, std::move(__lasti)};
-	      }
-	    if (__i == __first)
-	      {
-		ranges::reverse(__first, __last);
-		return {false, std::move(__lasti)};
-	      }
-	  }
-      }
-
-    template<bidirectional_range _Range, typename _Comp = ranges::less,
-	     typename _Proj = identity>
-      requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr prev_permutation_result<safe_iterator_t<_Range>>
-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r),
-		       std::move(__comp), std::move(__proj));
-      }
-  };
-
-  inline constexpr __prev_permutation_fn prev_permutation{};
-
-} // namespace ranges
-_GLIBCXX_END_NAMESPACE_VERSION
-} // namespace std
-#endif // concepts
-#endif // C++20
-#endif // _RANGES_ALGO_H
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/ranges_uninitialized.h gcc-10-20200202/libstdc++-v3/include/bits/ranges_uninitialized.h
--- gcc-10-20200216/libstdc++-v3/include/bits/ranges_uninitialized.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/ranges_uninitialized.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,564 +0,0 @@
-// Raw memory manipulators -*- C++ -*-
-
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// Under Section 7 of GPL version 3, you are granted additional
-// permissions described in the GCC Runtime Library Exception, version
-// 3.1, as published by the Free Software Foundation.
-
-// You should have received a copy of the GNU General Public License and
-// a copy of the GCC Runtime Library Exception along with this program;
-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
-// <http://www.gnu.org/licenses/>.
-
-/** @file bits/ranges_uninitialized.h
- *  This is an internal header file, included by other library headers.
- *  Do not attempt to use it directly. @headername{memory}
- */
-
-#ifndef _RANGES_UNINITIALIZED_H
-#define _RANGES_UNINITIALIZED_H 1
-
-#if __cplusplus > 201703L
-#if __cpp_lib_concepts
-
-#include <bits/ranges_algobase.h>
-
-namespace std _GLIBCXX_VISIBILITY(default)
-{
-_GLIBCXX_BEGIN_NAMESPACE_VERSION
-namespace ranges
-{
-  namespace __detail
-  {
-    template<typename _Tp>
-      constexpr void*
-      __voidify(_Tp& __obj) noexcept
-      {
-	return const_cast<void*>
-		 (static_cast<const volatile void*>(std::__addressof(__obj)));
-      }
-
-    template<typename _Iter>
-      concept __nothrow_input_iterator
-	= (input_iterator<_Iter>
-	   && is_lvalue_reference_v<iter_reference_t<_Iter>>
-	   && same_as<remove_cvref_t<iter_reference_t<_Iter>>,
-		      iter_value_t<_Iter>>);
-
-    template<typename _Sent, typename _Iter>
-      concept __nothrow_sentinel = sentinel_for<_Sent, _Iter>;
-
-    template<typename _Range>
-      concept __nothrow_input_range
-	= (range<_Range>
-	   && __nothrow_input_iterator<iterator_t<_Range>>
-	   && __nothrow_sentinel<sentinel_t<_Range>, iterator_t<_Range>>);
-
-    template<typename _Iter>
-      concept __nothrow_forward_iterator
-	= (__nothrow_input_iterator<_Iter>
-	   && forward_iterator<_Iter>
-	   && __nothrow_sentinel<_Iter, _Iter>);
-
-    template<typename _Range>
-      concept __nothrow_forward_range
-	= (__nothrow_input_range<_Range>
-	   && __nothrow_forward_iterator<iterator_t<_Range>>);
-  } // namespace __detail
-
-  struct __destroy_fn
-  {
-    template<__detail::__nothrow_input_iterator _Iter,
-	     __detail::__nothrow_sentinel<_Iter> _Sent>
-      requires destructible<iter_value_t<_Iter>>
-      constexpr _Iter
-      operator()(_Iter __first, _Sent __last) const noexcept;
-
-    template<__detail::__nothrow_input_range _Range>
-      requires destructible<range_value_t<_Range>>
-      constexpr safe_iterator_t<_Range>
-      operator()(_Range&& __r) const noexcept;
-  };
-
-  inline constexpr __destroy_fn destroy{};
-
-  namespace __detail
-  {
-    template<typename _Iter>
-      requires destructible<iter_value_t<_Iter>>
-      struct _DestroyGuard
-      {
-      private:
-	_Iter _M_first;
-	const _Iter* _M_cur;
-
-      public:
-	explicit
-	_DestroyGuard(const _Iter* __iter)
-	  : _M_first(*__iter), _M_cur(__iter)
-	{ }
-
-	void
-	release() noexcept
-	{ _M_cur = nullptr; }
-
-	~_DestroyGuard()
-	{
-	  if (_M_cur != nullptr)
-	    ranges::destroy(std::move(_M_first), *_M_cur);
-	}
-      };
-
-    template<typename _Iter>
-      requires destructible<iter_value_t<_Iter>>
-	&& is_trivially_destructible_v<iter_value_t<_Iter>>
-      struct _DestroyGuard<_Iter>
-      {
-	explicit
-	_DestroyGuard(const _Iter*)
-	{ }
-
-	void
-	release() noexcept
-	{ }
-      };
-  } // namespace __detail
-
-  struct __uninitialized_default_construct_fn
-  {
-    template<__detail::__nothrow_forward_iterator _Iter,
-	     __detail::__nothrow_sentinel<_Iter> _Sent>
-      requires default_initializable<iter_value_t<_Iter>>
-      _Iter
-      operator()(_Iter __first, _Sent __last) const
-      {
-	using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
-	if constexpr (is_trivially_default_constructible_v<_ValueType>)
-	  return ranges::next(__first, __last);
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
-	    for (; __first != __last; ++__first)
-	      ::new (__detail::__voidify(*__first)) _ValueType;
-	    __guard.release();
-	    return __first;
-	  }
-      }
-
-    template<__detail::__nothrow_forward_range _Range>
-      requires default_initializable<range_value_t<_Range>>
-      safe_iterator_t<_Range>
-      operator()(_Range&& __r) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r));
-      }
-  };
-
-  inline constexpr __uninitialized_default_construct_fn
-    uninitialized_default_construct{};
-
-  struct __uninitialized_default_construct_n_fn
-  {
-    template<__detail::__nothrow_forward_iterator _Iter>
-      requires default_initializable<iter_value_t<_Iter>>
-      _Iter
-      operator()(_Iter __first, iter_difference_t<_Iter> __n) const
-      {
-	using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
-	if constexpr (is_trivially_default_constructible_v<_ValueType>)
-	  return ranges::next(__first, __n);
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
-	    for (; __n > 0; ++__first, (void) --__n)
-	      ::new (__detail::__voidify(*__first)) _ValueType;
-	    __guard.release();
-	    return __first;
-	  }
-      }
-  };
-
-  inline constexpr __uninitialized_default_construct_n_fn
-    uninitialized_default_construct_n;
-
-  struct __uninitialized_value_construct_fn
-  {
-    template<__detail::__nothrow_forward_iterator _Iter,
-	     __detail::__nothrow_sentinel<_Iter> _Sent>
-      requires default_initializable<iter_value_t<_Iter>>
-      _Iter
-      operator()(_Iter __first, _Sent __last) const
-      {
-	using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
-	if constexpr (is_trivial_v<_ValueType>
-		      && is_copy_assignable_v<_ValueType>)
-	  return ranges::fill(__first, __last, _ValueType());
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
-	    for (; __first != __last; ++__first)
-	      ::new (__detail::__voidify(*__first)) _ValueType();
-	    __guard.release();
-	    return __first;
-	  }
-      }
-
-    template<__detail::__nothrow_forward_range _Range>
-      requires default_initializable<range_value_t<_Range>>
-      safe_iterator_t<_Range>
-      operator()(_Range&& __r) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r));
-      }
-  };
-
-  inline constexpr __uninitialized_value_construct_fn
-    uninitialized_value_construct{};
-
-  struct __uninitialized_value_construct_n_fn
-  {
-    template<__detail::__nothrow_forward_iterator _Iter>
-      requires default_initializable<iter_value_t<_Iter>>
-      _Iter
-      operator()(_Iter __first, iter_difference_t<_Iter> __n) const
-      {
-	using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
-	if constexpr (is_trivial_v<_ValueType>
-		      && is_copy_assignable_v<_ValueType>)
-	  return ranges::fill_n(__first, __n, _ValueType());
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
-	    for (; __n > 0; ++__first, (void) --__n)
-	      ::new (__detail::__voidify(*__first)) _ValueType();
-	    __guard.release();
-	    return __first;
-	  }
-      }
-  };
-
-  inline constexpr __uninitialized_value_construct_n_fn
-    uninitialized_value_construct_n;
-
-  template<typename _Iter, typename _Out>
-    using uninitialized_copy_result = copy_result<_Iter, _Out>;
-
-  struct __uninitialized_copy_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _ISent,
-	     __detail::__nothrow_forward_iterator _Out,
-	     __detail::__nothrow_sentinel<_Out> _OSent>
-      requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>
-      uninitialized_copy_result<_Iter, _Out>
-      operator()(_Iter __ifirst, _ISent __ilast,
-		 _Out __ofirst, _OSent __olast) const
-      {
-	using _OutType = remove_reference_t<iter_reference_t<_Out>>;
-	if constexpr (sized_sentinel_for<_ISent, _Iter>
-		      && sized_sentinel_for<_OSent, _Out>
-		      && is_trivial_v<_OutType>
-		      && is_nothrow_assignable_v<_OutType,
-						 iter_reference_t<_Iter>>)
-	  {
-	    auto __d1 = ranges::distance(__ifirst, __ilast);
-	    auto __d2 = ranges::distance(__ofirst, __olast);
-	    return ranges::copy_n(__ifirst, std::min(__d1, __d2), __ofirst);
-	  }
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
-	    for (; __ifirst != __ilast && __ofirst != __olast;
-		 ++__ofirst, (void)++__ifirst)
-	      ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);
-	    __guard.release();
-	    return {__ifirst, __ofirst};
-	  }
-      }
-
-    template<input_range _IRange, __detail::__nothrow_forward_range _ORange>
-      requires constructible_from<range_value_t<_ORange>,
-				  range_reference_t<_IRange>>
-      uninitialized_copy_result<safe_iterator_t<_IRange>,
-				safe_iterator_t<_ORange>>
-      operator()(_IRange&& __inr, _ORange&& __outr) const
-      {
-	return (*this)(ranges::begin(__inr), ranges::end(__inr),
-		       ranges::begin(__outr), ranges::end(__outr));
-      }
-  };
-
-  inline constexpr __uninitialized_copy_fn uninitialized_copy{};
-
-  template<typename _Iter, typename _Out>
-    using uninitialized_copy_n_result = uninitialized_copy_result<_Iter, _Out>;
-
-  struct __uninitialized_copy_n_fn
-  {
-    template<input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,
-	     __detail::__nothrow_sentinel<_Out> _Sent>
-      requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>
-      uninitialized_copy_n_result<_Iter, _Out>
-      operator()(_Iter __ifirst, iter_difference_t<_Iter> __n,
-		 _Out __ofirst, _Sent __olast) const
-      {
-	using _OutType = remove_reference_t<iter_reference_t<_Out>>;
-	if constexpr (sized_sentinel_for<_Sent, _Out>
-		      && is_trivial_v<_OutType>
-		      && is_nothrow_assignable_v<_OutType,
-						 iter_reference_t<_Iter>>)
-	  {
-	    auto __d = ranges::distance(__ofirst, __olast);
-	    return ranges::copy_n(__ifirst, std::min(__n, __d), __ofirst);
-	  }
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
-	    for (; __n > 0 && __ofirst != __olast;
-		 ++__ofirst, (void)++__ifirst, (void)--__n)
-	      ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);
-	    __guard.release();
-	    return {__ifirst, __ofirst};
-	  }
-      }
-  };
-
-  inline constexpr __uninitialized_copy_n_fn uninitialized_copy_n{};
-
-  template<typename _Iter, typename _Out>
-    using uninitialized_move_result = uninitialized_copy_result<_Iter, _Out>;
-
-  struct __uninitialized_move_fn
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _ISent,
-	     __detail::__nothrow_forward_iterator _Out,
-	     __detail::__nothrow_sentinel<_Out> _OSent>
-      requires constructible_from<iter_value_t<_Out>,
-				  iter_rvalue_reference_t<_Iter>>
-      uninitialized_move_result<_Iter, _Out>
-      operator()(_Iter __ifirst, _ISent __ilast,
-		 _Out __ofirst, _OSent __olast) const
-      {
-	using _OutType = remove_reference_t<iter_reference_t<_Out>>;
-	if constexpr (sized_sentinel_for<_ISent, _Iter>
-		      && sized_sentinel_for<_OSent, _Out>
-		      && is_trivial_v<_OutType>
-		      && is_nothrow_assignable_v<_OutType,
-						 iter_rvalue_reference_t<_Iter>>)
-	  {
-	    auto __d1 = ranges::distance(__ifirst, __ilast);
-	    auto __d2 = ranges::distance(__ofirst, __olast);
-	    return ranges::copy_n(std::make_move_iterator(__ifirst),
-				  std::min(__d1, __d2), __ofirst);
-	  }
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
-	    for (; __ifirst != __ilast && __ofirst != __olast;
-		 ++__ofirst, (void)++__ifirst)
-	      ::new (__detail::__voidify(*__ofirst))
-		    _OutType(ranges::iter_move(__ifirst));
-	    __guard.release();
-	    return {__ifirst, __ofirst};
-	  }
-      }
-
-    template<input_range _IRange, __detail::__nothrow_forward_range _ORange>
-      requires constructible_from<range_value_t<_ORange>,
-	       range_rvalue_reference_t<_IRange>>
-      uninitialized_move_result<safe_iterator_t<_IRange>,
-				safe_iterator_t<_ORange>>
-      operator()(_IRange&& __inr, _ORange&& __outr) const
-      {
-	return (*this)(ranges::begin(__inr), ranges::end(__inr),
-		       ranges::begin(__outr), ranges::end(__outr));
-      }
-  };
-
-  inline constexpr __uninitialized_move_fn uninitialized_move{};
-
-  template<typename _Iter, typename _Out>
-    using uninitialized_move_n_result = uninitialized_copy_result<_Iter, _Out>;
-
-  struct __uninitialized_move_n_fn
-  {
-    template<input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,
-      __detail::__nothrow_sentinel<_Out> _Sent>
-	requires constructible_from<iter_value_t<_Out>,
-				    iter_rvalue_reference_t<_Iter>>
-      uninitialized_move_n_result<_Iter, _Out>
-      operator()(_Iter __ifirst, iter_difference_t<_Iter> __n,
-		 _Out __ofirst, _Sent __olast) const
-      {
-	using _OutType = remove_reference_t<iter_reference_t<_Out>>;
-	if constexpr (sized_sentinel_for<_Sent, _Out>
-		      && is_trivial_v<_OutType>
-		      && is_nothrow_assignable_v<_OutType,
-						 iter_rvalue_reference_t<_Iter>>)
-	  {
-	    auto __d = ranges::distance(__ofirst, __olast);
-	    return ranges::copy_n(std::make_move_iterator(__ifirst),
-				  std::min(__n, __d), __ofirst);
-	  }
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__ofirst);
-	    for (; __n > 0 && __ofirst != __olast;
-		 ++__ofirst, (void)++__ifirst, (void)--__n)
-	      ::new (__detail::__voidify(*__ofirst))
-		    _OutType(ranges::iter_move(__ifirst));
-	    __guard.release();
-	    return {__ifirst, __ofirst};
-	  }
-      }
-  };
-
-  inline constexpr __uninitialized_move_n_fn uninitialized_move_n{};
-
-  struct __uninitialized_fill_fn
-  {
-    template<__detail::__nothrow_forward_iterator _Iter,
-	     __detail::__nothrow_sentinel<_Iter> _Sent, typename _Tp>
-      requires constructible_from<iter_value_t<_Iter>, const _Tp&>
-      _Iter
-      operator()(_Iter __first, _Sent __last, const _Tp& __x) const
-      {
-	using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
-	if constexpr (is_trivial_v<_ValueType>
-		      && is_nothrow_assignable_v<_ValueType, const _Tp&>)
-	  return ranges::fill(__first, __last, __x);
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
-	    for (; __first != __last; ++__first)
-	      ::new (__detail::__voidify(*__first)) _ValueType(__x);
-	    __guard.release();
-	    return __first;
-	  }
-      }
-
-    template<__detail::__nothrow_forward_range _Range, typename _Tp>
-      requires constructible_from<range_value_t<_Range>, const _Tp&>
-      safe_iterator_t<_Range>
-      operator()(_Range&& __r, const _Tp& __x) const
-      {
-	return (*this)(ranges::begin(__r), ranges::end(__r), __x);
-      }
-  };
-
-  inline constexpr __uninitialized_fill_fn uninitialized_fill{};
-
-  struct __uninitialized_fill_n_fn
-  {
-    template<__detail::__nothrow_forward_iterator _Iter, typename _Tp>
-      requires constructible_from<iter_value_t<_Iter>, const _Tp&>
-      _Iter
-      operator()(_Iter __first, iter_difference_t<_Iter> __n,
-		 const _Tp& __x) const
-      {
-	using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
-	if constexpr (is_trivial_v<_ValueType>
-		      && is_nothrow_assignable_v<_ValueType, const _Tp&>)
-	  return ranges::fill_n(__first, __n, __x);
-	else
-	  {
-	    auto __guard = __detail::_DestroyGuard(&__first);
-	    for (; __n > 0; ++__first, (void)--__n)
-	      ::new (__detail::__voidify(*__first)) _ValueType(__x);
-	    __guard.release();
-	    return __first;
-	  }
-      }
-  };
-
-  inline constexpr __uninitialized_fill_n_fn uninitialized_fill_n{};
-
-  struct __construct_at_fn
-  {
-    template<typename _Tp, typename... _Args>
-      requires requires { ::new (declval<void*>()) _Tp(declval<_Args>()...); }
-      constexpr _Tp*
-      operator()(_Tp* __location, _Args&&... __args) const
-      {
-	return ::new (__detail::__voidify(*__location))
-		     _Tp(std::forward<_Args>(__args)...);
-      }
-  };
-
-  inline constexpr __construct_at_fn construct_at{};
-
-  struct __destroy_at_fn
-  {
-    template<destructible _Tp>
-      constexpr void
-      operator()(_Tp* __location) const noexcept
-      {
-	if constexpr (is_array_v<_Tp>)
-	  ranges::destroy(ranges::begin(*__location), ranges::end(*__location));
-	else
-	  __location->~_Tp();
-      }
-  };
-
-  inline constexpr __destroy_at_fn destroy_at{};
-
-  template<__detail::__nothrow_input_iterator _Iter,
-	   __detail::__nothrow_sentinel<_Iter> _Sent>
-    requires destructible<iter_value_t<_Iter>>
-    constexpr _Iter
-    __destroy_fn::operator()(_Iter __first, _Sent __last) const noexcept
-    {
-      if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)
-	return ranges::next(__first, __last);
-      else
-	{
-	  for (; __first != __last; ++__first)
-	    ranges::destroy_at(std::__addressof(*__first));
-	  return __first;
-	}
-    }
-
-  template<__detail::__nothrow_input_range _Range>
-    requires destructible<range_value_t<_Range>>
-    constexpr safe_iterator_t<_Range>
-    __destroy_fn::operator()(_Range&& __r) const noexcept
-    {
-      return (*this)(ranges::begin(__r), ranges::end(__r));
-    }
-
-  struct __destroy_n_fn
-  {
-    template<__detail::__nothrow_input_iterator _Iter>
-      requires destructible<iter_value_t<_Iter>>
-      constexpr _Iter
-      operator()(_Iter __first, iter_difference_t<_Iter> __n) const noexcept
-      {
-	if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)
-	  return ranges::next(__first, __n);
-	else
-	  {
-	    for (; __n > 0; ++__first, (void)--__n)
-	      ranges::destroy_at(std::__addressof(*__first));
-	    return __first;
-	  }
-      }
-  };
-
-  inline constexpr __destroy_n_fn destroy_n{};
-}
-_GLIBCXX_END_NAMESPACE_VERSION
-} // namespace std
-#endif // concepts
-#endif // C++20
-#endif // _RANGES_UNINITIALIZED_H
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/stl_algobase.h gcc-10-20200202/libstdc++-v3/include/bits/stl_algobase.h
--- gcc-10-20200216/libstdc++-v3/include/bits/stl_algobase.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/stl_algobase.h	2020-02-02 23:32:19.000000000 +0100
@@ -139,6 +139,7 @@
     struct __iter_swap
     {
       template<typename _ForwardIterator1, typename _ForwardIterator2>
+	_GLIBCXX20_CONSTEXPR
 	static void
 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 	{
@@ -154,13 +155,14 @@
     struct __iter_swap<true>
     {
       template<typename _ForwardIterator1, typename _ForwardIterator2>
+	_GLIBCXX20_CONSTEXPR
 	static void
 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 	{
 	  swap(*__a, *__b);
 	}
     };
-#endif // C++03
+#endif
 
   /**
    *  @brief Swaps the contents of two iterators.
@@ -203,8 +205,6 @@
 	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
 	iter_swap(__a, __b);
 #else
-      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-      // 187. iter_swap underspecified
       swap(*__a, *__b);
 #endif
     }
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/stl_iterator.h gcc-10-20200202/libstdc++-v3/include/bits/stl_iterator.h
--- gcc-10-20200216/libstdc++-v3/include/bits/stl_iterator.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/stl_iterator.h	2020-02-02 23:32:19.000000000 +0100
@@ -1166,29 +1166,16 @@
 
       explicit _GLIBCXX17_CONSTEXPR
       move_iterator(iterator_type __i)
-      : _M_current(std::move(__i)) { }
+      : _M_current(__i) { }
 
       template<typename _Iter>
 	_GLIBCXX17_CONSTEXPR
 	move_iterator(const move_iterator<_Iter>& __i)
 	: _M_current(__i.base()) { }
 
-#if __cplusplus <= 201703L
       _GLIBCXX17_CONSTEXPR iterator_type
       base() const
       { return _M_current; }
-#else
-      constexpr iterator_type
-      base() const &
-#if __cpp_lib_concepts
-	requires copy_constructible<iterator_type>
-#endif
-      { return _M_current; }
-
-      constexpr iterator_type
-      base() &&
-      { return std::move(_M_current); }
-#endif
 
       _GLIBCXX17_CONSTEXPR reference
       operator*() const
@@ -1375,7 +1362,7 @@
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
     make_move_iterator(_Iterator __i)
-    { return move_iterator<_Iterator>(std::move(__i)); }
+    { return move_iterator<_Iterator>(__i); }
 
   template<typename _Iterator, typename _ReturnType
     = typename conditional<__move_if_noexcept_cond
@@ -1417,7 +1404,7 @@
       };
 
     template<typename _It>
-      concept __common_iter_has_arrow = indirectly_readable<const _It>
+      concept __common_iter_has_arrow = readable<const _It>
 	&& (requires(const _It& __it) { __it.operator->(); }
 	    || is_reference_v<iter_reference_t<_It>>
 	    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
@@ -1737,21 +1724,18 @@
 
   namespace __detail
   {
-    // FIXME: This has to be at namespace-scope because of PR 92103.
-    template<typename _It, typename _Sent>
+    // FIXME: This has to be at namespace-scope because of PR 92078.
+    template<typename _Iter>
       struct __common_iter_ptr
-      {
-	using type = void;
-      };
+	{
+	  using type = void;
+	};
 
-    template<typename _It, typename _Sent>
-      requires __detail::__common_iter_has_arrow<_It>
-      struct __common_iter_ptr<_It, _Sent>
+    template<typename _Iter>
+      requires __detail::__common_iter_has_arrow<_Iter>
+      struct __common_iter_ptr<_Iter>
       {
-	using common_iterator = std::common_iterator<_It, _Sent>;
-
-	using type
-	  = decltype(std::declval<const common_iterator&>().operator->());
+	using type = decltype(std::declval<const _Iter&>().operator->());
       };
   } // namespace __detail
 
@@ -1765,7 +1749,8 @@
 	forward_iterator_tag, input_iterator_tag>;
       using value_type = iter_value_t<_It>;
       using difference_type = iter_difference_t<_It>;
-      using pointer = typename __detail::__common_iter_ptr<_It, _Sent>::type;
+      using pointer = typename
+	__detail::__common_iter_ptr<common_iterator<_It, _Sent>>::type;
       using reference = iter_reference_t<_It>;
     };
 
@@ -1782,7 +1767,7 @@
 
       constexpr
       counted_iterator(_It __i, iter_difference_t<_It> __n)
-      : _M_current(std::move(__i)), _M_length(__n)
+      : _M_current(__i), _M_length(__n)
       { __glibcxx_assert(__n >= 0); }
 
       template<typename _It2>
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/unique_ptr.h gcc-10-20200202/libstdc++-v3/include/bits/unique_ptr.h
--- gcc-10-20200216/libstdc++-v3/include/bits/unique_ptr.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/bits/unique_ptr.h	2020-02-02 23:32:19.000000000 +0100
@@ -185,14 +185,6 @@
 	return __p;
       }
 
-      void
-      swap(__uniq_ptr_impl& __rhs) noexcept
-      {
-	using std::swap;
-	swap(this->_M_ptr(), __rhs._M_ptr());
-	swap(this->_M_deleter(), __rhs._M_deleter());
-      }
-
     private:
       tuple<pointer, _Dp> _M_t;
     };
@@ -456,8 +448,8 @@
       void
       swap(unique_ptr& __u) noexcept
       {
-	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
-	_M_t.swap(__u._M_t);
+	using std::swap;
+	swap(_M_t, __u._M_t);
       }
 
       // Disable copy from lvalue.
@@ -711,8 +703,8 @@
       void
       swap(unique_ptr& __u) noexcept
       {
-	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
-	_M_t.swap(__u._M_t);
+	using std::swap;
+	swap(_M_t, __u._M_t);
       }
 
       // Disable copy from lvalue.
diff -urN gcc-10-20200216/libstdc++-v3/include/ext/pointer.h gcc-10-20200202/libstdc++-v3/include/ext/pointer.h
--- gcc-10-20200216/libstdc++-v3/include/ext/pointer.h	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/ext/pointer.h	2020-02-02 23:32:19.000000000 +0100
@@ -47,7 +47,7 @@
 # include <bits/ptr_traits.h>
 #endif
 #if __cplusplus > 201703L
-# include <iterator> // for indirectly_readable_traits
+# include <iterator> // for readable_traits
 #endif
 
 namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
@@ -598,11 +598,11 @@
     };
 
 #if __cpp_lib_concepts
-  template<typename _Policy>
-    struct indirectly_readable_traits<__gnu_cxx::_Pointer_adapter<_Policy>>
+  template<typename _Storage_policy>
+    struct readable_traits<__gnu_cxx::_Pointer_adapter<_Storage_policy>>
     {
       using value_type
-	= typename __gnu_cxx::_Pointer_adapter<_Policy>::value_type;
+	= typename __gnu_cxx::_Pointer_adapter<_Storage_policy>::value_type;
     };
 #endif
 _GLIBCXX_END_NAMESPACE_VERSION
diff -urN gcc-10-20200216/libstdc++-v3/include/Makefile.am gcc-10-20200202/libstdc++-v3/include/Makefile.am
--- gcc-10-20200216/libstdc++-v3/include/Makefile.am	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/Makefile.am	2020-02-02 23:32:19.000000000 +0100
@@ -157,9 +157,6 @@
 	${bits_srcdir}/random.tcc \
 	${bits_srcdir}/range_access.h \
 	${bits_srcdir}/range_cmp.h \
-	${bits_srcdir}/ranges_algobase.h \
-	${bits_srcdir}/ranges_algo.h \
-	${bits_srcdir}/ranges_uninitialized.h \
 	${bits_srcdir}/refwrap.h \
 	${bits_srcdir}/regex.h \
 	${bits_srcdir}/regex.tcc \
diff -urN gcc-10-20200216/libstdc++-v3/include/Makefile.in gcc-10-20200202/libstdc++-v3/include/Makefile.in
--- gcc-10-20200216/libstdc++-v3/include/Makefile.in	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/Makefile.in	2020-02-02 23:32:19.000000000 +0100
@@ -502,9 +502,6 @@
 	${bits_srcdir}/random.tcc \
 	${bits_srcdir}/range_access.h \
 	${bits_srcdir}/range_cmp.h \
-	${bits_srcdir}/ranges_algobase.h \
-	${bits_srcdir}/ranges_algo.h \
-	${bits_srcdir}/ranges_uninitialized.h \
 	${bits_srcdir}/refwrap.h \
 	${bits_srcdir}/regex.h \
 	${bits_srcdir}/regex.tcc \
diff -urN gcc-10-20200216/libstdc++-v3/include/std/algorithm gcc-10-20200202/libstdc++-v3/include/std/algorithm
--- gcc-10-20200216/libstdc++-v3/include/std/algorithm	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/algorithm	2020-02-02 23:32:19.000000000 +0100
@@ -60,9 +60,6 @@
 #include <utility> // UK-300.
 #include <bits/stl_algobase.h>
 #include <bits/stl_algo.h>
-#if __cplusplus > 201703L
-# include <bits/ranges_algo.h>
-#endif
 
 #if __cplusplus > 201402L
 // Parallel STL algorithms
diff -urN gcc-10-20200216/libstdc++-v3/include/std/deque gcc-10-20200202/libstdc++-v3/include/std/deque
--- gcc-10-20200216/libstdc++-v3/include/std/deque	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/deque	2020-02-02 23:32:19.000000000 +0100
@@ -91,7 +91,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 202002L
+#define __cpp_lib_erase_if 201900L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename deque<_Tp, _Alloc>::size_type
diff -urN gcc-10-20200216/libstdc++-v3/include/std/forward_list gcc-10-20200202/libstdc++-v3/include/std/forward_list
--- gcc-10-20200216/libstdc++-v3/include/std/forward_list	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/forward_list	2020-02-02 23:32:19.000000000 +0100
@@ -62,7 +62,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 202002L
+#define __cpp_lib_erase_if 201900L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename forward_list<_Tp, _Alloc>::size_type 
diff -urN gcc-10-20200216/libstdc++-v3/include/std/functional gcc-10-20200202/libstdc++-v3/include/std/functional
--- gcc-10-20200216/libstdc++-v3/include/std/functional	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/functional	2020-02-02 23:32:19.000000000 +0100
@@ -953,7 +953,7 @@
       _GLIBCXX_NOT_FN_CALL_OP( const & )
       _GLIBCXX_NOT_FN_CALL_OP( && )
       _GLIBCXX_NOT_FN_CALL_OP( const && )
-#undef _GLIBCXX_NOT_FN_CALL_OP
+#undef _GLIBCXX_NOT_FN_CALL
 
     private:
       _Fn _M_fn;
diff -urN gcc-10-20200216/libstdc++-v3/include/std/list gcc-10-20200202/libstdc++-v3/include/std/list
--- gcc-10-20200216/libstdc++-v3/include/std/list	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/list	2020-02-02 23:32:19.000000000 +0100
@@ -86,7 +86,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 202002L
+#define __cpp_lib_erase_if 201900L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename list<_Tp, _Alloc>::size_type
diff -urN gcc-10-20200216/libstdc++-v3/include/std/memory gcc-10-20200202/libstdc++-v3/include/std/memory
--- gcc-10-20200216/libstdc++-v3/include/std/memory	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/memory	2020-02-02 23:32:19.000000000 +0100
@@ -66,7 +66,6 @@
 #include <bits/stl_uninitialized.h>
 #include <bits/stl_tempbuf.h>
 #include <bits/stl_raw_storage_iter.h>
-#include <bits/ranges_uninitialized.h>
 
 #if __cplusplus >= 201103L
 #  include <exception>        	  // std::exception
diff -urN gcc-10-20200216/libstdc++-v3/include/std/ranges gcc-10-20200202/libstdc++-v3/include/std/ranges
--- gcc-10-20200216/libstdc++-v3/include/std/ranges	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/ranges	2020-02-02 23:32:19.000000000 +0100
@@ -38,13 +38,11 @@
 
 #if __cpp_lib_concepts
 
-#include <bits/refwrap.h>
 #include <compare>
 #include <initializer_list>
 #include <iterator>
 #include <limits>
 #include <optional>
-#include <tuple>
 
 /**
  * @defgroup ranges Ranges
@@ -94,7 +92,7 @@
   /// A range which can be safely converted to a view.
   template<typename _Tp>
     concept viewable_range = range<_Tp>
-      && (safe_range<_Tp> || view<remove_cvref_t<_Tp>>);
+      && (safe_range<_Tp> || view<decay_t<_Tp>>);
 
   namespace __detail
   {
@@ -257,8 +255,7 @@
     class subrange : public view_interface<subrange<_It, _Sent, _Kind>>
     {
     private:
-      // XXX: gcc complains when using constexpr here
-      static const bool _S_store_size
+      static constexpr bool _S_store_size
 	= _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;
 
       _It _M_begin = _It();
@@ -510,9 +507,6 @@
 	: std::optional<_Tp>{std::in_place}
 	{ }
 
-	__box(const __box&) = default;
-	__box(__box&&) = default;
-
 	using std::optional<_Tp>::operator=;
 
 	__box&
@@ -782,8 +776,8 @@
 	  requires totally_ordered<_Winc>
 	{ return !(__x < __y); }
 
-#ifdef __cpp_lib_three_way_comparison
-	friend constexpr auto
+#ifdef __cpp_lib_threeway_comparison
+	friend constexpr compare_three_way_result_t<_Winc>
 	operator<=>(const _Iterator& __x, const _Iterator& __y)
 	  requires totally_ordered<_Winc> && three_way_comparable<_Winc>
 	{ return __x._M_value <=> __y._M_value; }
@@ -872,9 +866,7 @@
       : _M_value(__value), _M_bound(__bound)
       {
 	if constexpr (totally_ordered_with<_Winc, _Bound>)
-	  {
-	    __glibcxx_assert( bool(__value <= __bound) );
-	  }
+	  __glibcxx_assert( bool(__value <= __bound) );
       }
 
       constexpr _Iterator
@@ -930,7 +922,7 @@
   struct _Single
   {
     template<typename _Tp>
-      constexpr auto
+      auto
       operator()(_Tp&& __e) const
       { return single_view{std::forward<_Tp>(__e)}; }
   };
@@ -940,2504 +932,20 @@
   struct _Iota
   {
     template<typename _Tp>
-      constexpr auto
+      auto
       operator()(_Tp&& __e) const
       { return iota_view{std::forward<_Tp>(__e)}; }
 
     template<typename _Tp, typename _Up>
-      constexpr auto
+      auto
       operator()(_Tp&& __e, _Up&& __f) const
       { return iota_view{std::forward<_Tp>(__e), std::forward<_Tp>(__f)}; }
   };
 
   inline constexpr _Iota iota{};
-} // namespace views
-
-  namespace __detail
-  {
-    template<typename _Val, typename _CharT, typename _Traits>
-      concept __stream_extractable
-	= requires(basic_istream<_CharT, _Traits>& is, _Val& t) { is >> t; };
-  } // namespace __detail
-
-  template<movable _Val, typename _CharT, typename _Traits>
-    requires default_initializable<_Val>
-      && __detail::__stream_extractable<_Val, _CharT, _Traits>
-    class basic_istream_view
-    : public view_interface<basic_istream_view<_Val, _CharT, _Traits>>
-    {
-    public:
-      basic_istream_view() = default;
-
-      constexpr explicit
-      basic_istream_view(basic_istream<_CharT, _Traits>& __stream)
-	: _M_stream(std::__addressof(__stream))
-      { }
-
-      constexpr auto
-      begin()
-      {
-	if (_M_stream != nullptr)
-	  *_M_stream >> _M_object;
-	return _Iterator{*this};
-      }
-
-      constexpr default_sentinel_t
-      end() const noexcept
-      { return default_sentinel; }
-
-    private:
-      basic_istream<_CharT, _Traits>* _M_stream = nullptr;
-      _Val _M_object = _Val();
 
-      struct _Iterator
-      {
-      public:
-	using iterator_category = input_iterator_tag;
-	using difference_type = ptrdiff_t;
-	using value_type = _Val;
-
-	_Iterator() = default;
-
-	constexpr explicit
-	_Iterator(basic_istream_view& __parent) noexcept
-	  : _M_parent(std::__addressof(__parent))
-	{ }
-
-	_Iterator(const _Iterator&) = delete;
-	_Iterator(_Iterator&&) = default;
-	_Iterator& operator=(const _Iterator&) = delete;
-	_Iterator& operator=(_Iterator&&) = default;
-
-	_Iterator&
-	operator++()
-	{
-	  __glibcxx_assert(_M_parent->_M_stream != nullptr);
-	  *_M_parent->_M_stream >> _M_parent->_M_object;
-	  return *this;
-	}
-
-	void
-	operator++(int)
-	{ ++*this; }
-
-	_Val&
-	operator*() const
-	{
-	  __glibcxx_assert(_M_parent->_M_stream != nullptr);
-	  return _M_parent->_M_object;
-	}
-
-	friend bool
-	operator==(const _Iterator& __x, default_sentinel_t)
-	{ return __x._M_at_end(); }
-
-      private:
-	basic_istream_view* _M_parent = nullptr;
-
-	bool
-	_M_at_end() const
-	{ return _M_parent == nullptr || !*_M_parent->_M_stream; }
-      };
-
-      friend _Iterator;
-    };
-
-  template<typename _Val, typename _CharT, typename _Traits>
-    basic_istream_view<_Val, _CharT, _Traits>
-    istream_view(basic_istream<_CharT, _Traits>& __s)
-    { return basic_istream_view<_Val, _CharT, _Traits>{__s}; }
-
-namespace __detail
-{
-  struct _Empty { };
-} // namespace __detail
-
-namespace views
-{
-  namespace __adaptor
-  {
-    template<typename _Callable>
-      struct _RangeAdaptorClosure;
-
-    template<typename _Callable>
-      struct _RangeAdaptor
-      {
-      protected:
-	[[no_unique_address]]
-	  conditional_t<!is_default_constructible_v<_Callable>,
-			_Callable, __detail::_Empty> _M_callable;
-
-      public:
-	constexpr
-	_RangeAdaptor(const _Callable& = {})
-	  requires is_default_constructible_v<_Callable>
-	{ }
-
-	constexpr
-	_RangeAdaptor(_Callable __callable)
-	  requires (!is_default_constructible_v<_Callable>)
-	  : _M_callable(std::move(__callable))
-	{ }
-
-	template<typename... _Args>
-	  requires (sizeof...(_Args) >= 1)
-	  constexpr auto
-	  operator()(_Args&&... __args) const
-	  {
-	    if constexpr (is_invocable_v<_Callable, _Args...>)
-	      {
-		static_assert(sizeof...(_Args) != 1,
-			      "a _RangeAdaptor that accepts only one argument "
-			      "should be defined as a _RangeAdaptorClosure");
-		return _Callable{}(std::forward<_Args>(__args)...);
-	      }
-	    else
-	      {
-		auto __closure = [__args...] <typename _Range> (_Range&& __r) {
-		  return _Callable{}(std::forward<_Range>(__r), __args...);
-		};
-		using _ClosureType = decltype(__closure);
-		return _RangeAdaptorClosure<_ClosureType>(std::move(__closure));
-	      }
-	  }
-      };
-
-    template<typename _Callable>
-      struct _RangeAdaptorClosure : public _RangeAdaptor<_Callable>
-      {
-	using _RangeAdaptor<_Callable>::_RangeAdaptor;
-
-	template<viewable_range _Range>
-	  requires requires { declval<_Callable>()(declval<_Range>()); }
-	  constexpr auto
-	  operator()(_Range&& __r) const
-	  {
-	    if constexpr (is_default_constructible_v<_Callable>)
-	      return _Callable{}(std::forward<_Range>(__r));
-	    else
-	      return this->_M_callable(std::forward<_Range>(__r));
-	  }
-
-	template<viewable_range _Range>
-	  requires requires { declval<_Callable>()(declval<_Range>()); }
-	  friend constexpr auto
-	  operator|(_Range&& __r, const _RangeAdaptorClosure& __o)
-	  { return __o(std::forward<_Range>(__r)); }
-
-	template<typename _Tp>
-	  friend constexpr auto
-	  operator|(const _RangeAdaptorClosure<_Tp>& __x,
-		    const _RangeAdaptorClosure& __y)
-	  {
-	    if constexpr (is_default_constructible_v<_Tp>
-			  && is_default_constructible_v<_Callable>)
-	      {
-		auto __closure = [] <typename _Up> (_Up&& __e) {
-		  return std::forward<_Up>(__e) | decltype(__x){} | decltype(__y){};
-		};
-		return _RangeAdaptorClosure<decltype(__closure)>(__closure);
-	      }
-	    else if constexpr (is_default_constructible_v<_Tp>
-			       && !is_default_constructible_v<_Callable>)
-	      {
-		auto __closure = [__y] <typename _Up> (_Up&& __e) {
-		  return std::forward<_Up>(__e) | decltype(__x){} | __y;
-		};
-		return _RangeAdaptorClosure<decltype(__closure)>(__closure);
-	      }
-	    else if constexpr (!is_default_constructible_v<_Tp>
-			       && is_default_constructible_v<_Callable>)
-	      {
-		auto __closure = [__x] <typename _Up> (_Up&& __e) {
-		  return std::forward<_Up>(__e) | __x | decltype(__y){};
-		};
-		return _RangeAdaptorClosure<decltype(__closure)>(__closure);
-	      }
-	    else
-	      {
-		auto __closure = [__x, __y] <typename _Up> (_Up&& __e) {
-		  return std::forward<_Up>(__e) | __x | __y;
-		};
-		return _RangeAdaptorClosure<decltype(__closure)>(__closure);
-	      }
-	  }
-      };
-
-    template<typename _Callable>
-      _RangeAdaptorClosure(_Callable) -> _RangeAdaptorClosure<_Callable>;
-  } // namespace __adaptor
 } // namespace views
-
-  template<range _Range> requires is_object_v<_Range>
-    class ref_view : public view_interface<ref_view<_Range>>
-    {
-    private:
-      _Range* _M_r = nullptr;
-
-      static void _S_fun(_Range&); // not defined
-      static void _S_fun(_Range&&) = delete;
-
-    public:
-      constexpr
-      ref_view() noexcept = default;
-
-      template<__detail::__not_same_as<ref_view> _Tp>
-	requires convertible_to<_Tp, _Range&>
-	  && requires { _S_fun(declval<_Tp>()); }
-	constexpr
-	ref_view(_Tp&& __t)
-	  : _M_r(std::__addressof(static_cast<_Range&>(std::forward<_Tp>(__t))))
-	{ }
-
-      constexpr _Range&
-      base() const
-      { return *_M_r; }
-
-      constexpr iterator_t<_Range>
-      begin() const
-      { return ranges::begin(*_M_r); }
-
-      constexpr sentinel_t<_Range>
-      end() const
-      { return ranges::end(*_M_r); }
-
-      constexpr bool
-      empty() const requires requires { ranges::empty(*_M_r); }
-      { return ranges::empty(*_M_r); }
-
-      constexpr auto
-      size() const requires sized_range<_Range>
-      { return ranges::size(*_M_r); }
-
-      constexpr auto
-      data() const requires contiguous_range<_Range>
-      { return ranges::data(*_M_r); }
-    };
-
-  template<typename _Range>
-    ref_view(_Range&) -> ref_view<_Range>;
-
-  template<typename _Tp>
-    inline constexpr bool enable_safe_range<ref_view<_Tp>> = true;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptorClosure all
-      = [] <viewable_range _Range> (_Range&& __r)
-      {
-	if constexpr (view<decay_t<_Range>>)
-	  return std::forward<_Range>(__r);
-	else if constexpr (requires { ref_view{std::forward<_Range>(__r)}; })
-	  return ref_view{std::forward<_Range>(__r)};
-	else
-	  return subrange{std::forward<_Range>(__r)};
-      };
-  } // namespace views
-
-  template<viewable_range _Range>
-    using all_view = decltype(views::all(declval<_Range>()));
-
-  // XXX: the following algos are copied from ranges_algo.h to avoid a circular
-  // dependency with that header.
-  namespace __detail
-  {
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr _Iter
-      find_if(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
-      {
-	while (__first != __last
-	    && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	  ++__first;
-	return __first;
-      }
-
-    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
-	     typename _Proj = identity,
-	     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
-      constexpr _Iter
-      find_if_not(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
-      {
-	while (__first != __last
-	    && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
-	  ++__first;
-	return __first;
-      }
-
-    template<typename _Tp, typename _Proj = identity,
-	     indirect_strict_weak_order<projected<const _Tp*, _Proj>>
-	       _Comp = ranges::less>
-      constexpr const _Tp&
-      min(const _Tp& __a, const _Tp& __b, _Comp __comp = {}, _Proj __proj = {})
-      {
-	if (std::__invoke(std::move(__comp),
-			  std::__invoke(__proj, __b),
-			  std::__invoke(__proj, __a)))
-	  return __b;
-	else
-	  return __a;
-      }
-
-    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
-	     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
-	     typename _Pred = ranges::equal_to,
-	     typename _Proj1 = identity, typename _Proj2 = identity>
-      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
-      constexpr pair<_Iter1, _Iter2>
-      mismatch(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
-	       _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})
-      {
-	while (__first1 != __last1 && __first2 != __last2
-	       && (bool)std::__invoke(__pred,
-				      std::__invoke(__proj1, *__first1),
-				      std::__invoke(__proj2, *__first2)))
-	{
-	  ++__first1;
-	  ++__first2;
-	}
-	return { std::move(__first1), std::move(__first2) };
-      }
-  } // namespace __detail
-
-  template<input_range _Vp,
-	   indirect_unary_predicate<iterator_t<_Vp>> _Pred>
-    requires view<_Vp> && is_object_v<_Pred>
-    class filter_view : public view_interface<filter_view<_Vp, _Pred>>
-    {
-    private:
-      struct _Sentinel;
-
-      struct _Iterator
-      {
-      private:
-	static constexpr auto
-	_S_iter_concept()
-	{
-	  if constexpr (bidirectional_range<_Vp>)
-	    return bidirectional_iterator_tag{};
-	  else if constexpr (forward_range<_Vp>)
-	    return forward_iterator_tag{};
-	  else
-	    return input_iterator_tag{};
-	}
-
-	static constexpr auto
-	_S_iter_cat()
-	{
-	  using _Cat = iterator_traits<iterator_t<_Vp>>::iterator_category;
-	  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)
-	    return bidirectional_iterator_tag{};
-	  else if constexpr (derived_from<_Cat, forward_iterator_tag>)
-	    return forward_iterator_tag{};
-	  else
-	    return _Cat{};
-	}
-
-	friend filter_view;
-
-	iterator_t<_Vp> _M_current = iterator_t<_Vp>();
-	filter_view* _M_parent = nullptr;
-
-      public:
-	using iterator_concept = decltype(_S_iter_concept());
-	using iterator_category = decltype(_S_iter_cat());
-	using value_type = range_value_t<_Vp>;
-	using difference_type = range_difference_t<_Vp>;
-
-	_Iterator() = default;
-
-	constexpr
-	_Iterator(filter_view& __parent, iterator_t<_Vp> __current)
-	  : _M_current(std::move(__current)),
-	    _M_parent(std::__addressof(__parent))
-	{ }
-
-	constexpr iterator_t<_Vp>
-	base() const &
-	  requires copyable<iterator_t<_Vp>>
-	{ return _M_current; }
-
-	constexpr iterator_t<_Vp>
-	base() &&
-	{ return std::move(_M_current); }
-
-	constexpr range_reference_t<_Vp>
-	operator*() const
-	{ return *_M_current; }
-
-	constexpr iterator_t<_Vp>
-	operator->() const
-	  requires __detail::__has_arrow<iterator_t<_Vp>>
-	    && copyable<iterator_t<_Vp>>
-	{ return _M_current; }
-
-	constexpr _Iterator&
-	operator++()
-	{
-	  _M_current = __detail::find_if(std::move(++_M_current),
-					 ranges::end(_M_parent->_M_base),
-					 std::ref(*_M_parent->_M_pred));
-	  return *this;
-	}
-
-	constexpr void
-	operator++(int)
-	{ ++*this; }
-
-	constexpr _Iterator
-	operator++(int) requires forward_range<_Vp>
-	{
-	  auto __tmp = *this;
-	  ++*this;
-	  return __tmp;
-	}
-
-	constexpr _Iterator&
-	operator--() requires bidirectional_range<_Vp>
-	{
-	  do
-	    --_M_current;
-	  while (!std::__invoke(*_M_parent->_M_pred, *_M_current));
-	  return *this;
-	}
-
-	constexpr _Iterator
-	operator--(int) requires bidirectional_range<_Vp>
-	{
-	  auto __tmp = *this;
-	  --*this;
-	  return __tmp;
-	}
-
-	friend constexpr bool
-	operator==(const _Iterator& __x, const _Iterator& __y)
-	  requires equality_comparable<iterator_t<_Vp>>
-	{ return __x._M_current == __y._M_current; }
-
-	friend constexpr range_rvalue_reference_t<_Vp>
-	iter_move(const _Iterator& __i)
-	  noexcept(noexcept(ranges::iter_move(__i._M_current)))
-	{ return ranges::iter_move(__i._M_current); }
-
-	friend constexpr void
-	iter_swap(const _Iterator& __x, const _Iterator& __y)
-	  noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
-	  requires indirectly_swappable<iterator_t<_Vp>>
-	{ ranges::iter_swap(__x._M_current, __y._M_current); }
-      };
-
-      struct _Sentinel
-      {
-      private:
-	sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();
-
-	constexpr bool
-	__equal(const _Iterator& __i) const
-	{ return __i._M_current == _M_end; }
-
-      public:
-	_Sentinel() = default;
-
-	constexpr explicit
-	_Sentinel(filter_view& __parent)
-	  : _M_end(ranges::end(__parent._M_base))
-	{ }
-
-	constexpr sentinel_t<_Vp>
-	base() const
-	{ return _M_end; }
-
-	friend constexpr bool
-	operator==(const _Iterator& __x, const _Sentinel& __y)
-	{ return __y.__equal(__x); }
-      };
-
-      _Vp _M_base = _Vp();
-      __detail::__box<_Pred> _M_pred;
-
-    public:
-      filter_view() = default;
-
-      constexpr
-      filter_view(_Vp __base, _Pred __pred)
-	: _M_base(std::move(__base)), _M_pred(std::move(__pred))
-      { }
-
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range>
-	requires viewable_range<_Range>
-	  && constructible_from<_Vp, all_view<_Range>>
-	constexpr
-	filter_view(_Range&& __r, _Pred __pred)
-	  : _M_base(views::all(std::forward<_Range>(__r))),
-	    _M_pred(std::move(__pred))
-	{ }
-      */
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr _Iterator
-      begin()
-      {
-	// XXX: we need to cache the result here as per [range.filter.view]
-	__glibcxx_assert(_M_pred.has_value());
-	return {*this, __detail::find_if(ranges::begin(_M_base),
-					 ranges::end(_M_base),
-					 std::ref(*_M_pred))};
-      }
-
-      constexpr auto
-      end()
-      {
-	if constexpr (common_range<_Vp>)
-	  return _Iterator{*this, ranges::end(_M_base)};
-	else
-	  return _Sentinel{*this};
-      }
-    };
-
-  template<typename _Range, typename _Pred>
-    filter_view(_Range&&, _Pred) -> filter_view<all_view<_Range>, _Pred>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptor filter
-      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)
-      {
-	return filter_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};
-      };
-  } // namespace views
-
-  template<input_range _Vp, copy_constructible _Fp>
-    requires view<_Vp> && is_object_v<_Fp>
-      && regular_invocable<_Fp&, range_reference_t<_Vp>>
-    class transform_view : public view_interface<transform_view<_Vp, _Fp>>
-    {
-    private:
-      template<bool _Const>
-	struct _Sentinel;
-
-      template<bool _Const>
-	struct _Iterator
-	{
-	private:
-	  using _Parent
-	    = conditional_t<_Const, const transform_view, transform_view>;
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  static constexpr auto
-	  _S_iter_concept()
-	  {
-	    if constexpr (random_access_range<_Vp>)
-	      return random_access_iterator_tag{};
-	    else if constexpr (bidirectional_range<_Vp>)
-	      return bidirectional_iterator_tag{};
-	    else if constexpr (forward_range<_Vp>)
-	      return forward_iterator_tag{};
-	    else
-	      return input_iterator_tag{};
-	  }
-
-	  static constexpr auto
-	  _S_iter_cat()
-	  {
-	    using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;
-	    if constexpr (derived_from<_Cat, contiguous_iterator_tag>)
-	      return random_access_iterator_tag{};
-	    else
-	      return _Cat{};
-	  }
-
-	  static constexpr decltype(auto)
-	  __iter_move(const _Iterator& __i = {})
-	    noexcept(noexcept(std::__invoke(*__i._M_parent->_M_fun,
-					    *__i._M_current)))
-	  {
-	    if constexpr (is_lvalue_reference_v<decltype(*__i)>)
-	      return std::move(*__i);
-	    else
-	      return *__i;
-	  }
-
-	  iterator_t<_Base> _M_current = iterator_t<_Base>();
-	  _Parent* _M_parent = nullptr;
-
-	public:
-	  using iterator_concept = decltype(_S_iter_concept());
-	  using iterator_category = decltype(_S_iter_cat());
-	  using value_type
-	    = remove_cvref_t<invoke_result_t<_Fp&, range_reference_t<_Base>>>;
-	  using difference_type = range_difference_t<_Base>;
-
-	  _Iterator() = default;
-
-	  constexpr
-	  _Iterator(_Parent& __parent, iterator_t<_Base> __current)
-	    : _M_current(std::move(__current)),
-	      _M_parent(std::__addressof(__parent))
-	  { }
-
-	  constexpr
-	  _Iterator(_Iterator<!_Const> __i)
-	    requires _Const
-	      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
-	    : _M_current(std::move(__i._M_current)), _M_parent(__i._M_parent)
-	  { }
-
-	  constexpr iterator_t<_Base>
-	  base() const &
-	    requires copyable<iterator_t<_Base>>
-	  { return _M_current; }
-
-	  constexpr iterator_t<_Base>
-	  base() &&
-	  { return std::move(_M_current); }
-
-	  constexpr decltype(auto)
-	  operator*() const
-	  { return std::__invoke(*_M_parent->_M_fun, *_M_current); }
-
-	  constexpr _Iterator&
-	  operator++()
-	  {
-	    ++_M_current;
-	    return *this;
-	  }
-
-	  constexpr void
-	  operator++(int)
-	  { ++_M_current; }
-
-	  constexpr _Iterator
-	  operator++(int) requires forward_range<_Base>
-	  {
-	    auto __tmp = *this;
-	    ++*this;
-	    return __tmp;
-	  }
-
-	  constexpr _Iterator&
-	  operator--() requires bidirectional_range<_Base>
-	  {
-	    --_M_current;
-	    return *this;
-	  }
-
-	  constexpr _Iterator
-	  operator--(int) requires bidirectional_range<_Base>
-	  {
-	    auto __tmp = *this;
-	    --*this;
-	    return __tmp;
-	  }
-
-	  constexpr _Iterator&
-	  operator+=(difference_type __n) requires random_access_range<_Base>
-	  {
-	    _M_current += __n;
-	    return *this;
-	  }
-
-	  constexpr _Iterator&
-	  operator-=(difference_type __n) requires random_access_range<_Base>
-	  {
-	    _M_current -= __n;
-	    return *this;
-	  }
-
-	  constexpr decltype(auto)
-	  operator[](difference_type __n) const
-	    requires random_access_range<_Base>
-	  { return std::__invoke(*_M_parent->_M_fun, _M_current[__n]); }
-
-	  friend constexpr bool
-	  operator==(const _Iterator& __x, const _Iterator& __y)
-	    requires equality_comparable<iterator_t<_Base>>
-	  { return __x._M_current == __y._M_current; }
-
-	  friend constexpr bool
-	  operator<(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return __x._M_current < __y._M_current; }
-
-	  friend constexpr bool
-	  operator>(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return __y < __x; }
-
-	  friend constexpr bool
-	  operator<=(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return !(__y < __x); }
-
-	  friend constexpr bool
-	  operator>=(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return !(__x < __y); }
-
-#ifdef __cpp_lib_three_way_comparison
-	  friend constexpr auto
-	  operator<=>(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	      && three_way_comparable<iterator_t<_Base>>
-	  { return __x._M_current <=> __y._M_current; }
-#endif
-
-	  friend constexpr _Iterator
-	  operator+(_Iterator __i, difference_type __n)
-	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current + __n}; }
-
-	  friend constexpr _Iterator
-	  operator+(difference_type __n, _Iterator __i)
-	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current + __n}; }
-
-	  friend constexpr _Iterator
-	  operator-(_Iterator __i, difference_type __n)
-	    requires random_access_range<_Base>
-	  { return {*__i._M_parent, __i._M_current - __n}; }
-
-	  friend constexpr difference_type
-	  operator-(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return __x._M_current - __y._M_current; }
-
-	  friend constexpr decltype(auto)
-	  iter_move(const _Iterator& __i) noexcept(noexcept(__iter_move()))
-	  { return __iter_move(__i); }
-
-	  friend constexpr void
-	  iter_swap(const _Iterator& __x, const _Iterator& __y)
-	    noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
-	    requires indirectly_swappable<iterator_t<_Base>>
-	  { return ranges::iter_swap(__x._M_current, __y._M_current); }
-
-	  friend _Sentinel<_Const>;
-	};
-
-      template<bool _Const>
-	struct _Sentinel
-	{
-	private:
-	  using _Parent
-	    = conditional_t<_Const, const transform_view, transform_view>;
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  constexpr range_difference_t<_Base>
-	  __distance_from(const _Iterator<_Const>& __i) const
-	  { return _M_end - __i._M_current; }
-
-	  constexpr bool
-	  __equal(const _Iterator<_Const>& __i) const
-	  { return __i._M_current == _M_end; }
-
-	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();
-
-	public:
-	  _Sentinel() = default;
-
-	  constexpr explicit
-	  _Sentinel(sentinel_t<_Base> __end)
-	    : _M_end(__end)
-	  { }
-
-	  constexpr
-	  _Sentinel(_Sentinel<!_Const> __i)
-	    requires _Const
-	      && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
-	    : _M_end(std::move(__i._M_end))
-	  { }
-
-	  constexpr sentinel_t<_Base>
-	  base() const
-	  { return _M_end; }
-
-	  friend constexpr bool
-	  operator==(const _Iterator<_Const>& __x, const _Sentinel& __y)
-	  { return __y.__equal(__x); }
-
-	  friend constexpr range_difference_t<_Base>
-	  operator-(const _Iterator<_Const>& __x, const _Sentinel& __y)
-	    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
-	  { return -__y.__distance_from(__x); }
-
-	  friend constexpr range_difference_t<_Base>
-	  operator-(const _Sentinel& __y, const _Iterator<_Const>& __x)
-	    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
-	  { return __y.__distance_from(__x); }
-	};
-
-      _Vp _M_base = _Vp();
-      __detail::__box<_Fp> _M_fun;
-
-    public:
-      transform_view() = default;
-
-      constexpr
-      transform_view(_Vp __base, _Fp __fun)
-	: _M_base(std::move(__base)), _M_fun(std::move(__fun))
-      { }
-
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range>
-	requires viewable_range<_Range>
-	  && constructible_from<_Vp, all_view<_Range>>
-	constexpr
-	transform_view(_Range&& __r, _Fp __fun)
-	  : _M_base(views::all(std::forward<_Range>(__r)))
-	{
-	}
-	*/
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base ; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr _Iterator<false>
-      begin()
-      { return _Iterator<false>{*this, ranges::begin(_M_base)}; }
-
-      constexpr _Iterator<true>
-      begin() const
-	requires range<const _Vp>
-	  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>
-      { return _Iterator<true>{*this, ranges::begin(_M_base)}; }
-
-      constexpr _Sentinel<false>
-      end()
-      { return _Sentinel<false>{ranges::end(_M_base)}; }
-
-      constexpr _Iterator<false>
-      end() requires common_range<_Vp>
-      { return _Iterator<false>{*this, ranges::end(_M_base)}; }
-
-      constexpr _Sentinel<true>
-      end() const
-	requires range<const _Vp>
-	  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>
-      { return _Sentinel<true>{ranges::end(_M_base)}; }
-
-      constexpr _Iterator<true>
-      end() const
-	requires common_range<const _Vp>
-	  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>
-      { return _Iterator<true>{*this, ranges::end(_M_base)}; }
-
-      constexpr auto
-      size() requires sized_range<_Vp>
-      { return ranges::size(_M_base); }
-
-      constexpr auto
-      size() const requires sized_range<const _Vp>
-      { return ranges::size(_M_base); }
-    };
-
-  template<typename _Range, typename _Fp>
-    transform_view(_Range&&, _Fp) -> transform_view<all_view<_Range>, _Fp>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptor transform
-      = [] <viewable_range _Range, typename _Fp> (_Range&& __r, _Fp&& __f)
-      {
-	return transform_view{std::forward<_Range>(__r), std::forward<_Fp>(__f)};
-      };
-  } // namespace views
-
-  template<view _Vp>
-    class take_view : public view_interface<take_view<_Vp>>
-    {
-    private:
-      template<bool _Const>
-	struct _Sentinel
-	{
-	private:
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-	  using _CI = counted_iterator<iterator_t<_Base>>;
-
-	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();
-
-	public:
-	  _Sentinel() = default;
-
-	  constexpr explicit
-	  _Sentinel(sentinel_t<_Base> __end)
-	    : _M_end(__end)
-	  { }
-
-	  constexpr
-	  _Sentinel(_Sentinel<!_Const> __s)
-	    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
-	    : _M_end(std::move(__s._M_end))
-	  { }
-
-	  constexpr sentinel_t<_Base>
-	  base() const
-	  { return _M_end; }
-
-	  friend constexpr bool operator==(const _CI& __y, const _Sentinel& __x)
-	  { return __y.count() == 0 || __y.base() == __x._M_end; }
-	};
-
-      _Vp _M_base = _Vp();
-      range_difference_t<_Vp> _M_count = 0;
-
-    public:
-      take_view() = default;
-
-      constexpr
-      take_view(_Vp base, range_difference_t<_Vp> __count)
-	: _M_base(std::move(base)), _M_count(std::move(__count))
-      { }
-
-      /* XXX: P3280 removes this constructor
-      template<viewable_range _Range>
-	requires constructible_from<_Vp, all_view<_Range>>
-      constexpr
-      take_view(_Range&& __r, range_difference_t<_Vp> __count)
-	: _M_base(views::all(std::forward<_Range>(__r))), _M_count(__count)
-      { }
-      */
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr auto
-      begin() requires (!__detail::__simple_view<_Vp>)
-      {
-	if constexpr (sized_range<_Vp>)
-	  {
-	    if constexpr (random_access_range<_Vp>)
-	      return ranges::begin(_M_base);
-	    else
-	      return counted_iterator{ranges::begin(_M_base), size()};
-	  }
-	else
-	  return counted_iterator{ranges::begin(_M_base), _M_count};
-      }
-
-      constexpr auto
-      begin() const requires range<const _Vp>
-      {
-	if constexpr (sized_range<const _Vp>)
-	  {
-	    if constexpr (random_access_range<const _Vp>)
-	      return ranges::begin(_M_base);
-	    else
-	      return counted_iterator{ranges::begin(_M_base), size()};
-	  }
-	else
-	  return counted_iterator{ranges::begin(_M_base), _M_count};
-      }
-
-      constexpr auto
-      end() requires (!__detail::__simple_view<_Vp>)
-      {
-	if constexpr (sized_range<_Vp>)
-	  {
-	    if constexpr (random_access_range<_Vp>)
-	      return ranges::begin(_M_base) + size();
-	    else
-	      return default_sentinel;
-	  }
-	else
-	  return _Sentinel<false>{ranges::end(_M_base)};
-      }
-
-      constexpr auto
-      end() const requires range<const _Vp>
-      {
-	if constexpr (sized_range<const _Vp>)
-	  {
-	    if constexpr (random_access_range<const _Vp>)
-	      return ranges::begin(_M_base) + size();
-	    else
-	      return default_sentinel;
-	  }
-	else
-	  return _Sentinel<true>{ranges::end(_M_base)};
-      }
-
-      constexpr auto
-      size() requires sized_range<_Vp>
-      {
-	auto __n = ranges::size(_M_base);
-	return __detail::min(__n, static_cast<decltype(__n)>(_M_count));
-      }
-
-      constexpr auto
-      size() const requires sized_range<const _Vp>
-      {
-	auto __n = ranges::size(_M_base);
-	return __detail::min(__n, static_cast<decltype(__n)>(_M_count));
-      }
-    };
-
-  template<range _Range>
-    take_view(_Range&&, range_difference_t<_Range>)
-      -> take_view<all_view<_Range>>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptor take
-      = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)
-      {
-	return take_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};
-      };
-  } // namespace views
-
-  template<view _Vp, typename _Pred>
-    requires input_range<_Vp> && is_object_v<_Pred>
-      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>
-    class take_while_view : public view_interface<take_while_view<_Vp, _Pred>>
-    {
-      template<bool _Const>
-	struct _Sentinel
-	{
-	private:
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();
-	  const _Pred* _M_pred = nullptr;
-
-	public:
-	  _Sentinel() = default;
-
-	  constexpr explicit
-	  _Sentinel(sentinel_t<_Base> __end, const _Pred* __pred)
-	    : _M_end(__end), _M_pred(__pred)
-	  { }
-
-	  constexpr
-	  _Sentinel(_Sentinel<!_Const> __s)
-	    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
-	    : _M_end(__s._M_end), _M_pred(__s._M_pred)
-	  { }
-
-	  constexpr sentinel_t<_Base>
-	  base() const { return _M_end; }
-
-	  friend constexpr bool
-	  operator==(const iterator_t<_Base>& __x, const _Sentinel& __y)
-	  { return __y._M_end == __x || !std::__invoke(*__y._M_pred, *__x); }
-	};
-
-      _Vp _M_base;
-      __detail::__box<_Pred> _M_pred;
-
-    public:
-      take_while_view() = default;
-
-      constexpr
-      take_while_view(_Vp base, _Pred __pred)
-	: _M_base(std::move(base)), _M_pred(std::move(__pred))
-      {
-      }
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr const _Pred&
-      pred() const
-      { return *_M_pred; }
-
-      constexpr auto
-      begin() requires (!__detail::__simple_view<_Vp>)
-      { return ranges::begin(_M_base); }
-
-      constexpr auto
-      begin() const requires range<const _Vp>
-      { return ranges::begin(_M_base); }
-
-      constexpr auto
-      end() requires (!__detail::__simple_view<_Vp>)
-      { return _Sentinel<false>(ranges::end(_M_base),
-				std::__addressof(*_M_pred)); }
-
-      constexpr auto
-      end() const requires range<const _Vp>
-      { return _Sentinel<true>(ranges::end(_M_base),
-			       std::__addressof(*_M_pred)); }
-    };
-
-  template<typename _Range, typename _Pred>
-    take_while_view(_Range&&, _Pred)
-      -> take_while_view<all_view<_Range>, _Pred>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptor take_while
-      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)
-      {
-	return take_while_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};
-      };
-  } // namespace views
-
-  template<view _Vp>
-    class drop_view : public view_interface<drop_view<_Vp>>
-    {
-    private:
-      _Vp _M_base;
-      range_difference_t<_Vp> _M_count;
-
-    public:
-      drop_view() = default;
-
-      constexpr
-      drop_view(_Vp __base, range_difference_t<_Vp> __count)
-	: _M_base(std::move(__base)), _M_count(__count)
-      { __glibcxx_assert(__count >= 0); }
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr auto
-      begin() requires (!(__detail::__simple_view<_Vp>
-			  && random_access_range<_Vp>))
-      {
-	// XXX: we need to cache the result here as per [range.drop.view]
-	return ranges::next(ranges::begin(_M_base), _M_count,
-			    ranges::end(_M_base));
-      }
-
-      constexpr auto
-      begin() const requires random_access_range<const _Vp>
-      {
-	return ranges::next(ranges::begin(_M_base), _M_count,
-			    ranges::end(_M_base));
-      }
-
-      constexpr auto
-      end() requires (!__detail::__simple_view<_Vp>)
-      { return ranges::end(_M_base); }
-
-      constexpr auto
-      end() const requires range<const _Vp>
-      { return ranges::end(_M_base); }
-
-      constexpr auto
-      size() requires sized_range<_Vp>
-      {
-	const auto __s = ranges::size(_M_base);
-	const auto __c = static_cast<decltype(__s)>(_M_count);
-	return __s < __c ? 0 : __s - __c;
-      }
-
-      constexpr auto
-      size() const requires sized_range<const _Vp>
-      {
-	const auto __s = ranges::size(_M_base);
-	const auto __c = static_cast<decltype(__s)>(_M_count);
-	return __s < __c ? 0 : __s - __c;
-      }
-    };
-
-  template<typename _Range>
-    drop_view(_Range&&, range_difference_t<_Range>)
-      -> drop_view<all_view<_Range>>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptor drop
-      = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)
-      {
-	return drop_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};
-      };
-  } // namespace views
-
-  template<view _Vp, typename _Pred>
-    requires input_range<_Vp> && is_object_v<_Pred>
-      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>
-    class drop_while_view : public view_interface<drop_while_view<_Vp, _Pred>>
-    {
-    private:
-      _Vp _M_base;
-      __detail::__box<_Pred> _M_pred;
-
-    public:
-      drop_while_view() = default;
-
-      constexpr
-      drop_while_view(_Vp __base, _Pred __pred)
-	: _M_base(std::move(__base)), _M_pred(std::move(__pred))
-      { }
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr const _Pred&
-      pred() const
-      { return *_M_pred; }
-
-      constexpr auto
-      begin()
-      {
-	// XXX: we need to cache the result here as per [range.drop.while.view]
-	return __detail::find_if_not(ranges::begin(_M_base),
-				     ranges::end(_M_base),
-				     std::cref(*_M_pred));
-      }
-
-      constexpr auto
-      end()
-      { return ranges::end(_M_base); }
-    };
-
-  template<typename _Range, typename _Pred>
-    drop_while_view(_Range&&, _Pred)
-      -> drop_while_view<all_view<_Range>, _Pred>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptor drop_while
-      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)
-      {
-	return drop_while_view{std::forward<_Range>(__r),
-			       std::forward<_Pred>(__p)};
-      };
-  } // namespace views
-
-  template<input_range _Vp>
-    requires view<_Vp> && input_range<range_reference_t<_Vp>>
-      && (is_reference_v<range_reference_t<_Vp>>
-	  || view<range_value_t<_Vp>>)
-    class join_view : public view_interface<join_view<_Vp>>
-    {
-    private:
-      using _InnerRange = range_reference_t<_Vp>;
-
-      template<bool _Const>
-	struct _Sentinel;
-
-      template<bool _Const>
-	struct _Iterator
-	{
-	private:
-	  using _Parent = conditional_t<_Const, const join_view, join_view>;
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  static constexpr bool _S_ref_is_glvalue
-	    = is_reference_v<range_reference_t<_Base>>;
-
-	  constexpr void
-	  _M_satisfy()
-	  {
-	    auto __update_inner = [this] (range_reference_t<_Base> __x) -> auto&
-	    {
-	      if constexpr (_S_ref_is_glvalue)
-		return __x;
-	      else
-		return (_M_parent->_M_inner = views::all(std::move(__x)));
-	    };
-
-	    for (; _M_outer != ranges::end(_M_parent->_M_base); ++_M_outer)
-	      {
-		auto& inner = __update_inner(*_M_outer);
-		_M_inner = ranges::begin(inner);
-		if (_M_inner != ranges::end(inner))
-		  return;
-	      }
-
-	    if constexpr (_S_ref_is_glvalue)
-	      _M_inner = iterator_t<range_reference_t<_Base>>();
-	  }
-
-	  static constexpr auto
-	  _S_iter_concept()
-	  {
-	    if constexpr (_S_ref_is_glvalue
-			  && bidirectional_range<_Base>
-			  && bidirectional_range<range_reference_t<_Base>>)
-	      return bidirectional_iterator_tag{};
-	    else if constexpr (_S_ref_is_glvalue
-			       && forward_range<_Base>
-			       && forward_range<range_reference_t<_Base>>)
-	      return forward_iterator_tag{};
-	    else
-	      return input_iterator_tag{};
-	  }
-
-	  static constexpr auto
-	  _S_iter_cat()
-	  {
-	    using _OuterCat
-	      = iterator_traits<iterator_t<_Base>>::iterator_category;
-	    using _InnerCat
-	      = iterator_traits<iterator_t<range_reference_t<_Base>>>
-		 ::iterator_category;
-	    if constexpr (_S_ref_is_glvalue
-			  && derived_from<_OuterCat, bidirectional_iterator_tag>
-			  && derived_from<_InnerCat, bidirectional_iterator_tag>)
-	      return bidirectional_iterator_tag{};
-	    else if constexpr (_S_ref_is_glvalue
-			       && derived_from<_OuterCat, forward_iterator_tag>
-			       && derived_from<_InnerCat, forward_iterator_tag>)
-	      return forward_iterator_tag{};
-	    else if constexpr (derived_from<_OuterCat, input_iterator_tag>
-			       && derived_from<_InnerCat, input_iterator_tag>)
-	      return input_iterator_tag{};
-	    else
-	      return output_iterator_tag{};
-	  }
-
-	  iterator_t<_Base> _M_outer = iterator_t<_Base>();
-	  iterator_t<range_reference_t<_Base>> _M_inner
-	    = iterator_t<range_reference_t<_Base>>();
-	  _Parent* _M_parent = nullptr;
-
-	public:
-	  using iterator_concept = decltype(_S_iter_concept());
-	  using iterator_category = decltype(_S_iter_cat());
-	  using value_type = range_value_t<range_reference_t<_Base>>;
-	  using difference_type
-	    = common_type_t<range_difference_t<_Base>,
-			    range_difference_t<range_reference_t<_Base>>>;
-
-	  _Iterator() = default;
-
-	  // XXX: had to change the type of __outer from iterator_t<_Vp> to
-	  // iterator_t<_Base> here, a possible defect in the spec?
-	  constexpr
-	  _Iterator(_Parent& __parent, iterator_t<_Base> __outer)
-	    : _M_outer(std::move(__outer)),
-	      _M_parent(std::__addressof(__parent))
-	  { _M_satisfy(); }
-
-	  constexpr
-	  _Iterator(_Iterator<!_Const> __i)
-	    requires _Const
-	      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
-	      && convertible_to<iterator_t<_InnerRange>,
-				iterator_t<range_reference_t<_Base>>>
-	    : _M_outer(std::move(__i._M_outer)), _M_inner(__i._M_inner),
-	      _M_parent(__i._M_parent)
-	  { }
-
-	  constexpr decltype(auto)
-	  operator*() const
-	  { return *_M_inner; }
-
-	  constexpr iterator_t<_Base>
-	  operator->() const
-	    requires __detail::__has_arrow<iterator_t<_Base>>
-	      && copyable<iterator_t<_Base>>
-	  { return _M_inner; }
-
-	  constexpr _Iterator&
-	  operator++()
-	  {
-	    auto&& __inner_range = [this] () -> decltype(auto) {
-	      if constexpr (_S_ref_is_glvalue)
-		return *_M_outer;
-	      else
-		return _M_parent->_M_inner;
-	    }();
-	    if (++_M_inner == ranges::end(__inner_range))
-	      {
-		++_M_outer;
-		_M_satisfy();
-	      }
-	    return *this;
-	  }
-
-	  constexpr void
-	  operator++(int)
-	  { ++*this; }
-
-	  constexpr _Iterator
-	  operator++(int)
-	    requires _S_ref_is_glvalue && forward_range<_Base>
-	      && forward_range<range_reference_t<_Base>>
-	  {
-	    auto __tmp = *this;
-	    ++*this;
-	    return __tmp;
-	  }
-
-	  constexpr _Iterator&
-	  operator--()
-	    requires _S_ref_is_glvalue && bidirectional_range<_Base>
-	      && bidirectional_range<range_reference_t<_Base>>
-	  {
-	    if (_M_outer == ranges::end(_M_parent->_M_base))
-	      _M_inner = ranges::end(*--_M_outer);
-	    while (_M_inner == ranges::begin(*_M_outer))
-	      _M_inner = ranges::end(*--_M_outer);
-	    --_M_inner;
-	    return *this;
-	  }
-
-	  constexpr _Iterator
-	  operator--(int)
-	    requires _S_ref_is_glvalue && bidirectional_range<_Base>
-	      && bidirectional_range<range_reference_t<_Base>>
-	  {
-	    auto __tmp = *this;
-	    --*this;
-	    return __tmp;
-	  }
-
-	  friend constexpr bool
-	  operator==(const _Iterator& __x, const _Iterator& __y)
-	    requires _S_ref_is_glvalue
-	      && equality_comparable<iterator_t<_Base>>
-	      && equality_comparable<iterator_t<range_reference_t<_Base>>>
-	  {
-	    return (__x._M_outer == __y._M_outer
-		    && __x._M_inner == __y._M_inner);
-	  }
-
-	  friend constexpr decltype(auto)
-	  iter_move(const _Iterator& __i)
-	  noexcept(noexcept(ranges::iter_move(__i._M_inner)))
-	  { return ranges::iter_move(__i._M_inner); }
-
-	  friend constexpr void
-	  iter_swap(const _Iterator& __x, const _Iterator& __y)
-	    noexcept(noexcept(ranges::iter_swap(__x._M_inner, __y._M_inner)))
-	  { return ranges::iter_swap(__x._M_inner, __y._M_inner); }
-
-	  friend _Sentinel<_Const>;
-	};
-
-      template<bool _Const>
-	struct _Sentinel
-	{
-	private:
-	  using _Parent = conditional_t<_Const, const join_view, join_view>;
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  constexpr bool
-	  __equal(const _Iterator<_Const>& __i) const
-	  { return __i._M_outer == _M_end; }
-
-	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();
-
-	public:
-	  _Sentinel() = default;
-
-	  constexpr explicit
-	  _Sentinel(_Parent& __parent)
-	    : _M_end(ranges::end(__parent._M_base))
-	  { }
-
-	  constexpr
-	  _Sentinel(_Sentinel<!_Const> __s)
-	    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
-	    : _M_end(std::move(__s._M_end))
-	  { }
-
-	  friend constexpr bool
-	  operator==(const _Iterator<_Const>& __x, const _Sentinel& __y)
-	  { return __y.__equal(__x); }
-	};
-
-      _Vp _M_base = _Vp();
-
-      // XXX: _M_inner is "present only when !is_reference_v<_InnerRange>"
-      // Applied P3278 and made this field mutable.
-      [[no_unique_address]] mutable
-	conditional_t<!is_reference_v<_InnerRange>,
-		      all_view<_InnerRange>, __detail::_Empty> _M_inner;
-
-    public:
-      join_view() = default;
-
-      constexpr explicit
-      join_view(_Vp __base)
-	: _M_base(std::move(__base))
-      { }
-
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range>
-	requires viewable_range<_Range>
-	  && constructible_from<_Vp, all_view<_Range>>
-      constexpr explicit
-      join_view(_Range&& __r)
-	: _M_base(views::all(std::forward<_Range>(__r)))
-      { }
-      */
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr auto
-      begin()
-      {
-	return _Iterator<__detail::__simple_view<_Vp>>{*this,
-						       ranges::begin(_M_base)};
-      }
-
-      constexpr auto
-      begin() const
-	requires input_range<const _Vp>
-	  && is_reference_v<range_reference_t<const _Vp>>
-      {
-	return _Iterator<true>{*this, ranges::begin(_M_base)};
-      }
-
-      constexpr auto
-      end()
-      {
-	if constexpr (forward_range<_Vp> && is_reference_v<_InnerRange>
-		      && forward_range<_InnerRange>
-		      && common_range<_Vp> && common_range<_InnerRange>)
-	  return _Iterator<__detail::__simple_view<_Vp>>{*this,
-							 ranges::end(_M_base)};
-	else
-	  return _Sentinel<__detail::__simple_view<_Vp>>{*this};
-      }
-
-      constexpr auto
-      end() const
-	requires input_range<const _Vp>
-	  && is_reference_v<range_reference_t<const _Vp>>
-      {
-	if constexpr (forward_range<const _Vp>
-		      && is_reference_v<range_reference_t<const _Vp>>
-		      && forward_range<range_reference_t<const _Vp>>
-		      && common_range<const _Vp>
-		      && common_range<range_reference_t<const _Vp>>)
-	  return _Iterator<true>{*this, ranges::end(_M_base)};
-	else
-	  return _Sentinel<true>{*this};
-      }
-    };
-
-  template<typename _Range>
-    explicit join_view(_Range&&) -> join_view<all_view<_Range>>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptorClosure join
-      = [] <viewable_range _Range> (_Range&& __r)
-      {
-	return join_view{std::forward<_Range>(__r)};
-      };
-  } // namespace views
-
-  namespace __detail
-  {
-    template<auto>
-      struct __require_constant;
-
-    template<typename _Range>
-      concept __tiny_range = sized_range<_Range>
-	&& requires
-	   { typename __require_constant<remove_reference_t<_Range>::size()>; }
-	&& (remove_reference_t<_Range>::size() <= 1);
-  }
-
-  template<input_range _Vp, forward_range _Pattern>
-    requires view<_Vp> && view<_Pattern>
-      && indirectly_comparable<iterator_t<_Vp>, iterator_t<_Pattern>,
-			       ranges::equal_to>
-      && (forward_range<_Vp> || __detail::__tiny_range<_Pattern>)
-    class split_view : public view_interface<split_view<_Vp, _Pattern>>
-    {
-    private:
-      template<bool _Const>
-	struct _InnerIter;
-
-      template<bool _Const>
-	struct _OuterIter
-	{
-	private:
-	  using _Parent = conditional_t<_Const, const split_view, split_view>;
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  constexpr bool
-	  __at_end() const
-	  { return _M_current == ranges::end(_M_parent->_M_base); }
-
-	  // XXX: [24.7.11.3.1]
-	  //  Many of the following specifications refer to the notional member
-	  //  current of outer-iterator.  current is equivalent to current_ if
-	  //  V models forward_range, and parent_->current_ otherwise.
-	  constexpr auto&
-	  __current()
-	  {
-	    if constexpr (forward_range<_Vp>)
-	      return _M_current;
-	    else
-	      return _M_parent->_M_current;
-	  }
-
-	  constexpr auto&
-	  __current() const
-	  {
-	    if constexpr (forward_range<_Vp>)
-	      return _M_current;
-	    else
-	      return _M_parent->_M_current;
-	  }
-
-	  _Parent* _M_parent = nullptr;
-
-	  // XXX: _M_current is present only if "V models forward_range"
-	  [[no_unique_address]]
-	    conditional_t<forward_range<_Vp>,
-			  iterator_t<_Base>, __detail::_Empty> _M_current;
-
-	public:
-	  using iterator_concept = conditional_t<forward_range<_Base>,
-						 forward_iterator_tag,
-						 input_iterator_tag>;
-	  using iterator_category = input_iterator_tag;
-	  using difference_type = range_difference_t<_Base>;
-
-	  struct value_type : view_interface<value_type>
-	  {
-	  private:
-	    _OuterIter _M_i = _OuterIter();
-
-	  public:
-	    value_type() = default;
-
-	    constexpr explicit
-	    value_type(_OuterIter __i)
-	      : _M_i(std::move(__i))
-	    { }
-
-	    constexpr _InnerIter<_Const>
-	    begin() const
-	      requires copyable<_OuterIter>
-	    { return _InnerIter<_Const>{_M_i}; }
-
-	    constexpr _InnerIter<_Const>
-	    begin()
-	      requires (!copyable<_OuterIter>)
-	    { return _InnerIter<_Const>{std::move(_M_i)}; }
-
-	    constexpr default_sentinel_t
-	    end() const
-	    { return default_sentinel; }
-	  };
-
-	  _OuterIter() = default;
-
-	  constexpr explicit
-	  _OuterIter(_Parent& __parent) requires (!forward_range<_Base>)
-	    : _M_parent(address(__parent))
-	  { }
-
-	  constexpr
-	  _OuterIter(_Parent& __parent, iterator_t<_Base> __current)
-	    requires forward_range<_Base>
-	    : _M_parent(std::__addressof(__parent)),
-	      _M_current(std::move(__current))
-	  { }
-
-	  constexpr
-	  _OuterIter(_OuterIter<!_Const> __i)
-	    requires _Const
-	      && convertible_to<iterator_t<_Vp>, iterator_t<const _Vp>>
-	    : _M_parent(__i._M_parent), _M_current(std::move(__i._M_current))
-	  { }
-
-	  constexpr value_type
-	  operator*() const
-	  { return value_type{*this}; }
-
-	  constexpr _OuterIter&
-	  operator++()
-	  {
-	    const auto __end = ranges::end(_M_parent->_M_base);
-	    if (_M_current == __end)
-	      return *this;
-	    const auto [__pbegin, __pend] = subrange{_M_parent->_M_pattern};
-	    if (__pbegin == __pend)
-	      ++_M_current;
-	    else
-	      do
-		{
-		  auto [__b, __p]
-		    = __detail::mismatch(std::move(_M_current), __end,
-					 __pbegin, __pend);
-		  _M_current = std::move(__b);
-		  if (__p == __pend)
-		    break;
-		} while (++_M_current != __end);
-	    return *this;
-	  }
-
-	  constexpr decltype(auto)
-	  operator++(int)
-	  {
-	    if constexpr (forward_range<_Base>)
-	      {
-		auto __tmp = *this;
-		++*this;
-		return __tmp;
-	      }
-	    else
-	      ++*this;
-	  }
-
-	  friend constexpr bool
-	  operator==(const _OuterIter& __x, const _OuterIter& __y)
-	    requires forward_range<_Base>
-	  { return __x._M_current == __y._M_current; }
-
-	  friend constexpr bool
-	  operator==(const _OuterIter& __x, default_sentinel_t)
-	  { return __x.__at_end(); };
-
-	  friend _InnerIter<_Const>;
-	};
-
-      template<bool _Const>
-	struct _InnerIter
-	{
-	private:
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  constexpr bool
-	  __at_end() const
-	  {
-	    auto [__pcur, __pend] = subrange{_M_i._M_parent->_M_pattern};
-	    auto __end = ranges::end(_M_i._M_parent->_M_base);
-	    if constexpr (__detail::__tiny_range<_Pattern>)
-	      {
-		const auto& __cur = _M_i.__current();
-		if (__cur == __end)
-		  return true;
-		if (__pcur == __pend)
-		  return _M_incremented;
-		return *__cur == *__pcur;
-	      }
-	    else
-	      {
-		auto __cur = _M_i.__current();
-		if (__cur == __end)
-		  return true;
-		if (__pcur == __pend)
-		  return _M_incremented;
-		do
-		  {
-		    if (*__cur != *__pcur)
-		      return false;
-		    if (++__pcur == __pend)
-		      return true;
-		  } while (++__cur != __end);
-		return false;
-	      }
-	  }
-
-	  static constexpr auto
-	  _S_iter_cat()
-	  {
-	    using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;
-	    if constexpr (derived_from<_Cat, forward_iterator_tag>)
-	      return forward_iterator_tag{};
-	    else
-	      return _Cat{};
-	  }
-
-	  static constexpr decltype(auto)
-	  __iter_move(const _InnerIter& __i = {})
-	  noexcept(noexcept(ranges::iter_move(__i._M_i.__current())))
-	  { return ranges::iter_move(__i._M_i.__current()); }
-
-	  static constexpr void
-	  __iter_swap(const _InnerIter& __x = {}, const _InnerIter& __y = {})
-	    noexcept(noexcept(ranges::iter_swap(__x._M_i.__current(),
-						__y._M_i.__current())))
-	  { ranges::iter_swap(__x._M_i.__current(), __y._M_i.__current()); }
-
-	  _OuterIter<_Const> _M_i = _OuterIter<_Const>();
-	  bool _M_incremented = false;
-
-	public:
-	  using iterator_concept = typename _OuterIter<_Const>::iterator_concept;
-	  using iterator_category = decltype(_S_iter_cat());
-	  using value_type = range_value_t<_Base>;
-	  using difference_type = range_difference_t<_Base>;
-
-	  _InnerIter() = default;
-
-	  constexpr explicit
-	  _InnerIter(_OuterIter<_Const> __i)
-	    : _M_i(std::move(__i))
-	  { }
-
-	  constexpr decltype(auto)
-	  operator*() const
-	  { return *_M_i._M_current; }
-
-	  constexpr _InnerIter&
-	  operator++()
-	  {
-	    _M_incremented = true;
-	    if constexpr (!forward_range<_Base>)
-	      if constexpr (_Pattern::size() == 0)
-		return *this;
-	    ++_M_i.__current();
-	    return *this;
-	  }
-
-	  constexpr decltype(auto)
-	  operator++(int)
-	  {
-	    if constexpr (forward_range<_Vp>)
-	      {
-		auto __tmp = *this;
-		++*this;
-		return __tmp;
-	      }
-	    else
-	      ++*this;
-	  }
-
-	  friend constexpr bool
-	  operator==(const _InnerIter& __x, const _InnerIter& __y)
-	    requires forward_range<_Base>
-	  { return __x._M_i.__current() == __y._M_i.__current(); }
-
-	  friend constexpr bool
-	  operator==(const _InnerIter& __x, default_sentinel_t)
-	  { return __x.__at_end(); }
-
-	  friend constexpr decltype(auto)
-	  iter_move(const _InnerIter& __i) noexcept(noexcept(__iter_move()))
-	  { return __iter_move(__i); }
-
-	  friend constexpr void
-	  iter_swap(const _InnerIter& __x, const _InnerIter& __y)
-	    noexcept(noexcept(__iter_swap()))
-	    requires indirectly_swappable<iterator_t<_Base>>
-	  { __iter_swap(__x, __y); }
-	};
-
-      _Vp _M_base = _Vp();
-      _Pattern _M_pattern = _Pattern();
-
-      // XXX: _M_current is "present only if !forward_range<V>"
-      [[no_unique_address]]
-	conditional_t<!forward_range<_Vp>,
-		      iterator_t<_Vp>, __detail::_Empty> _M_current;
-
-
-    public:
-      split_view() = default;
-
-      constexpr
-      split_view(_Vp __base, _Pattern __pattern)
-	: _M_base(std::move(__base)), _M_pattern(std::move(__pattern))
-      { }
-
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range, forward_range _Pred>
-	requires constructible_from<_Vp, all_view<_Range>>
-	  && constructible_from<_Pattern, all_view<_Pred>>
-	constexpr
-	split_view(_Range&& __r, _Pred&& __p)
-	  : _M_base(views::all(std::forward<_Range>(__r))),
-	    _M_pattern(views::all(std::forward<_Pred>(__p)))
-      { }
-      */
-
-      template<input_range _Range>
-	requires constructible_from<_Vp, all_view<_Range>>
-	  && constructible_from<_Pattern, single_view<range_value_t<_Range>>>
-	constexpr
-	split_view(_Range&& __r, range_value_t<_Range> __e)
-	  : _M_base(views::all(std::forward<_Range>(__r))),
-	    _M_pattern(std::move(__e))
-	{ }
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr auto
-      begin()
-      {
-	if constexpr (forward_range<_Vp>)
-	  return _OuterIter<__detail::__simple_view<_Vp>>{*this,
-							ranges::begin(_M_base)};
-	else
-	  {
-	    _M_current = ranges::begin(_M_base);
-	    return _OuterIter<false>{*this};
-	  }
-      }
-
-      constexpr auto
-      begin() const requires forward_range<_Vp> && forward_range<const _Vp>
-      {
-	return _OuterIter<true>{*this, ranges::begin(_M_base)};
-      }
-
-      constexpr auto
-      end() requires forward_range<_Vp> && common_range<_Vp>
-      {
-	return _OuterIter<__detail::__simple_view<_Vp>>{*this, ranges::end(_M_base)};
-      }
-
-      constexpr auto
-      end() const
-      {
-	if constexpr (forward_range<_Vp>
-		      && forward_range<const _Vp>
-		      && common_range<const _Vp>)
-	  return _OuterIter<true>{*this, ranges::end(_M_base)};
-	else
-	  return default_sentinel;
-      }
-    };
-
-  template<typename _Range, typename _Pred>
-    split_view(_Range&&, _Pred&&)
-      -> split_view<all_view<_Range>, all_view<_Pred>>;
-
-  template<input_range _Range>
-    split_view(_Range&&, range_value_t<_Range>)
-      -> split_view<all_view<_Range>, single_view<range_value_t<_Range>>>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptor split
-      = [] <viewable_range _Range, typename _Fp> (_Range&& __r, _Fp&& __f)
-      {
-	return split_view{std::forward<_Range>(__r), std::forward<_Fp>(__f)};
-      };
-  } // namespace views
-
-  namespace views
-  {
-    struct _Counted
-    {
-      template<input_or_output_iterator _Iter>
-      constexpr auto
-      operator()(_Iter __i, iter_difference_t<_Iter> __n) const
-      {
-	if constexpr (random_access_iterator<_Iter>)
-	  return subrange{__i, __i + __n};
-	else
-	  return subrange{counted_iterator{std::move(__i), __n},
-			  default_sentinel};
-      }
-    };
-
-    inline constexpr _Counted counted{};
-  } // namespace views
-
-  template<view _Vp>
-    requires (!common_range<_Vp>) && copyable<iterator_t<_Vp>>
-    class common_view : public view_interface<common_view<_Vp>>
-    {
-    private:
-      _Vp _M_base = _Vp();
-
-    public:
-      common_view() = default;
-
-      constexpr explicit
-      common_view(_Vp __r)
-	: _M_base(std::move(__r))
-      { }
-
-      /* XXX: P3280 doesn't remove this constructor, but I think it should?
-      template<viewable_range _Range>
-	requires (!common_range<_Range>) && constructible_from<_Vp, all_view<_Range>>
-	constexpr explicit
-	common_view(_Range&& __r)
-	  : _M_base(views::all(std::forward<_Range>(__r)))
-	{ }
-	*/
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr auto
-      begin()
-      {
-	if constexpr (random_access_range<_Vp> && sized_range<_Vp>)
-	  return ranges::begin(_M_base);
-	else
-	  return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>
-		  (ranges::begin(_M_base));
-      }
-
-      constexpr auto
-      begin() const requires range<const _Vp>
-      {
-	if constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)
-	  return ranges::begin(_M_base);
-	else
-	  return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>
-		  (ranges::begin(_M_base));
-      }
-
-      constexpr auto
-      end()
-      {
-	if constexpr (random_access_range<_Vp> && sized_range<_Vp>)
-	  return ranges::begin(_M_base) + ranges::size(_M_base);
-	else
-	  return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>
-		  (ranges::end(_M_base));
-      }
-
-      constexpr auto
-      end() const requires range<const _Vp>
-      {
-	if constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)
-	  return ranges::begin(_M_base) + ranges::size(_M_base);
-	else
-	  return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>
-		  (ranges::end(_M_base));
-      }
-
-      constexpr auto
-      size() requires sized_range<_Vp>
-      { return ranges::size(_M_base); }
-
-      constexpr auto
-      size() const requires sized_range<const _Vp>
-      { return ranges::size(_M_base); }
-    };
-
-  template<typename _Range>
-    common_view(_Range&&) -> common_view<all_view<_Range>>;
-
-  namespace views
-  {
-    inline constexpr __adaptor::_RangeAdaptorClosure common
-      = [] <viewable_range _Range> (_Range&& __r)
-      {
-	if constexpr (common_range<_Range>
-		      && requires { views::all(std::forward<_Range>(__r)); })
-	  return views::all(std::forward<_Range>(__r));
-	else
-	  return common_view{std::forward<_Range>(__r)};
-      };
-
-  } // namespace views
-
-  template<view _Vp>
-    requires bidirectional_range<_Vp>
-    class reverse_view : public view_interface<reverse_view<_Vp>>
-    {
-    private:
-      _Vp _M_base = _Vp();
-
-    public:
-      reverse_view() = default;
-
-      constexpr explicit
-      reverse_view(_Vp __r)
-	: _M_base(std::move(__r))
-	{ }
-
-      /* XXX: P3280 removes this constructor
-      template<viewable_range _Range>
-	requires bidirectional_range<_Range> && constructible_from<_Vp, all_view<_Range>>
-	constexpr explicit
-	reverse_view(_Range&& __r)
-	  : _M_base(views::all(std::forward<_Range>(__r)))
-	{ }
-	*/
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr reverse_iterator<iterator_t<_Vp>>
-      begin()
-      {
-	// XXX: we need to cache the result here as per [range.reverse.view]
-	return make_reverse_iterator(ranges::next(ranges::begin(_M_base),
-						  ranges::end(_M_base)));
-      }
-
-      constexpr auto
-      begin() requires common_range<_Vp>
-      { return make_reverse_iterator(ranges::end(_M_base)); }
-
-      constexpr auto
-      begin() const requires common_range<const _Vp>
-      { return make_reverse_iterator(ranges::end(_M_base)); }
-
-      constexpr reverse_iterator<iterator_t<_Vp>>
-      end()
-      { return make_reverse_iterator(ranges::begin(_M_base)); }
-
-      constexpr auto
-      end() const requires common_range<const _Vp>
-      { return make_reverse_iterator(ranges::begin(_M_base)); }
-
-      constexpr auto
-      size() requires sized_range<_Vp>
-      { return ranges::size(_M_base); }
-
-      constexpr auto
-      size() const requires sized_range<const _Vp>
-      { return ranges::size(_M_base); }
-    };
-
-  template<typename _Range>
-    reverse_view(_Range&&) -> reverse_view<all_view<_Range>>;
-
-  namespace views
-  {
-    namespace __detail
-    {
-      template<typename>
-	inline constexpr bool __is_reversible_subrange = false;
-
-      template<typename _Iter, subrange_kind _Kind>
-	inline constexpr bool
-	  __is_reversible_subrange<subrange<reverse_iterator<_Iter>,
-					    reverse_iterator<_Iter>,
-					    _Kind>> = true;
-
-      template<typename>
-	inline constexpr bool __is_reverse_view = false;
-
-      template<typename _Vp>
-	inline constexpr bool __is_reverse_view<reverse_view<_Vp>> = true;
-    }
-
-    inline constexpr __adaptor::_RangeAdaptorClosure reverse
-      = [] <viewable_range _Range> (_Range&& __r)
-      {
-	using _Tp = remove_cvref_t<_Range>;
-	if constexpr (__detail::__is_reverse_view<_Tp>)
-	  return std::forward<_Range>(__r).base();
-	else if constexpr (__detail::__is_reversible_subrange<_Tp>)
-	  {
-	    using _Iter = decltype(ranges::begin(__r).base());
-	    if constexpr (sized_range<_Tp>)
-	      return subrange<_Iter, _Iter, subrange_kind::sized>
-		      (__r.end().base(), __r.begin().base(), __r.size());
-	    else
-	      return subrange<_Iter, _Iter, subrange_kind::unsized>
-		      (__r.end().base(), __r.begin().base());
-	  }
-	else
-	  return reverse_view{std::forward<_Range>(__r)};
-      };
-  } // namespace views
-
-  namespace __detail
-  {
-    template<typename _Tp, size_t _Nm>
-    concept __has_tuple_element = requires(_Tp __t)
-      {
-	typename tuple_size<_Tp>::type;
-	requires _Nm < tuple_size_v<_Tp>;
-	typename tuple_element_t<_Nm, _Tp>;
-	// XXX: we applied P3323 here
-	{ std::get<_Nm>(__t) }
-	  -> convertible_to<const tuple_element_t<_Nm, _Tp>&>;
-      };
-  }
-
-  template<input_range _Vp, size_t _Nm>
-    requires view<_Vp>
-      && __detail::__has_tuple_element<range_value_t<_Vp>, _Nm>
-      && __detail::__has_tuple_element<remove_reference_t<range_reference_t<_Vp>>,
-				       _Nm>
-    class elements_view : public view_interface<elements_view<_Vp, _Nm>>
-    {
-    public:
-      elements_view() = default;
-
-      constexpr explicit
-      elements_view(_Vp base)
-	: _M_base(std::move(base))
-      { }
-
-      constexpr _Vp
-      base() const& requires copy_constructible<_Vp>
-      { return _M_base; }
-
-      constexpr _Vp
-      base() &&
-      { return std::move(_M_base); }
-
-      constexpr auto
-      begin() requires (!__detail::__simple_view<_Vp>)
-      { return _Iterator<false>(ranges::begin(_M_base)); }
-
-      constexpr auto
-      begin() const requires __detail::__simple_view<_Vp>
-      { return _Iterator<true>(ranges::begin(_M_base)); }
-
-      constexpr auto
-      end() requires (!__detail::__simple_view<_Vp>)
-      { return ranges::end(_M_base); }
-
-      constexpr auto
-      end() const requires __detail::__simple_view<_Vp>
-      { return ranges::end(_M_base); }
-
-      constexpr auto
-      size() requires sized_range<_Vp>
-      { return ranges::size(_M_base); }
-
-      constexpr auto
-      size() const requires sized_range<const _Vp>
-      { return ranges::size(_M_base); }
-
-    private:
-      template<bool _Const>
-	struct _Iterator
-	{
-	  using _Base = conditional_t<_Const, const _Vp, _Vp>;
-
-	  iterator_t<_Base> _M_current;
-
-	  friend _Iterator<!_Const>;
-
-	public:
-	  using iterator_category
-	    = typename iterator_traits<iterator_t<_Base>>::iterator_category;
-	  using value_type
-	    = remove_cvref_t<tuple_element_t<_Nm, range_value_t<_Base>>>;
-	  using difference_type = range_difference_t<_Base>;
-
-	  _Iterator() = default;
-
-	  constexpr explicit
-	  _Iterator(iterator_t<_Base> current)
-	    : _M_current(std::move(current))
-	  { }
-
-	  constexpr
-	  _Iterator(_Iterator<!_Const> i)
-	    requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
-	    : _M_current(std::move(i._M_current))
-	  { }
-
-	  constexpr iterator_t<_Base>
-	  base() const&
-	    requires copyable<iterator_t<_Base>>
-	  { return _M_current; }
-
-	  constexpr iterator_t<_Base>
-	  base() &&
-	  { return std::move(_M_current); }
-
-	  constexpr decltype(auto)
-	    operator*() const
-	  { return std::get<_Nm>(*_M_current); }
-
-	  constexpr _Iterator&
-	  operator++()
-	  {
-	    ++_M_current;
-	    return *this;
-	  }
-
-	  constexpr void
-	  operator++(int) requires (!forward_range<_Base>)
-	  { ++_M_current; }
-
-	  constexpr _Iterator
-	  operator++(int) requires forward_range<_Base>
-	  {
-	    auto __tmp = *this;
-	    ++_M_current;
-	    return __tmp;
-	  }
-
-	  constexpr _Iterator&
-	  operator--() requires bidirectional_range<_Base>
-	  {
-	    --_M_current;
-	    return *this;
-	  }
-
-	  constexpr _Iterator
-	  operator--(int) requires bidirectional_range<_Base>
-	  {
-	    auto __tmp = *this;
-	    --_M_current;
-	    return __tmp;
-	  }
-
-	  constexpr _Iterator&
-	  operator+=(difference_type __n)
-	    requires random_access_range<_Base>
-	  {
-	    _M_current += __n;
-	    return *this;
-	  }
-
-	  constexpr _Iterator&
-	  operator-=(difference_type __n)
-	    requires random_access_range<_Base>
-	  {
-	    _M_current -= __n;
-	    return *this;
-	  }
-
-	  constexpr decltype(auto)
-	  operator[](difference_type __n) const
-	    requires random_access_range<_Base>
-	  { return std::get<_Nm>(*(_M_current + __n)); }
-
-	  friend constexpr bool
-	  operator==(const _Iterator& __x, const _Iterator& __y)
-	    requires equality_comparable<iterator_t<_Base>>
-	  { return __x._M_current == __y._M_current; }
-
-	  friend constexpr bool
-	  operator==(const _Iterator& __x, const sentinel_t<_Base>& __y)
-	  { return __x._M_current == __y; }
-
-	  friend constexpr bool
-	  operator<(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return __x._M_current < __y._M_current; }
-
-	  friend constexpr bool
-	  operator>(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return __y._M_current < __x._M_current; }
-
-	  friend constexpr bool
-	  operator<=(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return !(__y._M_current > __x._M_current); }
-
-	  friend constexpr bool
-	  operator>=(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return !(__x._M_current > __y._M_current); }
-
-#ifdef __cpp_lib_three_way_comparison
-	  friend constexpr auto
-	  operator<=>(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	      && three_way_comparable<iterator_t<_Base>>
-	  { return __x._M_current <=> __y._M_current; }
-#endif
-
-	  friend constexpr _Iterator
-	  operator+(const _Iterator& __x, difference_type __y)
-	    requires random_access_range<_Base>
-	  { return _Iterator{__x} += __y; }
-
-	  friend constexpr _Iterator
-	  operator+(difference_type __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return __y + __x; }
-
-	  friend constexpr _Iterator
-	  operator-(const _Iterator& __x, difference_type __y)
-	    requires random_access_range<_Base>
-	  { return _Iterator{__x} -= __y; }
-
-	  friend constexpr difference_type
-	  operator-(const _Iterator& __x, const _Iterator& __y)
-	    requires random_access_range<_Base>
-	  { return __x._M_current - __y._M_current; }
-
-	  friend constexpr difference_type
-	  operator-(const _Iterator<_Const>& __x, const sentinel_t<_Base>& __y)
-	    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
-	  { return __x._M_current - __y; }
-
-	  friend constexpr difference_type
-	  operator-(const sentinel_t<_Base>& __x, const _Iterator<_Const>& __y)
-	    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
-	  { return -(__y - __x); }
-	};
-
-      _Vp _M_base = _Vp();
-    };
-
-  template<typename _Range>
-    using keys_view = elements_view<all_view<_Range>, 0>;
-
-  template<typename _Range>
-    using values_view = elements_view<all_view<_Range>, 1>;
-
-  namespace views
-  {
-    template<size_t _Nm>
-    inline constexpr __adaptor::_RangeAdaptorClosure elements
-      = [] <viewable_range _Range> (_Range&& __r)
-      {
-	return elements_view<all_view<_Range>, _Nm>{std::forward<_Range>(__r)};
-      };
-
-    inline constexpr __adaptor::_RangeAdaptorClosure keys = elements<0>;
-    inline constexpr __adaptor::_RangeAdaptorClosure values = elements<1>;
-  } // namespace views
-
 } // namespace ranges
-
-  namespace views = ranges::views;
-
-  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
-    struct tuple_size<ranges::subrange<_Iter, _Sent, _Kind>>
-    : integral_constant<size_t, 2>
-    { };
-
-  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
-    struct tuple_element<0, ranges::subrange<_Iter, _Sent, _Kind>>
-    { using type = _Iter; };
-
-  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
-    struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>>
-    { using type = _Sent; };
-
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 #endif // library concepts
diff -urN gcc-10-20200216/libstdc++-v3/include/std/string gcc-10-20200202/libstdc++-v3/include/std/string
--- gcc-10-20200216/libstdc++-v3/include/std/string	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/string	2020-02-02 23:32:19.000000000 +0100
@@ -118,7 +118,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 202002L
+#define __cpp_lib_erase_if 201900L
 
   template<typename _CharT, typename _Traits, typename _Alloc,
 	   typename _Predicate>
diff -urN gcc-10-20200216/libstdc++-v3/include/std/vector gcc-10-20200202/libstdc++-v3/include/std/vector
--- gcc-10-20200216/libstdc++-v3/include/std/vector	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/vector	2020-02-02 23:32:19.000000000 +0100
@@ -101,7 +101,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 202002L
+#define __cpp_lib_erase_if 201900L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename vector<_Tp, _Alloc>::size_type
diff -urN gcc-10-20200216/libstdc++-v3/include/std/version gcc-10-20200202/libstdc++-v3/include/std/version
--- gcc-10-20200216/libstdc++-v3/include/std/version	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/include/std/version	2020-02-02 23:32:19.000000000 +0100
@@ -184,7 +184,7 @@
 #define __cpp_lib_constexpr_complex 201711L
 #define __cpp_lib_constexpr_dynamic_alloc 201907L
 #define __cpp_lib_constexpr_invoke 201907L
-#define __cpp_lib_erase_if 202002L
+#define __cpp_lib_erase_if 201900L
 #define __cpp_lib_interpolate 201902L
 #ifdef _GLIBCXX_HAS_GTHREADS
 # define __cpp_lib_jthread 201907L
diff -urN gcc-10-20200216/libstdc++-v3/libsupc++/compare gcc-10-20200202/libstdc++-v3/libsupc++/compare
--- gcc-10-20200216/libstdc++-v3/libsupc++/compare	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/libsupc++/compare	2020-02-02 23:32:19.000000000 +0100
@@ -48,11 +48,9 @@
 
   namespace __cmp_cat
   {
-    using type = signed char;
+    enum class _Ord { equivalent = 0, less = -1, greater = 1 };
 
-    enum class _Ord : type { equivalent = 0, less = -1, greater = 1 };
-
-    enum class _Ncmp : type { _Unordered = 2 };
+    enum class _Ncmp { _Unordered = -127 };
 
     struct __unspec
     {
@@ -62,22 +60,19 @@
 
   class partial_ordering
   {
-    // less=0xff, equiv=0x00, greater=0x01, unordered=0x02
-    __cmp_cat::type _M_value;
+    int _M_value;
+    bool _M_is_ordered;
 
     constexpr explicit
     partial_ordering(__cmp_cat::_Ord __v) noexcept
-    : _M_value(__cmp_cat::type(__v))
+    : _M_value(int(__v)), _M_is_ordered(true)
     { }
 
     constexpr explicit
     partial_ordering(__cmp_cat::_Ncmp __v) noexcept
-    : _M_value(__cmp_cat::type(__v))
+    : _M_value(int(__v)), _M_is_ordered(false)
     { }
 
-    friend class weak_ordering;
-    friend class strong_ordering;
-
   public:
     // valid values
     static const partial_ordering less;
@@ -88,42 +83,42 @@
     // comparisons
     friend constexpr bool
     operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept
-    { return __v._M_value == 0; }
+    { return __v._M_is_ordered && __v._M_value == 0; }
 
     friend constexpr bool
     operator==(partial_ordering, partial_ordering) noexcept = default;
 
     friend constexpr bool
     operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept
-    { return __v._M_value == -1; }
+    { return __v._M_is_ordered && __v._M_value < 0; }
 
     friend constexpr bool
     operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept
-    { return __v._M_value == 1; }
+    { return __v._M_is_ordered && __v._M_value > 0; }
 
     friend constexpr bool
     operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept
-    { return __v._M_value <= 0; }
+    { return __v._M_is_ordered && __v._M_value <= 0; }
 
     friend constexpr bool
     operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept
-    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }
+    { return __v._M_is_ordered && __v._M_value >= 0; }
 
     friend constexpr bool
     operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept
-    { return __v._M_value == 1; }
+    { return __v._M_is_ordered && 0 < __v._M_value; }
 
     friend constexpr bool
     operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept
-    { return __v._M_value == -1; }
+    { return __v._M_is_ordered && 0 > __v._M_value; }
 
     friend constexpr bool
     operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept
-    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }
+    { return __v._M_is_ordered && 0 <= __v._M_value; }
 
     friend constexpr bool
     operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept
-    { return 0 >= __v._M_value; }
+    { return __v._M_is_ordered && 0 >= __v._M_value; }
 
     friend constexpr partial_ordering
     operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept
@@ -132,8 +127,10 @@
     friend constexpr partial_ordering
     operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept
     {
-      if (__v._M_value & 1)
-	return partial_ordering(__cmp_cat::_Ord(-__v._M_value));
+      if (__v < 0)
+	return  partial_ordering::greater;
+      else if (__v > 0)
+	return partial_ordering::less;
       else
 	return __v;
     }
@@ -154,14 +151,12 @@
 
   class weak_ordering
   {
-    __cmp_cat::type _M_value;
+    int _M_value;
 
     constexpr explicit
-    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))
+    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(int(__v))
     { }
 
-    friend class strong_ordering;
-
   public:
     // valid values
     static const weak_ordering less;
@@ -169,7 +164,14 @@
     static const weak_ordering greater;
 
     constexpr operator partial_ordering() const noexcept
-    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }
+    {
+      if (_M_value == 0)
+	return partial_ordering::equivalent;
+      else if (_M_value < 0)
+	return partial_ordering::less;
+      else
+	return partial_ordering::greater;
+    }
 
     // comparisons
     friend constexpr bool
@@ -217,7 +219,14 @@
 
     friend constexpr weak_ordering
     operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept
-    { return weak_ordering(__cmp_cat::_Ord(-__v._M_value)); }
+    {
+      if (__v < 0)
+	return  weak_ordering::greater;
+      else if (__v > 0)
+	return weak_ordering::less;
+      else
+	return __v;
+    }
   };
 
   // valid values' definitions
@@ -232,11 +241,11 @@
 
   class strong_ordering
   {
-    __cmp_cat::type _M_value;
+    int _M_value;
 
     constexpr explicit
     strong_ordering(__cmp_cat::_Ord __v) noexcept
-    : _M_value(__cmp_cat::type(__v))
+    : _M_value(int(__v))
     { }
 
   public:
@@ -247,10 +256,24 @@
     static const strong_ordering greater;
 
     constexpr operator partial_ordering() const noexcept
-    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }
+    {
+      if (_M_value == 0)
+	return partial_ordering::equivalent;
+      else if (_M_value < 0)
+	return partial_ordering::less;
+      else
+	return partial_ordering::greater;
+    }
 
     constexpr operator weak_ordering() const noexcept
-    { return weak_ordering(__cmp_cat::_Ord(_M_value)); }
+    {
+      if (_M_value == 0)
+	return weak_ordering::equivalent;
+      else if (_M_value < 0)
+	return weak_ordering::less;
+      else
+	return weak_ordering::greater;
+    }
 
     // comparisons
     friend constexpr bool
@@ -298,7 +321,14 @@
 
     friend constexpr strong_ordering
     operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept
-    { return strong_ordering(__cmp_cat::_Ord(-__v._M_value)); }
+    {
+      if (__v < 0)
+	return  strong_ordering::greater;
+      else if (__v > 0)
+	return strong_ordering::less;
+      else
+	return __v;
+    }
   };
 
   // valid values' definitions
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/18_support/comparisons/categories/partialord.cc gcc-10-20200202/libstdc++-v3/testsuite/18_support/comparisons/categories/partialord.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/18_support/comparisons/categories/partialord.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/18_support/comparisons/categories/partialord.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <compare>
-
-using std::partial_ordering;
-
-static_assert( partial_ordering::less == partial_ordering::less );
-static_assert( partial_ordering::less != partial_ordering::equivalent );
-static_assert( partial_ordering::less != partial_ordering::greater );
-static_assert( partial_ordering::less != partial_ordering::unordered );
-static_assert( partial_ordering::equivalent == partial_ordering::equivalent );
-static_assert( partial_ordering::equivalent != partial_ordering::greater );
-static_assert( partial_ordering::equivalent != partial_ordering::unordered );
-static_assert( partial_ordering::greater == partial_ordering::greater );
-static_assert( partial_ordering::greater != partial_ordering::unordered );
-static_assert( partial_ordering::unordered == partial_ordering::unordered );
-
-static_assert( ! (partial_ordering::less == 0)	);
-static_assert(    partial_ordering::less <  0	);
-static_assert( ! (partial_ordering::less >  0)	);
-static_assert(    partial_ordering::less <= 0	);
-static_assert( ! (partial_ordering::less >= 0)	);
-static_assert( ! (0 == partial_ordering::less)	);
-static_assert( ! (0 <  partial_ordering::less)	);
-static_assert(    0 >  partial_ordering::less	);
-static_assert( ! (0 <= partial_ordering::less)	);
-static_assert(    0 >= partial_ordering::less	);
-static_assert( (partial_ordering::less <=> 0) == partial_ordering::less );
-static_assert( (0 <=> partial_ordering::less) == partial_ordering::greater );
-
-static_assert(   (partial_ordering::equivalent == 0)	);
-static_assert( ! (partial_ordering::equivalent <  0)	);
-static_assert( ! (partial_ordering::equivalent >  0)	);
-static_assert(    partial_ordering::equivalent <= 0	);
-static_assert(    partial_ordering::equivalent >= 0	);
-static_assert(    0 == partial_ordering::equivalent	);
-static_assert( ! (0 <  partial_ordering::equivalent)	);
-static_assert( ! (0 >  partial_ordering::equivalent)	);
-static_assert(    0 <= partial_ordering::equivalent	);
-static_assert(    0 >= partial_ordering::equivalent	);
-static_assert( (partial_ordering::equivalent <=> 0) == partial_ordering::equivalent );
-static_assert( (0 <=> partial_ordering::equivalent) == partial_ordering::equivalent );
-
-static_assert( ! (partial_ordering::greater == 0)	);
-static_assert( ! (partial_ordering::greater <  0)	);
-static_assert(    partial_ordering::greater >  0	);
-static_assert( ! (partial_ordering::greater <= 0)	);
-static_assert(    partial_ordering::greater >= 0	);
-static_assert( ! (0 == partial_ordering::greater)	);
-static_assert(    0 <  partial_ordering::greater	);
-static_assert( ! (0 >  partial_ordering::greater)	);
-static_assert(    0 <= partial_ordering::greater	);
-static_assert( ! (0 >= partial_ordering::greater)	);
-static_assert( (partial_ordering::greater <=> 0) == partial_ordering::greater );
-static_assert( (0 <=> partial_ordering::greater) == partial_ordering::less );
-
-static_assert( ! (partial_ordering::unordered == 0)	);
-static_assert( ! (partial_ordering::unordered <  0)	);
-static_assert( ! (partial_ordering::unordered >  0)	);
-static_assert( ! (partial_ordering::unordered <= 0)	);
-static_assert( ! (partial_ordering::unordered >= 0)	);
-static_assert( ! (0 == partial_ordering::unordered)	);
-static_assert( ! (0 <  partial_ordering::unordered)	);
-static_assert( ! (0 >  partial_ordering::unordered)	);
-static_assert( ! (0 <= partial_ordering::unordered)	);
-static_assert( ! (0 >= partial_ordering::unordered)	);
-static_assert( (partial_ordering::unordered <=> 0) == partial_ordering::unordered );
-static_assert( (0 <=> partial_ordering::unordered) == partial_ordering::unordered );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/18_support/comparisons/categories/strongord.cc gcc-10-20200202/libstdc++-v3/testsuite/18_support/comparisons/categories/strongord.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/18_support/comparisons/categories/strongord.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/18_support/comparisons/categories/strongord.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <compare>
-
-using std::strong_ordering;
-
-static_assert( strong_ordering::less == strong_ordering::less );
-static_assert( strong_ordering::less != strong_ordering::equal );
-static_assert( strong_ordering::less != strong_ordering::equivalent );
-static_assert( strong_ordering::less != strong_ordering::greater );
-static_assert( strong_ordering::equivalent == strong_ordering::equivalent );
-static_assert( strong_ordering::equivalent == strong_ordering::equal );
-static_assert( strong_ordering::equivalent != strong_ordering::greater );
-static_assert( strong_ordering::equal == strong_ordering::equal );
-static_assert( strong_ordering::equal != strong_ordering::greater );
-static_assert( strong_ordering::greater == strong_ordering::greater );
-
-static_assert( ! (strong_ordering::less == 0)	);
-static_assert(    strong_ordering::less <  0	);
-static_assert( ! (strong_ordering::less >  0)	);
-static_assert(    strong_ordering::less <= 0	);
-static_assert( ! (strong_ordering::less >= 0)	);
-static_assert( ! (0 == strong_ordering::less)	);
-static_assert( ! (0 <  strong_ordering::less)	);
-static_assert(    0 >  strong_ordering::less	);
-static_assert( ! (0 <= strong_ordering::less)	);
-static_assert(    0 >= strong_ordering::less	);
-static_assert( (strong_ordering::less <=> 0) == strong_ordering::less );
-static_assert( (0 <=> strong_ordering::less) == strong_ordering::greater );
-
-static_assert(   (strong_ordering::equal == 0)	);
-static_assert( ! (strong_ordering::equal <  0)	);
-static_assert( ! (strong_ordering::equal >  0)	);
-static_assert(    strong_ordering::equal <= 0	);
-static_assert(    strong_ordering::equal >= 0	);
-static_assert(    0 == strong_ordering::equal	);
-static_assert( ! (0 <  strong_ordering::equal)	);
-static_assert( ! (0 >  strong_ordering::equal)	);
-static_assert(    0 <= strong_ordering::equal	);
-static_assert(    0 >= strong_ordering::equal	);
-static_assert( (strong_ordering::equal <=> 0) == strong_ordering::equal );
-static_assert( (0 <=> strong_ordering::equal) == strong_ordering::equal );
-
-static_assert(   (strong_ordering::equivalent == 0)	);
-static_assert( ! (strong_ordering::equivalent <  0)	);
-static_assert( ! (strong_ordering::equivalent >  0)	);
-static_assert(    strong_ordering::equivalent <= 0	);
-static_assert(    strong_ordering::equivalent >= 0	);
-static_assert(    0 == strong_ordering::equivalent	);
-static_assert( ! (0 <  strong_ordering::equivalent)	);
-static_assert( ! (0 >  strong_ordering::equivalent)	);
-static_assert(    0 <= strong_ordering::equivalent	);
-static_assert(    0 >= strong_ordering::equivalent	);
-static_assert( (strong_ordering::equivalent <=> 0) == strong_ordering::equivalent );
-static_assert( (0 <=> strong_ordering::equivalent) == strong_ordering::equivalent );
-
-static_assert( ! (strong_ordering::greater == 0)	);
-static_assert( ! (strong_ordering::greater <  0)	);
-static_assert(    strong_ordering::greater >  0	);
-static_assert( ! (strong_ordering::greater <= 0)	);
-static_assert(    strong_ordering::greater >= 0	);
-static_assert( ! (0 == strong_ordering::greater)	);
-static_assert(    0 <  strong_ordering::greater	);
-static_assert( ! (0 >  strong_ordering::greater)	);
-static_assert(    0 <= strong_ordering::greater	);
-static_assert( ! (0 >= strong_ordering::greater)	);
-static_assert( (strong_ordering::greater <=> 0) == strong_ordering::greater );
-static_assert( (0 <=> strong_ordering::greater) == strong_ordering::less );
-
-// Conversions
-using std::partial_ordering;
-static_assert( partial_ordering(strong_ordering::less) == partial_ordering::less );
-static_assert( partial_ordering(strong_ordering::equal) == partial_ordering::equivalent );
-static_assert( partial_ordering(strong_ordering::equivalent) == partial_ordering::equivalent );
-static_assert( partial_ordering(strong_ordering::greater) == partial_ordering::greater );
-using std::weak_ordering;
-static_assert( weak_ordering(strong_ordering::less) == weak_ordering::less );
-static_assert( partial_ordering(strong_ordering::equal) == weak_ordering::equivalent );
-static_assert( partial_ordering(strong_ordering::equivalent) == weak_ordering::equivalent );
-static_assert( weak_ordering(strong_ordering::greater) == weak_ordering::greater );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/18_support/comparisons/categories/weakord.cc gcc-10-20200202/libstdc++-v3/testsuite/18_support/comparisons/categories/weakord.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/18_support/comparisons/categories/weakord.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/18_support/comparisons/categories/weakord.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <compare>
-
-using std::weak_ordering;
-
-static_assert( weak_ordering::less == weak_ordering::less );
-static_assert( weak_ordering::less != weak_ordering::equivalent );
-static_assert( weak_ordering::less != weak_ordering::greater );
-static_assert( weak_ordering::equivalent == weak_ordering::equivalent );
-static_assert( weak_ordering::equivalent != weak_ordering::greater );
-static_assert( weak_ordering::greater == weak_ordering::greater );
-
-static_assert( ! (weak_ordering::less == 0)	);
-static_assert(    weak_ordering::less <  0	);
-static_assert( ! (weak_ordering::less >  0)	);
-static_assert(    weak_ordering::less <= 0	);
-static_assert( ! (weak_ordering::less >= 0)	);
-static_assert( ! (0 == weak_ordering::less)	);
-static_assert( ! (0 <  weak_ordering::less)	);
-static_assert(    0 >  weak_ordering::less	);
-static_assert( ! (0 <= weak_ordering::less)	);
-static_assert(    0 >= weak_ordering::less	);
-static_assert( (weak_ordering::less <=> 0) == weak_ordering::less );
-static_assert( (0 <=> weak_ordering::less) == weak_ordering::greater );
-
-static_assert(   (weak_ordering::equivalent == 0)	);
-static_assert( ! (weak_ordering::equivalent <  0)	);
-static_assert( ! (weak_ordering::equivalent >  0)	);
-static_assert(    weak_ordering::equivalent <= 0	);
-static_assert(    weak_ordering::equivalent >= 0	);
-static_assert(    0 == weak_ordering::equivalent	);
-static_assert( ! (0 <  weak_ordering::equivalent)	);
-static_assert( ! (0 >  weak_ordering::equivalent)	);
-static_assert(    0 <= weak_ordering::equivalent	);
-static_assert(    0 >= weak_ordering::equivalent	);
-static_assert( (weak_ordering::equivalent <=> 0) == weak_ordering::equivalent );
-static_assert( (0 <=> weak_ordering::equivalent) == weak_ordering::equivalent );
-
-static_assert( ! (weak_ordering::greater == 0)	);
-static_assert( ! (weak_ordering::greater <  0)	);
-static_assert(    weak_ordering::greater >  0	);
-static_assert( ! (weak_ordering::greater <= 0)	);
-static_assert(    weak_ordering::greater >= 0	);
-static_assert( ! (0 == weak_ordering::greater)	);
-static_assert(    0 <  weak_ordering::greater	);
-static_assert( ! (0 >  weak_ordering::greater)	);
-static_assert(    0 <= weak_ordering::greater	);
-static_assert( ! (0 >= weak_ordering::greater)	);
-static_assert( (weak_ordering::greater <=> 0) == weak_ordering::greater );
-static_assert( (0 <=> weak_ordering::greater) == weak_ordering::less );
-
-// Conversions
-using std::partial_ordering;
-static_assert( partial_ordering(weak_ordering::less) == partial_ordering::less );
-static_assert( partial_ordering(weak_ordering::equivalent) == partial_ordering::equivalent );
-static_assert( partial_ordering(weak_ordering::greater) == partial_ordering::greater );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/equal_to.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/equal_to.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/equal_to.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/equal_to.cc	2020-02-02 23:32:19.000000000 +0100
@@ -69,15 +69,6 @@
   VERIFY( f(x, x) );
 }
 
-struct Y
-{
-  operator void*() const;
-  operator int() const;
-};
-
-// Y{} == Y{} is ambiguous so ranges::equal_to{}(Y{}, Y{}) should be invalid
-static_assert( !std::is_invocable_v<F&, Y, Y> );
-
 int
 main()
 {
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/less.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/less.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/less.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/function_objects/range.cmp/less.cc	2020-02-02 23:32:19.000000000 +0100
@@ -74,15 +74,6 @@
   VERIFY( ! f(x, x) );
 }
 
-struct Y
-{
-  operator void*() const;
-  operator int() const;
-};
-
-// Y{} == Y{} is ambiguous so ranges::less{}(Y{}, Y{}) should be invalid
-static_assert( !std::is_invocable_v<F&, Y, Y> );
-
 int
 main()
 {
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <cstring>
-#include <deque>
-#include <list>
-#include <memory>
-#include <span>
-#include <string>
-#include <vector>
-
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  X()
-  { ++count; }
-
-  ~X()
-  { --count; }
-
-  static inline int count = 0;
-};
-
-void
-test01()
-{
-  for (int k = 0; k < 3; k++)
-    {
-      constexpr int size = 1024;
-      auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);
-      std::span<X> rx((X *)buffer.get(), size);
-
-      ranges::uninitialized_default_construct(rx);
-      VERIFY( X::count == size );
-
-      auto i = rx.cbegin();
-      if (k == 0)
-	i = ranges::destroy(rx);
-      else if (k == 1)
-	i = ranges::destroy(rx.begin(), rx.end());
-      else if (k == 2)
-	i = ranges::destroy_n(rx.begin(), size);
-      else
-	__builtin_abort();
-
-      VERIFY( i == rx.cend() );
-      VERIFY( X::count == 0 );
-    }
-}
-
-int
-main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,166 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <cstring>
-#include <deque>
-#include <list>
-#include <memory>
-#include <span>
-#include <string>
-#include <vector>
-
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_input_range;
-using __gnu_test::test_forward_range;
-
-namespace ranges = std::ranges;
-
-template<typename T>
-void
-test01(const std::vector<T> &ix)
-{
-  static_assert(std::copy_constructible<T>);
-  static_assert(std::equality_comparable<T>);
-
-  for (int k = 0; k < 7; k++)
-    {
-      int size = ix.size();
-      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
-      std::span<T> rx((T *)buffer.get(), size);
-
-      ranges::uninitialized_copy_result res = {ix.cbegin(), rx.cbegin()};
-      if (k == 0)
-	res = ranges::uninitialized_copy(ix.begin(), ix.end(),
-					 rx.begin(), rx.end());
-      else if (k == 1)
-	res = ranges::uninitialized_copy(ix, rx);
-      else if (k == 2)
-	res = ranges::uninitialized_copy_n(ix.begin(), size,
-					   rx.begin(), rx.end());
-      else if (k == 3)
-	res = ranges::uninitialized_copy(ix.begin(), ix.end(),
-					 rx.cbegin(), rx.cend());
-      else if (k == 4)
-	res = ranges::uninitialized_copy(ix, std::as_const(rx));
-      else if (k == 5)
-	res = ranges::uninitialized_copy_n(ix.begin(), size,
-					   rx.cbegin(), rx.cend());
-      else if (k == 6)
-	res = ranges::uninitialized_copy_n(ix.begin(), size/2,
-					   rx.cbegin(), rx.cend());
-      else if (k == 7)
-	res = ranges::uninitialized_copy_n(ix.begin(), size,
-					   rx.cbegin(), rx.cbegin()+size/2);
-      else
-	__builtin_abort();
-
-      if (k == 6 || k == 7)
-	{
-	  VERIFY( ranges::distance(ix.cbegin(), res.in) == size/2 );
-	  VERIFY( ranges::distance(rx.cbegin(), res.out) == size/2 );
-	  VERIFY( ranges::equal(ix.begin(), ix.begin()+size/2,
-				rx.begin(), rx.begin()+size/2) );
-	  ranges::destroy(rx.begin(), rx.begin()+size/2);
-	}
-      else
-	{
-	  VERIFY( res.in == ix.cend() );
-	  VERIFY( res.out == rx.cend() );
-	  VERIFY( ranges::equal(ix, rx) );
-	  ranges::destroy(rx);
-	}
-    }
-}
-
-struct X
-{
-  static constexpr int limit = 67;
-  static inline int copy_construct_count = 0;
-  static inline int destruct_count = 0;
-
-  struct exception {};
-
-  bool live = false;
-
-  X()
-  { live = true; }
-
-  X& operator=(const X&) = delete;
-
-  X(const X&)
-  {
-    live = true;
-    if (copy_construct_count >= limit)
-      throw exception{};
-    copy_construct_count++;
-  }
-
-  ~X()
-  {
-    VERIFY( live );
-    live = false;
-    destruct_count++;
-  }
-};
-
-template<bool test_sized>
-void
-test02()
-{
-  constexpr int size = 100;
-  X x[size];
-  // FIXME: Should be test_input_range?
-  test_forward_range<X> ix(x);
-
-  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);
-  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);
-  try
-    {
-      X::copy_construct_count = 0;
-      X::destruct_count = 0;
-      if constexpr (test_sized)
-	ranges::uninitialized_copy_n(ix.begin(), size, rx.begin(), rx.end());
-      else
-	ranges::uninitialized_copy(ix, rx);
-      VERIFY( false && "exception not thrown" );
-    }
-  catch (const X::exception&)
-    {
-      VERIFY( X::copy_construct_count == X::limit );
-      VERIFY( X::destruct_count == X::limit );
-    }
-}
-
-int
-main()
-{
-  test01<char>({1,2,3,4,5});
-  test01<int>({1,2,3,4,5});
-  test01<long long>({1,2,3,4,5});
-  test01<float>({1.1,2.1,3.1,4.1});
-  test01<double>({1.1,2.1,3.1,4.1});
-  test01<std::vector<char>>({{'a','b'}, {'c','d'}, {'e','f'}});
-  test01<std::string>({"the", "quick", "brown", "fox"});
-
-  test02<false>();
-  test02<true>();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,147 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <cstring>
-#include <deque>
-#include <list>
-#include <memory>
-#include <span>
-#include <string>
-#include <vector>
-
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_forward_range;
-
-namespace ranges = std::ranges;
-
-template<typename T>
-void
-test01()
-{
-  static_assert(std::default_initializable<T>);
-  static_assert(std::equality_comparable<T>);
-
-  for (int k = 0; k < 6; k++)
-    {
-      constexpr int size = 1024;
-      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
-      std::span<T> rx((T *)buffer.get(), size);
-
-      T t;
-      if constexpr (std::is_fundamental_v<T>)
-	{
-	  std::memset(&t, 0xCC, sizeof(t));
-	  ranges::fill(rx, t);
-	}
-
-      auto i = rx.cbegin();
-      if (k == 0)
-	i = ranges::uninitialized_default_construct(rx.begin(), rx.end());
-      else if (k == 1)
-	i = ranges::uninitialized_default_construct(rx);
-      else if (k == 2)
-	i = ranges::uninitialized_default_construct_n(rx.begin(), 1024);
-      else if constexpr (std::is_fundamental_v<T>)
-	continue;
-      else if (k == 3)
-	i = ranges::uninitialized_default_construct(rx.cbegin(), rx.cend());
-      else if (k == 4)
-	i = ranges::uninitialized_default_construct(std::as_const(rx));
-      else if (k == 5)
-	i = ranges::uninitialized_default_construct_n(rx.cbegin(), 1024);
-      else
-	__builtin_abort();
-
-      VERIFY( i == rx.cend() );
-      VERIFY( ranges::find_if(rx, [&t](const T& v) { return t != v; }) == i );
-
-      ranges::destroy(rx);
-    }
-}
-
-struct X
-{
-  static constexpr int limit = 67;
-  static inline int construct_count = 0;
-  static inline int destruct_count = 0;
-
-  struct exception {};
-
-  bool live = false;
-
-  X()
-  {
-    if (construct_count >= limit)
-      throw exception{};
-    construct_count++;
-    live = true;
-  }
-
-  ~X()
-  {
-    VERIFY( live );
-    live = false;
-    destruct_count++;
-  }
-};
-
-template<bool test_sized>
-void
-test02()
-{
-  constexpr int size = 100;
-  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);
-  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);
-  try
-    {
-      X::construct_count = 0;
-      X::destruct_count = 0;
-      if constexpr (test_sized)
-	ranges::uninitialized_default_construct_n(rx.begin(), size);
-      else
-	ranges::uninitialized_default_construct(rx);
-      VERIFY( false && "exception not thrown" );
-    }
-  catch (const X::exception&)
-    {
-      VERIFY( X::construct_count == X::limit );
-      VERIFY( X::destruct_count == X::limit );
-    }
-}
-
-int
-main()
-{
-  test01<char>();
-  test01<int>();
-  test01<long long>();
-  test01<float>();
-  test01<double>();
-  test01<std::vector<char>>();
-  test01<std::string>();
-  test01<std::deque<double>>();
-  test01<std::list<std::vector<std::deque<double>>>>();
-  test01<std::unique_ptr<std::string>>();
-
-  test02<false>();
-  test02<true>();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,137 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <cstring>
-#include <deque>
-#include <list>
-#include <memory>
-#include <span>
-#include <string>
-#include <vector>
-
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_forward_range;
-
-namespace ranges = std::ranges;
-
-template<typename T>
-void
-test01(const T& value)
-{
-  static_assert(std::equality_comparable<T>);
-
-  for (int k = 0; k < 6; k++)
-    {
-      constexpr int size = 1024;
-      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
-      std::span<T> rx((T *)buffer.get(), size);
-
-      auto i = rx.cbegin();
-      if (k == 0)
-	i = ranges::uninitialized_fill(rx.begin(), rx.end(), value);
-      else if (k == 1)
-	i = ranges::uninitialized_fill(rx, value);
-      else if (k == 2)
-	i = ranges::uninitialized_fill_n(rx.begin(), 1024, value);
-      else if (k == 3)
-	i = ranges::uninitialized_fill(rx.cbegin(), rx.cend(), value);
-      else if (k == 4)
-	i = ranges::uninitialized_fill(std::as_const(rx), value);
-      else if (k == 5)
-	i = ranges::uninitialized_fill_n(rx.cbegin(), 1024, value);
-      else
-	__builtin_abort();
-
-      VERIFY( i == rx.cend() );
-      VERIFY( ranges::find_if(rx, [&value](const T& v) { return value != v; }) == i );
-
-      ranges::destroy(rx);
-    }
-}
-
-struct X
-{
-  static constexpr int limit = 67;
-  static inline int construct_count = 0;
-  static inline int destruct_count = 0;
-
-  struct exception {};
-
-  bool live = false;
-
-  X(int)
-  {
-    if (construct_count >= limit)
-      throw exception{};
-    construct_count++;
-    live = true;
-  }
-
-  ~X()
-  {
-    VERIFY( live );
-    live = false;
-    destruct_count++;
-  }
-};
-
-template<bool test_sized>
-void
-test02()
-{
-  constexpr int size = 100;
-  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);
-  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);
-  int value = 5;
-  try
-    {
-      X::construct_count = 0;
-      X::destruct_count = 0;
-      if constexpr (test_sized)
-	ranges::uninitialized_fill_n(rx.begin(), size, value);
-      else
-	ranges::uninitialized_fill(rx, value);
-      VERIFY( false && "exception not thrown" );
-    }
-  catch (const X::exception&)
-    {
-      VERIFY( X::construct_count == X::limit );
-      VERIFY( X::destruct_count == X::limit );
-    }
-}
-
-int
-main()
-{
-  test01<char>(5);
-  test01<int>(3);
-  test01<long long>(17);
-  test01<float>(2.18);
-  test01<double>(3.98);
-  test01<std::vector<char>>({'a', 'b', 'c', 'd'});
-  test01<std::string>("hello");
-  test01<std::deque<double>>({1.1,2.1,3.1});
-  test01<std::list<std::vector<std::deque<double>>>>({{{3.4},{1}},{{7.9}}});
-
-  test02<false>();
-  test02<true>();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,176 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <cstring>
-#include <deque>
-#include <list>
-#include <memory>
-#include <span>
-#include <string>
-#include <vector>
-
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_input_range;
-using __gnu_test::test_forward_range;
-
-namespace ranges = std::ranges;
-
-template<typename T>
-void
-test01(std::vector<T> ix)
-{
-  static_assert(std::move_constructible<T>);
-  static_assert(std::equality_comparable<T>);
-
-  const auto saved_ix = ix;
-
-  for (int k = 0; k < 7; k++)
-    {
-      ix = saved_ix;
-
-      int size = ix.size();
-      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
-      std::span<T> rx((T *)buffer.get(), size);
-
-      ranges::uninitialized_move_result res = {ix.cbegin(), rx.cbegin()};
-      if (k == 0)
-	res = ranges::uninitialized_move(ix.begin(), ix.end(),
-					 rx.begin(), rx.end());
-      else if (k == 1)
-	res = ranges::uninitialized_move(ix, rx);
-      else if (k == 2)
-	res = ranges::uninitialized_move_n(ix.begin(), size,
-					   rx.begin(), rx.end());
-      else if (k == 3)
-	res = ranges::uninitialized_move(ix.begin(), ix.end(),
-					 rx.cbegin(), rx.cend());
-      else if (k == 4)
-	res = ranges::uninitialized_move(ix, std::as_const(rx));
-      else if (k == 5)
-	res = ranges::uninitialized_move_n(ix.begin(), size,
-					   rx.cbegin(), rx.cend());
-      else if (k == 6)
-	res = ranges::uninitialized_move_n(ix.begin(), size/2,
-					   rx.cbegin(), rx.cend());
-      else if (k == 7)
-	res = ranges::uninitialized_move_n(ix.begin(), size,
-					   rx.cbegin(), rx.cbegin()+size/2);
-      else
-	__builtin_abort();
-
-      if (k == 6 || k == 7)
-	{
-	  VERIFY( ranges::distance(ix.cbegin(), res.in) == size/2 );
-	  VERIFY( ranges::distance(rx.cbegin(), res.out) == size/2 );
-	  VERIFY( ranges::equal(saved_ix.begin(), saved_ix.begin()+size/2,
-				rx.begin(), rx.begin()+size/2) );
-	  ranges::destroy(rx.begin(), rx.begin()+size/2);
-	}
-      else
-	{
-	  VERIFY( res.in == ix.cend() );
-	  VERIFY( res.out == rx.cend() );
-	  VERIFY( ranges::equal(saved_ix, rx) );
-	  ranges::destroy(rx);
-	}
-    }
-}
-
-struct X
-{
-  static constexpr int limit = 67;
-  static inline int move_construct_count = 0;
-  static inline int destruct_count = 0;
-
-  struct exception {};
-
-  bool live = false;
-  bool moved_from = false;
-
-  X()
-  { live = true; moved_from = false; }
-
-  X& operator=(const X&) = delete;
-  X(const X&) = delete;
-
-  X&& operator=(X&&) = delete;
-
-  X(X&& other)
-  {
-    VERIFY( !other.moved_from );
-    other.moved_from = true;
-    live = true;
-    if (move_construct_count >= limit)
-      throw exception{};
-    move_construct_count++;
-  }
-
-  ~X()
-  {
-    VERIFY( live );
-    live = false;
-    destruct_count++;
-  }
-};
-
-template<bool test_sized>
-void
-test02()
-{
-  constexpr int size = 100;
-  X x[size];
-  // FIXME: Should be test_input_range?
-  test_forward_range<X> ix(x);
-
-  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);
-  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);
-  try
-    {
-      X::move_construct_count = 0;
-      X::destruct_count = 0;
-      if constexpr (test_sized)
-	ranges::uninitialized_move_n(ix.begin(), size, rx.begin(), rx.end());
-      else
-	ranges::uninitialized_move(ix, rx);
-      VERIFY( false && "exception not thrown" );
-    }
-  catch (const X::exception&)
-    {
-      VERIFY( X::move_construct_count == X::limit );
-      VERIFY( X::destruct_count == X::limit );
-    }
-}
-
-int
-main()
-{
-  test01<char>({1,2,3,4,5});
-  test01<int>({1,2,3,4,5});
-  test01<long long>({1,2,3,4,5});
-  test01<float>({1.1,2.1,3.1,4.1});
-  test01<double>({1.1,2.1,3.1,4.1});
-  test01<std::vector<char>>({{'a','b'}, {'c','d'}, {'e','f'}});
-  test01<std::string>({"the", "quick", "brown", "fox"});
-
-  test02<false>();
-  test02<true>();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,140 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <cstring>
-#include <deque>
-#include <list>
-#include <memory>
-#include <span>
-#include <string>
-#include <vector>
-
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_forward_range;
-
-namespace ranges = std::ranges;
-
-template<typename T>
-void
-test01()
-{
-  static_assert(std::default_initializable<T>);
-  static_assert(std::equality_comparable<T>);
-
-  for (int k = 0; k < 6; k++)
-    {
-      constexpr int size = 1024;
-      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
-      std::span<T> rx((T *)buffer.get(), size);
-
-      T t{};
-
-      auto i = rx.cbegin();
-      if (k == 0)
-	i = ranges::uninitialized_value_construct(rx.begin(), rx.end());
-      else if (k == 1)
-	i = ranges::uninitialized_value_construct(rx);
-      else if (k == 2)
-	i = ranges::uninitialized_value_construct_n(rx.begin(), 1024);
-      else if (k == 3)
-	i = ranges::uninitialized_value_construct(rx.cbegin(), rx.cend());
-      else if (k == 4)
-	i = ranges::uninitialized_value_construct(std::as_const(rx));
-      else if (k == 5)
-	i = ranges::uninitialized_value_construct_n(rx.cbegin(), 1024);
-      else
-	__builtin_abort();
-
-      VERIFY( i == rx.cend() );
-      VERIFY( ranges::find_if(rx, [&t](const T& v) { return t != v; }) == i );
-
-      ranges::destroy(rx);
-    }
-}
-
-struct X
-{
-  static constexpr int limit = 67;
-  static inline int construct_count = 0;
-  static inline int destruct_count = 0;
-
-  struct exception {};
-
-  bool live = false;
-
-  X()
-  {
-    if (construct_count >= limit)
-      throw exception{};
-    construct_count++;
-    live = true;
-  }
-
-  ~X()
-  {
-    VERIFY( live );
-    live = false;
-    destruct_count++;
-  }
-};
-
-template<bool test_sized>
-void
-test02()
-{
-  constexpr int size = 100;
-  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);
-  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);
-  try
-    {
-      X::construct_count = 0;
-      X::destruct_count = 0;
-      if constexpr (test_sized)
-	ranges::uninitialized_value_construct_n(rx.begin(), size);
-      else
-	ranges::uninitialized_value_construct(rx);
-      VERIFY( false && "exception not thrown" );
-    }
-  catch (const X::exception&)
-    {
-      VERIFY( X::construct_count == X::limit );
-      VERIFY( X::destruct_count == X::limit );
-    }
-}
-
-int
-main()
-{
-  test01<char>();
-  test01<int>();
-  test01<long long>();
-  test01<float>();
-  test01<double>();
-  test01<std::vector<char>>();
-  test01<std::string>();
-  test01<std::deque<double>>();
-  test01<std::list<std::vector<std::deque<double>>>>();
-  test01<std::unique_ptr<std::string>>();
-
-  test02<false>();
-  test02<true>();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/93562.cc gcc-10-20200202/libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/93562.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/93562.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/93562.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-do run { target c++11 } }
-
-#include <memory>
-#include <testsuite_hooks.h>
-
-struct incomplete;
-
-// This function isn't called, we just need to check it compiles.
-void
-test01(std::unique_ptr<incomplete>& p1, std::unique_ptr<incomplete>& p2)
-{
-  // PR libstdc++/93562
-  p1.swap(p2);
-  swap(p1, p2);
-}
-
-// This function isn't called, we just need to check it compiles.
-void
-test02(std::unique_ptr<incomplete[]>& p1, std::unique_ptr<incomplete[]>& p2)
-{
-  // PR libstdc++/93562
-  p1.swap(p2);
-  swap(p1, p2);
-}
-
-namespace A
-{
-  struct Deleter
-  {
-    Deleter& operator=(const Deleter&) = delete;
-
-    void operator()(int* p) const noexcept { delete p; }
-
-    // found by ADL
-    friend void swap(Deleter& lhs, Deleter& rhs) noexcept
-    { std::swap(lhs.id, rhs.id); }
-
-    int id;
-  };
-
-  static_assert(!std::is_move_assignable<Deleter>::value, "not assignable");
-#if __cplusplus >= 201703L
-  static_assert(std::is_swappable_v<Deleter>, "but swappable");
-#endif
-} // namespace A
-
-void
-test03()
-{
-  std::unique_ptr<int, A::Deleter> p1(new int(1), { -1 });
-  std::unique_ptr<int, A::Deleter> p2(new int(2), { -2 });
-  int* const pi1 = p1.get();
-  int* const pi2 = p2.get();
-  // This type must swappable even though the deleter is not move-assignable:
-  swap(p1, p2);
-  VERIFY(p1.get() == pi2);
-  VERIFY(p1.get_deleter().id == -2);
-  VERIFY(p2.get() == pi1);
-  VERIFY(p2.get_deleter().id == -1);
-}
-
-void
-test04()
-{
-  std::unique_ptr<int[], A::Deleter> p1(new int[1]{1}, { -1 });
-  std::unique_ptr<int[], A::Deleter> p2(new int[2]{2, 2}, { -2 });
-  int* const pi1 = p1.get();
-  int* const pi2 = p2.get();
-  // This type must swappable even though the deleter is not move-assignable:
-  swap(p1, p2);
-  VERIFY(p1.get() == pi2);
-  VERIFY(p1.get_deleter().id == -2);
-  VERIFY(p2.get() == pi1);
-  VERIFY(p2.get_deleter().id == -1);
-}
-
-int main()
-{
-  test03();
-  test04();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/deque/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/deque/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/deque/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/deque/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -23,7 +23,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -23,7 +23,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/list/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/list/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/list/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/list/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -23,7 +23,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/map/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/map/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/map/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/map/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -24,7 +24,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/set/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/set/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/set/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/set/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -23,7 +23,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -24,7 +24,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -23,7 +23,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/vector/erasure.cc gcc-10-20200202/libstdc++-v3/testsuite/23_containers/vector/erasure.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/vector/erasure.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/23_containers/vector/erasure.cc	2020-02-02 23:32:20.000000000 +0100
@@ -23,7 +23,7 @@
 
 #ifndef __cpp_lib_erase_if
 # error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 202002
+#elif __cpp_lib_erase_if < 201811
 # error "Feature-test macro for erase_if has wrong value"
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/aliases.cc gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/aliases.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/aliases.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/aliases.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <iterator>
-
-template<typename T>
-struct Dereferenceable { T operator*(); };
-
-template<typename T>
-  concept has_iter_reference
-    = requires { typename std::iter_reference_t<T>; };
-
-template<typename T, typename U>
-  concept is_iter_reference_for
-    = has_iter_reference<U> && std::same_as<T, std::iter_reference_t<U>>;
-
-static_assert(!has_iter_reference<Dereferenceable<void>>);
-static_assert(is_iter_reference_for<int, Dereferenceable<int>>);
-static_assert(is_iter_reference_for<int&, Dereferenceable<int&>>);
-static_assert(is_iter_reference_for<int&&, Dereferenceable<int&&>>);
-static_assert(is_iter_reference_for<int&, int*>);
-static_assert(is_iter_reference_for<const int&, const int*>);
-
-template<typename T>
-  concept has_iter_rvalue_reference
-    = requires { typename std::iter_rvalue_reference_t<T>; };
-
-template<typename T, typename U>
-  concept is_iter_rvalue_reference_for
-    = has_iter_rvalue_reference<U>
-    && std::same_as<T, std::iter_rvalue_reference_t<U>>;
-
-static_assert(!has_iter_rvalue_reference<Dereferenceable<void>>);
-static_assert(is_iter_rvalue_reference_for<int, Dereferenceable<int>>);
-static_assert(is_iter_rvalue_reference_for<int&&, Dereferenceable<int&>>);
-static_assert(is_iter_rvalue_reference_for<int&&, Dereferenceable<int&&>>);
-static_assert(is_iter_rvalue_reference_for<int&&, int*>);
-static_assert(is_iter_rvalue_reference_for<const int&&, const int*>);
-
-// These functions should be found by ADL. std::move is not applied to result.
-long iter_move(Dereferenceable<short>);
-long& iter_move(Dereferenceable<short&&>);
-static_assert(is_iter_rvalue_reference_for<long, Dereferenceable<short>>);
-static_assert(is_iter_rvalue_reference_for<long&, Dereferenceable<short&&>>);
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc	2020-02-02 23:32:20.000000000 +0100
@@ -24,9 +24,9 @@
 
 template<typename T>
   concept has_readable_traits_type
-    = requires { typename std::indirectly_readable_traits<T>::value_type; };
+    = requires { typename std::readable_traits<T>::value_type; };
 
-// Check std::indirectly_readable_traits<T>::value_type is U (or doesn't exist).
+// Check std::readable_traits<T>::value_type is U (or doesn't exist).
 template<typename T, typename U>
   concept check_readable_traits
     = (has_readable_traits_type<T> != std::same_as<U, none>);
@@ -62,7 +62,7 @@
 
 struct E { };
 template<>
-  struct std::indirectly_readable_traits<E> { using value_type = long; };
+  struct std::readable_traits<E> { using value_type = long; };
 static_assert( check_readable_traits<E, long> );
 static_assert( check_readable_traits<const E, long> );
 
@@ -103,7 +103,7 @@
 
 struct G { };
 template<>
-  struct std::indirectly_readable_traits<G> { using value_type = G; };
+  struct std::readable_traits<G> { using value_type = G; };
 template<>
   struct std::iterator_traits<G> { using value_type = int; };
 // iterator_traits<G> is specialized, so use its value_type.
@@ -111,7 +111,7 @@
 
 struct H { };
 template<>
-  struct std::indirectly_readable_traits<H> { using value_type = H; };
+  struct std::readable_traits<H> { using value_type = H; };
 template<>
   struct std::iterator_traits<H>
   {
@@ -128,8 +128,8 @@
   using value_type = I;
 };
 // iterator_traits<I> is not specialized, and no standard specialization
-// matches, so use indirectly_readable_traits.
-static_assert( check_alias<I, std::indirectly_readable_traits<I>::value_type> );
+// matches, so use readable_traits.
+static_assert( check_alias<I, std::readable_traits<I>::value_type> );
 
 struct J
 {
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3389.cc gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3389.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3389.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3389.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <iterator>
-
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-
-template<typename T>
-struct move_only_wrapper : input_iterator_wrapper<T>
-{
-  using input_iterator_wrapper<T>::input_iterator_wrapper;
-
-  move_only_wrapper()
-    : input_iterator_wrapper<T>(nullptr, nullptr)
-  { }
-
-  move_only_wrapper(const move_only_wrapper&) = delete;
-  move_only_wrapper&
-  operator=(const move_only_wrapper&) = delete;
-
-  move_only_wrapper(move_only_wrapper&&) = default;
-  move_only_wrapper&
-  operator=(move_only_wrapper&&) = default;
-
-  using input_iterator_wrapper<T>::operator++;
-
-  move_only_wrapper&
-  operator++()
-  {
-    input_iterator_wrapper<T>::operator++();
-    return *this;
-  }
-};
-
-static_assert(std::input_iterator<move_only_wrapper<int>>);
-static_assert(!std::forward_iterator<move_only_wrapper<int>>);
-static_assert(!std::copyable<move_only_wrapper<int>>);
-
-// LWG 3389
-void
-test01()
-{
-  int x[] = {1,2,3,4};
-  test_range<int, move_only_wrapper> rx(x);
-  auto it = std::counted_iterator(rx.begin(), 2);
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/indirect_callable/projected.cc gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/indirect_callable/projected.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/indirect_callable/projected.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/indirect_callable/projected.cc	2020-02-02 23:32:20.000000000 +0100
@@ -29,11 +29,9 @@
 struct X
 {
   using value_type = char*;
-  char* const& operator*() const;
+  char* const& operator*() &;
 };
-static_assert( std::indirectly_readable<X> );
-static_assert( std::indirectly_readable<X&> );
-static_assert( std::indirectly_readable<const X> );
+static_assert( std::readable<X> );
 static_assert(std::same_as<PI<X>::value_type, char*>);
 static_assert(std::same_as<decltype(*std::declval<PI<X>&>()), char* const&>);
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/move_iterator/lwg3390.cc gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/move_iterator/lwg3390.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/24_iterators/move_iterator/lwg3390.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/24_iterators/move_iterator/lwg3390.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <iterator>
-
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-
-template<typename T>
-struct move_only_wrapper : input_iterator_wrapper<T>
-{
-  using input_iterator_wrapper<T>::input_iterator_wrapper;
-
-  move_only_wrapper()
-    : input_iterator_wrapper<T>(nullptr, nullptr)
-  { }
-
-  move_only_wrapper(const move_only_wrapper&) = delete;
-  move_only_wrapper&
-  operator=(const move_only_wrapper&) = delete;
-
-  move_only_wrapper(move_only_wrapper&&) = default;
-  move_only_wrapper&
-  operator=(move_only_wrapper&&) = default;
-
-  using input_iterator_wrapper<T>::operator++;
-
-  move_only_wrapper&
-  operator++()
-  {
-    input_iterator_wrapper<T>::operator++();
-    return *this;
-  }
-};
-
-static_assert(std::input_iterator<move_only_wrapper<int>>);
-static_assert(!std::forward_iterator<move_only_wrapper<int>>);
-static_assert(!std::copyable<move_only_wrapper<int>>);
-
-// LWG 3390
-void
-test01()
-{
-  int x[] = {1,2,3,4};
-  test_range<int, move_only_wrapper> rx(x);
-  auto it = std::make_move_iterator(rx.begin());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/adjacent_find/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/adjacent_find/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/adjacent_find/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/adjacent_find/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  int y[] = { 2, 7, 8, 8, 9 };
-
-  VERIFY( ranges::adjacent_find(x, x+6, {}, &X::i) == x+0 );
-  VERIFY( ranges::adjacent_find(x+1, x+6, {}, &X::i) == x+6 );
-  VERIFY( ranges::adjacent_find(y) == y+2 );
-  VERIFY( ranges::adjacent_find(y, y+4) == y+2 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  VERIFY( ranges::adjacent_find(c, {}, &X::i) == ranges::begin(c) );
-
-  test_range<int, forward_iterator_wrapper> r(y);
-  auto res = ranges::adjacent_find(r);
-  VERIFY( *res == 8 && *++res == 8 );
-}
-
-void
-test02()
-{
-  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  static constexpr X y[] = { {2}, {6}, {8}, {10}, {11} };
-  static_assert(ranges::adjacent_find(x, {}, &X::i) == x+0);
-  static_assert(ranges::adjacent_find(y, {}, &X::i) == y+5);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
-
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/all_of/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/all_of/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/all_of/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/all_of/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,90 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-struct XLess
-{
-  int val;
-  bool operator()(X& x) const { return x.i < val; }
-};
-
-struct ILess
-{
-  int val;
-  bool operator()(int& i) const { return i < val; }
-};
-
-template<typename T>
-struct NotZero
-{
-  bool operator()(T& t) const { return t != 0; }
-};
-
-void
-test01()
-{
-  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };
-
-  VERIFY( ranges::all_of(x, x+5, XLess{11}) );
-  VERIFY( ranges::all_of(x, x+5, ILess{11}, &X::i) );
-  VERIFY( !ranges::all_of(x, x+6, ILess{11}, &X::i) );
-  VERIFY( !ranges::all_of(x, XLess{11}) );
-  VERIFY( ranges::all_of(x, XLess{12}) );
-  VERIFY( ranges::all_of(x, ILess{12}, &X::i) );
-  VERIFY( !ranges::all_of(x, ILess{11}, &X::i) );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  VERIFY( ranges::all_of(c, NotZero<int>{}, &X::i) );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  VERIFY( ranges::all_of(r, NotZero<int>{}, &X::i) );
-
-  r.bounds.first = x;
-  VERIFY( ranges::all_of(r, NotZero<X* const>{}, [](X& x) { return &x; }) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };
-  static_assert(ranges::all_of(y, [](int j) { return j%2 == 0; }, &Y::j));
-  static_assert(ranges::all_of(y, [](const Y& y) { return y.j == y.i * 2; }));
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/any_of/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/any_of/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/any_of/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/any_of/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-struct XLess
-{
-  int val;
-  bool operator()(X& x) const { return x.i < val; }
-};
-
-struct ILess
-{
-  int val;
-  bool operator()(int& i) const { return i < val; }
-};
-
-template<typename T>
-struct NotZero
-{
-  bool operator()(T& t) const { return t != 0; }
-};
-
-void
-test01()
-{
-  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };
-
-  VERIFY( ranges::any_of(x, x+6, XLess{3}) );
-  VERIFY( ranges::any_of(x, x+6, ILess{3}, &X::i) );
-  VERIFY( !ranges::any_of(x+1, x+6, XLess{3}) );
-  VERIFY( !ranges::any_of(x+1, x+6, ILess{3}, &X::i) );
-  VERIFY( ranges::any_of(x, XLess{5}) );
-  VERIFY( ranges::any_of(x, ILess{5}, &X::i) );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  VERIFY( ranges::any_of(c, NotZero<int>{}, &X::i) );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  VERIFY( ranges::any_of(r, NotZero<int>{}, &X::i) );
-  VERIFY( ranges::any_of(r, NotZero<X* const>{}, [](X& x) { return &x; }) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };
-  static_assert(ranges::any_of(y, [](int i) { return i%2 == 0; }, &Y::i));
-  static_assert(ranges::any_of(y, [](const Y& y) { return y.i + y.j == 3; }));
-  static_assert(!ranges::any_of(y, [](const Y& y) { return y.i == y.j; }));
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/binary_search/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/binary_search/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/binary_search/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/binary_search/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  float x[] = {1, 2, 3, 4, 5, 5, 6, 7};
-  test_container<float, forward_iterator_wrapper> cx(x);
-  for (int i = 0; i < 7; i++)
-    {
-      VERIFY( ranges::binary_search(cx, i, {}, [] (int a) { return a-1; }) );
-      VERIFY( !ranges::binary_search(cx.begin(), cx.end(), i+0.5) );
-    }
-  VERIFY( !ranges::binary_search(cx, 0) );
-
-  ranges::reverse(x);
-  test_range<float, forward_iterator_wrapper> rx(x);
-  VERIFY( ranges::binary_search(rx, 5, ranges::greater{}) );
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1, 2, 3};
-  return (ranges::binary_search(x, 3)
-	  && !ranges::binary_search(x, x, 3));
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,225 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-    {
-      int x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      int y[7] = { 0 };
-      int z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      auto [in, out] = ranges::copy(x, y);
-      VERIFY( ranges::equal(x, y) && in == x+7 && out == y+7 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      int x[3] = { 1, 2, 3 };
-      char y[4] = { 0 };
-      int z[3] = { 1, 2, 3 };
-      test_container<int, forward_iterator_wrapper> cx(x);
-      test_container<char, forward_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::copy(cx, ranges::begin(cy));
-      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      char x[3] = { 1, 2, 3 };
-      int y[4] = { 0 };
-      int z[3] = { 1, 2, 3 };
-      test_range<char, input_iterator_wrapper> rx(x);
-      test_range<int, output_iterator_wrapper> ry(y);
-      auto [in, out] = ranges::copy(rx, ranges::begin(ry));
-      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::copy(x, ranges::begin(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::copy(x, ranges::begin(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::copy(make_reverse_iterator(x.end()),
-				   make_reverse_iterator(x.begin()),
-				   make_reverse_iterator(y.end()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::copy(make_reverse_iterator(x.end()),
-				   make_reverse_iterator(x.begin()),
-				   make_reverse_iterator(y.end()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-}
-
-struct X
-{
-  int i;
-  constexpr X (int a) : i(a) { }
-};
-
-void
-test02()
-{
-  int x[] = { {2}, {2}, {6}, {8}, {10} };
-  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  int z[] = { {2}, {2}, {6}, {8}, {10} };
-  auto [in, out] = ranges::copy(x, y);
-  VERIFY( ranges::equal(x, x+5, y, y+5, {}, {}, &X::i) );
-  VERIFY( in == x+5 );
-  VERIFY( out == y+5 );
-  VERIFY( y[5].i == 2 );
-  VERIFY( ranges::equal(x, z) );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  int x[] = { {2}, {2}, {6}, {8}, {10} };
-  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  int z[] = { {2}, {2}, {6}, {8}, {10} };
-  auto [in, out] = ranges::copy(x, y);
-  ok &= ranges::equal(x, x+5, y, y+5, {}, {}, &X::i);
-  ok &= (in == x+5);
-  ok &= (out == y+5);
-  ok &= (y[5].i == 2);
-  ok &= ranges::equal(x, z);
-  return ok;
-}
-
-struct Y
-{
-  int i;
-  int moved = 0;
-
-  constexpr Y(int a) : i(a) { }
-
-  constexpr Y(const Y&) = delete;
-  constexpr Y& operator=(const Y&) = delete;
-
-  constexpr Y(Y&& other)
-  {
-    *this = std::move(other);
-  }
-
-  constexpr Y&
-  operator=(Y&& other)
-  {
-    other.moved++;
-    i = other.i;
-    return *this;
-  }
-
-  friend constexpr bool
-  operator==(const Y& a, const Y& b)
-  { return a.i == b.i; }
-};
-
-void
-test04()
-{
-  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };
-  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  test_range<Y, input_iterator_wrapper> rx(x);
-  auto [in, out] = ranges::copy(std::move_iterator{ranges::begin(rx)},
-				std::move_sentinel{ranges::end(rx)},
-				ranges::begin(y));
-  VERIFY( ranges::equal(x, y) && std::move(in).base().ptr == x+7 && out == y+7 );
-  VERIFY( ranges::equal(x, z) );
-  for (const auto& v : x)
-    VERIFY( v.moved == 1 );
-  for (const auto& v : y)
-    VERIFY( v.moved == 0 );
-}
-
-constexpr bool
-test05()
-{
-  bool ok = true;
-  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };
-  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  auto [in, out] = ranges::copy(std::move_iterator{ranges::begin(x)},
-				std::move_sentinel{ranges::end(x)},
-				ranges::begin(y));
-  ok &= ranges::equal(x, y);
-  ok &= in.base() == x+7;
-  ok &= out == y+7;
-  ok &= ranges::equal(x, z);
-  for (const auto& v : x)
-    ok &= v.moved == 1;
-  for (const auto& v : y)
-    ok &= v.moved == 0;
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-  test04();
-  static_assert(test05());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy_backward/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy_backward/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy_backward/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy_backward/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,193 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-    {
-      int x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      int y[7] = { 0 };
-      int z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      auto [in, out] = ranges::copy_backward(x, ranges::end(y));
-      VERIFY( ranges::equal(x, y) && in == x+7 && out == y);
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      int x[3] = { 1, 2, 3 };
-      char y[4] = { 0 };
-      int z[3] = { 1, 2, 3 };
-      test_container<int, bidirectional_iterator_wrapper> cx(x);
-      test_container<char, bidirectional_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::copy_backward(cx, ranges::end(cy));
-      VERIFY( ranges::equal(x, x+3, y+1, y+4) && in.ptr == x+3 && out.ptr == y+1 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::copy_backward(x, ranges::end(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::copy_backward(x, ranges::end(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::copy_backward(make_reverse_iterator(x.end()),
-					    make_reverse_iterator(x.begin()),
-					    make_reverse_iterator(y.begin()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::copy_backward(make_reverse_iterator(x.end()),
-					    make_reverse_iterator(x.begin()),
-					    make_reverse_iterator(y.begin()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  int x[] = { {2}, {2}, {6}, {8}, {10} };
-  int y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  const int z[] = { {2}, {2}, {6}, {8}, {10} };
-  auto [in, out] = ranges::copy_backward(x, ranges::end(y));
-  ok &= ranges::equal(x, x+5, y+1, y+6);
-  ok &= (in == x+5);
-  ok &= (out == y+1);
-  ok &= (y[0] == 2);
-  ok &= ranges::equal(x, z);
-  return ok;
-}
-
-/*  move_iterators are always input_iterators and therefore do not model
- *  bidirectional_iterator, so I think the following tests are rightly invalid.
-
-struct Y
-{
-  int i;
-  int moved = 0;
-
-  constexpr Y(int a) : i(a) { }
-
-  constexpr Y(const Y&) = delete;
-  constexpr Y& operator=(const Y&) = delete;
-
-  constexpr Y(Y&& other)
-  {
-    *this = std::move(other);
-  }
-
-  constexpr Y&
-  operator=(Y&& other)
-  {
-    other.moved++;
-    i = other.i;
-    return *this;
-  }
-
-  friend constexpr bool
-  operator==(const Y& a, const Y& b)
-  { return a.i == b.i; }
-};
-
-void
-test02()
-{
-  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };
-  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  test_range<Y, bidirectional_iterator_wrapper> rx(x);
-  auto [in, out] = ranges::copy_backward(std::move_iterator{ranges::begin(rx)},
-					 std::move_sentinel{ranges::end(rx)},
-					 ranges::end(y));
-  VERIFY( ranges::equal(x, y) && std::move(in).base().ptr == x+7 && out == y );
-  VERIFY( ranges::equal(x, z) );
-  for (const auto& v : x)
-    VERIFY( v.moved == 1 );
-  for (const auto& v : y)
-    VERIFY( v.moved == 0 );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  Y x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  Y y[7] = { 0, 0, 0, 0, 0, 0, 0 };
-  Y z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  auto [in, out] = ranges::copy_backward(std::move_iterator{ranges::begin(x)},
-					 std::move_sentinel{ranges::end(x)},
-					 ranges::end(y));
-  ok &= ranges::equal(x, y);
-  ok &= in.base() == x+7;
-  ok &= out == y;
-  ok &= ranges::equal(x, z);
-  for (const auto& v : x)
-    ok &= v.moved == 1;
-  for (const auto& v : y)
-    ok &= v.moved == 0;
-  return ok;
-}
-*/
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy_if/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy_if/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy_if/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy_if/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5,6,7};
-
-    {
-      const int y[] = {2,4,6};
-      int w[7];
-      test_range<int, input_iterator_wrapper> rx(x);
-      test_range<int, output_iterator_wrapper> rw(w);
-      auto [in,out] = ranges::copy_if(rx, rw.begin(),
-				      [] (int a) { return (a%2)==0; });
-      VERIFY( in == rx.end() && out.ptr == w+3 );
-      VERIFY( ranges::equal(w, w+3, y, y+3) );
-    }
-
-    {
-      const int y[] = {1,3,5,7};
-      int w[7];
-      test_range<int, input_iterator_wrapper> rx(x);
-      test_range<int, output_iterator_wrapper> rw(w);
-      auto [in,out] = ranges::copy_if(rx, rw.begin(),
-				      [] (int a) { return (a%2)==0; },
-				      [] (int a) { return a+1; });
-      VERIFY( in == rx.end() && out.ptr == w+4 );
-      VERIFY( ranges::equal(w, w+4, y, y+4) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1,2,3};
-  const int y[] = {1,3};
-  int w[3];
-  auto [in,out] = ranges::copy_if(x, w, [] (int a) { return (a%2)==1; });
-  return ranges::equal(w, out, y, y+2);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy_n/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy_n/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/copy_n/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/copy_n/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,72 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-template<template<typename> typename in_wrapper,
-	 template<typename> typename out_wrapper>
-void
-test01()
-{
-  int x[] = {1,2,3,4,5,6,7};
-  for (int i = -1; i <= 7; i++)
-    {
-      test_range<int, in_wrapper> rx(x);
-      int w[7];
-      test_range<int, out_wrapper> rw(w);
-      ranges::copy_n(rx.begin(), i, rw.begin());
-      if (i >= 0)
-	VERIFY( ranges::equal(x, x+i, w, w+i) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1,2,3};
-  int y[2];
-  auto [in,out] = ranges::copy_n(x, 2, y);
-  return (in == x+2
-	  && out == y+2
-	  && ranges::equal(x, x+2, y, y+2));
-}
-
-int
-main()
-{
-  test01<input_iterator_wrapper,
-	 output_iterator_wrapper>();
-  test01<random_access_iterator_wrapper,
-	 output_iterator_wrapper>();
-  test01<random_access_iterator_wrapper,
-	 random_access_iterator_wrapper>();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/count/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/count/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/count/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/count/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10}, {11}, {2} };
-  auto res = ranges::count(x, x+7, 2, &X::i);
-  VERIFY( res == 3 );
-  res = ranges::count(x, x+7, 8, &X::i);
-  VERIFY( res == 1 );
-  res = ranges::count(x, x+7, 9, &X::i);
-  VERIFY( res == 0 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  res = ranges::count(c, 6, &X::i);
-  VERIFY( res == 1 );
-  res = ranges::count(c, 9, &X::i);
-  VERIFY( res == 0 );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  res = ranges::count(r, 2, &X::i);
-  VERIFY( res == 3 );
-
-  r.bounds.first = x;
-  res = ranges::count(r, 9, &X::i);
-  VERIFY( res == 0 );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6}, {1,6} };
-  static_assert(ranges::count(y, 6, &Y::j) == 2);
-  static_assert(ranges::count(y, 5, &Y::j) == 0);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/count_if/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/count_if/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/count_if/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/count_if/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10}, {11}, {2} };
-  auto res = ranges::count_if(x, x+7, [] (int i) { return i % 2 == 0; }, &X::i);
-  VERIFY( res == 6 );
-  res = ranges::count_if(x, x+7, [] (int i) { return i % 2 == 1; }, &X::i);
-  VERIFY( res == 1 );
-  res = ranges::count_if(x, x+7, [] (int i) { return i < 0; }, &X::i);
-  VERIFY( res == 0 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  res = ranges::count_if(c, [] (int i) { return i == 2; }, &X::i);
-  VERIFY( res == 3 );
-  res = ranges::count_if(c, [] (int i) { return i < 0; }, &X::i);
-  VERIFY( res == 0 );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  res = ranges::count_if(c, [] (int i) { return i == 2; }, &X::i);
-  VERIFY( res == 3 );
-  res = ranges::count_if(c, [] (int i) { return i < 0; }, &X::i);
-  VERIFY( res == 0 );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6}, {1,6} };
-  static_assert(ranges::count_if(y, [] (int i) { return i < 5; }, &Y::j) == 2);
-  static_assert(ranges::count_if(y, [] (int i) { return i != 4; }, &Y::j) == 3);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/equal/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/equal/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/equal/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/equal/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  int x[] = { {2}, {2}, {6}, {8}, {10}, {11}, {11} };
-  int y[] = { {2}, {2}, {6}, {8}, {10}, {11}, {11} };
-  X   z[] = { {2}, {6}, {8}, {10}, {2}, {2} };
-  int w[] = { {1}, {1}, {1}, {1}, {1} };
-
-  VERIFY( ranges::equal(w, w+4, w+1, w+5) );
-  VERIFY( ranges::equal(w, w+5, w, w+5, ranges::greater{},
-			[] (int a) { return a+1; }) );
-
-  test_container<int, forward_iterator_wrapper> cx(x), cy(y);
-  test_container<X, forward_iterator_wrapper> cz(z);
-  VERIFY( ranges::equal(cx, cy) );
-  VERIFY( !ranges::equal(cx, cy, {}, [] (int a) { return a+1; }) );
-  VERIFY( !ranges::equal(cx, cz, {}, {}, &X::i) );
-
-  test_range<int, input_iterator_wrapper> rx(x), ry(y);
-  test_range<X, input_iterator_wrapper> rz(z);
-  VERIFY( ranges::equal(rx, ry) );
-
-  rx.bounds.first = x;
-  ry.bounds.first = y;
-  VERIFY( !ranges::equal(rx, ry, {}, {}, [] (int a) { return a+1; }) );
-
-  rx.bounds.first = x;
-  rz.bounds.first = z;
-  VERIFY( !ranges::equal(rx, rz, {}, {}, &X::i) );
-}
-
-void
-test02()
-{
-  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  static constexpr X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  static constexpr int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };
-  static constexpr int w[] = { {2}, {6}, {8}, {10}, {2}, {2} };
-
-  static_assert(ranges::equal(z, w));
-  static_assert(!ranges::equal(z, z+5, w+1, w+6));
-  static_assert(!ranges::equal(z, z, {}, {}, [] (int a) { return a+1; }));
-  static_assert(!ranges::equal(x, y, {}, &X::i, &X::i));
-}
-
-void
-test03()
-{
-  std::vector<int> x = { {2}, {2}, {6}, {8}, {10}, {11} };
-  std::vector<int> y = { {2}, {2}, {6}, {8}, {10}, {11} };
-  std::vector<int> z = { {2}, {2}, {6}, {8}, {10}, {12} };
-  VERIFY( ranges::equal(x, y) );
-  VERIFY( !ranges::equal(x, z) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/equal_range/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/equal_range/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/equal_range/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/equal_range/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1, 2, 3, 4, 5, 5, 6, 7};
-  for (unsigned i = 0; i < 5; i++)
-    for (unsigned j = 6; j < 8; j++)
-      {
-	test_container<int, forward_iterator_wrapper> cx(x);
-	auto range = ranges::equal_range(std::next(cx.begin(), i),
-					 std::next(cx.begin(), j),
-					 4, {}, [] (int a) { return a-1; });
-	VERIFY( range.begin().ptr == x+4 && range.end().ptr == x+6 );
-      }
-
-  ranges::reverse(x);
-  test_range<int, forward_iterator_wrapper> rx(x);
-  auto range = ranges::equal_range(rx, 5, ranges::greater{},
-				   [] (int a) { return a+1; });
-  VERIFY( range.begin().ptr == x+4 && range.end().ptr == x+5 );
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  auto range1 = ranges::equal_range(x, 6);
-  auto range2 = ranges::equal_range(x, x, 6);
-  auto range3 = ranges::equal_range(x, 1);
-  return (range1.begin() == x+5 && range1.end() == x+5
-	  && range2.begin() == x && range2.end() == x
-	  && range3.begin() == x && range3.end() == x+1);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/fill/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/fill/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/fill/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/fill/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-#include <list>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-};
-
-void
-test01()
-{
-  const int c[6] = { 17, 17, 17, 17, 17, 17 };
-    {
-      X x[6];
-      VERIFY( ranges::fill(x, X{17}) == x+6 );
-      VERIFY( ranges::equal(x, c, {}, &X::i) );
-    }
-
-    {
-      char x[6];
-      VERIFY( ranges::fill(x, 17) == x+6 );
-      VERIFY( ranges::equal(x, c) );
-    }
-
-    {
-      X x[6];
-      test_container<X, forward_iterator_wrapper> cx(x);
-      VERIFY( ranges::fill(cx, X{17}) == cx.end() );
-      VERIFY( ranges::equal(cx, c, {}, &X::i) );
-    }
-
-    {
-      int x[6];
-      test_range<int, output_iterator_wrapper> rx(x);
-      VERIFY( ranges::fill(rx, 17) == rx.end() );
-      VERIFY( ranges::equal(x, c) );
-    }
-
-    {
-      std::list<int> list(6);
-      ranges::fill(list, 17);
-      VERIFY( ranges::equal(list, c) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  int x[5];
-  ranges::fill(x, 17);
-  for (auto v : x)
-    ok &= v == 17;
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/fill_n/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-#include <list>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-};
-
-void
-test01()
-{
-  const int c[6] = { 17, 17, 17, 4, 5, 6 };
-    {
-      X x[6] = { {1}, {2}, {3}, {4}, {5}, {6} };
-      VERIFY( ranges::fill_n(x, 3, X{17}) == x+3 );
-      VERIFY( ranges::equal(x, c, {}, &X::i) );
-    }
-
-    {
-      char x[6];
-      VERIFY( ranges::fill_n(x, 3, 17) == x+3 );
-      VERIFY( ranges::equal(x, x+3, c, c+3) );
-    }
-
-    {
-      X x[6] = { 1, 2, 3, 4, 5, 6 };
-      test_container<X, forward_iterator_wrapper> cx(x);
-      VERIFY( ranges::fill_n(cx.begin(), 3, X{17})->i == 4 );
-      VERIFY( ranges::equal(cx, c, {}, &X::i) );
-    }
-
-    {
-      int x[6] = { 1, 2, 3, 4, 5, 6 };;
-      test_range<int, output_iterator_wrapper> rx(x);
-      ranges::fill_n(ranges::begin(rx), 3, 17);
-      VERIFY( ranges::equal(x, c) );
-    }
-
-    {
-      std::list<int> list({1, 2, 3, 4, 5, 6});
-      ranges::fill_n(list.begin(), 3, 17);
-      VERIFY( ranges::equal(list, c) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  int x[6] = { 1, 2, 3, 4, 5, 6 };
-  const int y[6] = { 1, 2, 3, 4, 5, 6 };
-  const int z[6] = { 17, 17, 17, 4, 5, 6 };
-
-  ranges::fill_n(x, 0, 17);
-  ranges::fill_n(x, -1, 17);
-  ok &= ranges::equal(x, y);
-
-  ranges::fill_n(x, 3, 17);
-  ok &= ranges::equal(x, z);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  auto res = ranges::find(x, x+6, 8, &X::i);
-  VERIFY( res == x+3 );
-  res = ranges::find(x, x+6, 2, &X::i);
-  VERIFY( res == x+0 );
-  res = ranges::find(x, x+6, 9, &X::i);
-  VERIFY( res == x+6 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  auto res2 = ranges::find(c, 8, &X::i);
-  VERIFY( res2 != ranges::end(c) && res2->i == 8 );
-  res2 = ranges::find(c, 9, &X::i);
-  VERIFY( res2 == ranges::end(c) );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  auto res3 = ranges::find(r, 8, &X::i);
-  VERIFY( res3 != ranges::end(r) && res3->i == 8 );
-
-  r.bounds.first = x;
-  res3 = ranges::find(r, 9, &X::i);
-  VERIFY( res3 == ranges::end(r) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };
-  static_assert(ranges::find(y, 4, &Y::j) == y+1);
-  static_assert(ranges::find(y, 5, &Y::j) == y+3);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_end/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_end/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_end/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_end/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {10}, {11}, {2}, {6}, {8}, {10}, {11} };
-  X y[] = { {10}, {11} };
-  {
-
-    test_container<X, forward_iterator_wrapper> c(x);
-    auto res = ranges::find_end(c, y, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(c) );
-    res = ranges::find_end(c, c, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res) == ranges::begin(c)
-	    && std::get<1>(res) == ranges::end(c) );
-  }
-
-  {
-    test_range<X, forward_iterator_wrapper> r(x);
-    auto res = ranges::find_end(r, y, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(r) );
-    res = ranges::find_end(r, r, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res) == ranges::begin(r)
-	    && std::get<1>(res) == ranges::end(r) );
-  }
-
-  {
-    test_range<X, bidirectional_iterator_wrapper> r(x);
-    auto res = ranges::find_end(r, y, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(r) );
-    res = ranges::find_end(r, r, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res) == ranges::begin(r)
-	    && std::get<1>(res) == ranges::end(r) );
-  }
-}
-
-void
-test02()
-{
-  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {6}, {8}, {11} };
-  static constexpr X y[] = { {6}, {8} };
-  static constexpr int z[] = { 2, 8 };
-  static constexpr int w[] = { 2 };
-
-  static_assert(std::get<0>(ranges::find_end(x, y, {}, &X::i, &X::i)) == x+5);
-  static_assert(std::get<1>(ranges::find_end(x, y, {}, &X::i, &X::i)) == x+7);
-
-  static_assert(std::get<0>(ranges::find_end(x, z, {}, &X::i)) == x+8);
-  static_assert(std::get<1>(ranges::find_end(x, z, {}, &X::i)) == x+8);
-
-  static_assert(std::get<0>(ranges::find_end(x, w, {}, &X::i)) == x+1);
-  static_assert(std::get<1>(ranges::find_end(x, w, {}, &X::i)) == x+2);
-
-  static_assert(std::get<0>(ranges::find_end(x, x+6, w, w, {}, &X::i)) == x+6);
-  static_assert(std::get<1>(ranges::find_end(x, x+6, w, w, {}, &X::i)) == x+6);
-
-  static_assert(std::get<0>(ranges::find_end(x, x, w, w+1, {}, &X::i)) == x+0);
-  static_assert(std::get<1>(ranges::find_end(x, x, w, w+1, {}, &X::i)) == x+0);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_first_of/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_first_of/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_first_of/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_first_of/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  int y[] = { 2, 7, 8, 9 };
-  X w[] = { {2}, {7}, {8}, {9} };
-
-  auto res = ranges::find_first_of(x, x+6, y+1, y+4, {}, &X::i);
-  VERIFY( res == x+3 );
-  res = ranges::find_first_of(x, x+6, w, w+4, {}, &X::i, &X::i);
-  VERIFY( res == x+0 );
-  res = ranges::find_first_of(x, x+6, y+3, y+4, {}, &X::i);
-  VERIFY( res == x+6 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  test_container<int, forward_iterator_wrapper> d1(y+1, y+4);
-  auto res2 = ranges::find_first_of(c, d1, {}, &X::i);
-  VERIFY( res2 != ranges::end(c) && res2->i == 8 );
-
-  test_container<X, forward_iterator_wrapper> d2(w+3, w+4);
-  res2 = ranges::find_first_of(c, d2, {}, &X::i, &X::i);
-  VERIFY( res2 == ranges::end(c) );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  test_range<int, forward_iterator_wrapper> s1(y+1, y+4);
-  auto res3 = ranges::find_first_of(r, s1, {}, &X::i);
-  VERIFY( res3 != ranges::end(r) && res3->i == 8 );
-
-  test_range<X, forward_iterator_wrapper> s2(w+3, w+4);
-  r.bounds.first = x;
-  res3 = ranges::find_first_of(r, s2, {}, &X::i, &X::i);
-  VERIFY( res3 == ranges::end(r) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };
-  static_assert(ranges::find_first_of(y, y, {}, &Y::j, &Y::i) == y);
-  static_assert(ranges::find_first_of(y, y, {}, &Y::i, &Y::j) == y+1);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_if/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_if/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_if/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_if/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  auto res = ranges::find_if(x, x+6, [] (X& v) { return v.i == 8; });
-  VERIFY( res == x+3 );
-  res = ranges::find_if(x, x+6, [] (X& v) { return v.i % 2 == 0; });
-  VERIFY( res == x+0 );
-  res = ranges::find_if(x, x+6, [] (X& v) { return v.i == 9; });
-  VERIFY( res == x+6 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  auto res2 = ranges::find_if(c, [] (int i) { return i > 7; }, &X::i);
-  VERIFY( res2 != ranges::end(c) && res2->i == 8 );
-  res2 = ranges::find_if(c, [] (int i) { return i > 11; }, &X::i);
-  VERIFY( res2 == ranges::end(c) );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  auto res3 = ranges::find_if(r, [] (int i) { return i > 10; }, &X::i);
-  VERIFY( res3 != ranges::end(r) && res3->i == 11 );
-
-  r.bounds.first = x;
-  res3 = ranges::find_if(r, [] (int i) { return i == 9; }, &X::i);
-  VERIFY( res3 == ranges::end(r) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };
-  static_assert(ranges::find_if(y, [] (int i) { return i > 3; }, &Y::j)
-		== y+1);
-  static_assert(ranges::find_if(y, [] (int i) { return i == 5; }, &Y::j)
-		== y+3);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_if_not/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_if_not/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/find_if_not/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/find_if_not/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  auto res = ranges::find_if_not(x, x+6, [] (X& v) { return v.i != 8; });
-  VERIFY( res == x+3 );
-  res = ranges::find_if_not(x, x+6, [] (X& v) { return v.i % 2 == 1; });
-  VERIFY( res == x+0 );
-  res = ranges::find_if_not(x, x+6, [] (X& v) { return v.i != 9; });
-  VERIFY( res == x+6 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  auto res2 = ranges::find_if_not(c, [] (int i) { return i <= 7; }, &X::i);
-  VERIFY( res2 != ranges::end(c) && res2->i == 8 );
-  res2 = ranges::find_if_not(c, [] (int i) { return i <= 11; }, &X::i);
-  VERIFY( res2 == ranges::end(c) );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  auto res3 = ranges::find_if_not(r, [] (int i) { return i <= 10; }, &X::i);
-  VERIFY( res3 != ranges::end(r) && res3->i == 11 );
-
-  r.bounds.first = x;
-  res3 = ranges::find_if_not(r, [] (int i) { return i != 9; }, &X::i);
-  VERIFY( res3 == ranges::end(r) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };
-  static_assert(ranges::find_if_not(y, [] (int i) { return i <= 3; }, &Y::j)
-		== y+1);
-  static_assert(ranges::find_if_not(y, [] (int i) { return i != 5; }, &Y::j)
-		== y+3);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-static int a;
-
-void
-f(int& i)
-{
-  a += i;
-}
-
-void
-test01()
-{
-  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };
-
-  auto res = ranges::for_each(x, x+6, f, &X::i);
-  VERIFY( res.in == x+6 );
-  VERIFY( res.fun == &f );
-  VERIFY( a == 41 );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  int p = 0;
-  ranges::for_each(c, [&p](int i) { ++p; }, &X::i);
-  VERIFY( p == 6 );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  int q = 0;
-  ranges::for_each(r, [&q](X&) { ++q; });
-  VERIFY( q == 6 );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  auto f = []
-  {
-    Y y[] = { {1,2}, {2,4}, {3,6} };
-    int a = 0;
-    ranges::for_each(y, [&a](int i) { a += i; }, &Y::i);
-    return a;
-  };
-  static_assert(f() == 6);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/generate/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/generate/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/generate/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/generate/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  const int c[6] = { 1, 2, 3, 4, 5, 6 };
-
-    {
-      int x[6];
-      int a = 1;
-      VERIFY( ranges::generate(x, [&] { return a++; }) == x+6 );
-      VERIFY( ranges::equal(x, c) );
-    }
-
-    {
-      int x[6];
-      int a = 1;
-      test_container<int, forward_iterator_wrapper> cx(x);
-      VERIFY( ranges::generate(cx, [&] { return a++; }) == cx.end() );
-      VERIFY( ranges::equal(cx, c) );
-    }
-
-    {
-      int x[6];
-      int a = 1;
-      test_range<int, output_iterator_wrapper> rx(x);
-      VERIFY( ranges::generate(rx, [&] { return a++; }) == rx.end() );
-      VERIFY( ranges::equal(x, c) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  const int c[6] = { 1, 2, 3, 4, 5, 6 };
-  int x[6];
-  int a = 1;
-  ranges::generate(x, [&] { return a++; });
-  return ranges::equal(x, c);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/generate_n/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/generate_n/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/generate_n/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/generate_n/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  const int c[6] = { 1, 2, 3, 4, 5, 6 };
-
-    {
-      int x[6] = { 7, 8, 9, 4, 5, 6 };
-      int a = 1;
-      VERIFY( ranges::generate_n(x, 3, [&] { return a++; }) == x+3 );
-      VERIFY( ranges::equal(x, c) );
-    }
-
-    {
-      int x[6] = { 7, 8, 9, 4, 5, 6 };
-      int a = 1;
-      test_container<int, forward_iterator_wrapper> cx(x);
-      VERIFY( *ranges::generate_n(cx.begin(), 3, [&] { return a++; })
-	       == 4 );
-      VERIFY( ranges::equal(cx, c) );
-    }
-
-    {
-      int x[6] = { 7, 8, 9, 4, 5, 6 };
-      int a = 1;
-      test_range<int, output_iterator_wrapper> rx(x);
-      ranges::generate_n(ranges::begin(rx), 3, [&] { return a++; });
-      VERIFY( ranges::equal(x, c) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  int c[6] = { 1, 2, 3, 4, 5, 6 };
-  int x[6];
-  int a = 1;
-  ranges::generate_n(x, 6, [&] { return a++; });
-  ok &= ranges::equal(x, c);
-  ranges::generate_n(c, 0, [] { return -1; });
-  ok &= ranges::equal(x, c);
-  ranges::generate_n(c, -2, [] { return -1; });
-  ok &= ranges::equal(x, c);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/heap/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/heap/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/heap/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/heap/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-template<template<typename, template<typename> typename> typename container>
-void
-test01()
-{
-  int x[50];
-
-  auto pred = std::greater{};
-  auto proj = [] (int a) { return -a; };
-  for (int i = 0; i < 50; i++)
-    {
-      std::iota(x, x+50, 1);
-      container<int, random_access_iterator_wrapper> rx(x);
-
-      std::ranlux48_base g(i);
-      ranges::shuffle(rx, g);
-
-      auto iter = ranges::make_heap(rx, pred, proj);
-      VERIFY( iter == rx.end() );
-      VERIFY( ranges::is_heap(rx, pred, proj) );
-      VERIFY( ranges::is_heap_until(rx, pred, proj) == rx.end() );
-
-      iter = ranges::pop_heap(rx, pred, proj);
-      VERIFY( iter == rx.end() );
-      VERIFY( *(iter-1) == 50 );
-      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter-1 );
-
-      iter = ranges::pop_heap(rx.begin(), iter-1, pred, proj);
-      VERIFY( iter+1 == rx.end() );
-      VERIFY( *(iter-1) == 49 );
-      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter-1 );
-
-      *(iter-1) = i;
-      iter = ranges::push_heap(rx.begin(), iter, pred, proj);
-      VERIFY( iter+1 == rx.end() );
-      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter );
-
-      *iter = 2*i;
-      iter = ranges::push_heap(rx.begin(), rx.end(), pred, proj);
-      VERIFY( iter == rx.end() );
-      VERIFY( ranges::is_heap_until(rx, pred, proj) == iter );
-
-      *(rx.begin()+1) *= -1;
-      VERIFY( !ranges::is_heap(rx, pred, proj) );
-      *(rx.begin()+1) *= -1;
-      VERIFY( ranges::is_heap(rx, pred, proj) );
-
-      iter = ranges::sort_heap(rx, pred, proj);
-      VERIFY( iter == rx.end() );
-      VERIFY( ranges::is_sorted(rx, pred, proj) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  int x[] = {1,2,3,4,5};
-  ranges::make_heap(x);
-  ranges::pop_heap(x);
-  x[4] = 7;
-  ranges::push_heap(x);
-  ok &= ranges::is_heap(x);
-  ok &= ranges::is_heap_until(x) == x+5;
-  ranges::sort_heap(x);
-  ok &= ranges::equal(x, (int[]){1,2,3,4,7});
-  return ok;
-}
-
-int
-main()
-{
-  test01<test_range>();
-  test01<test_container>();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/includes/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/includes/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/includes/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/includes/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5,6,7};
-  int y[] = {2,4,6};
-  test_range<int, input_iterator_wrapper> rx(x), ry(y);
-
-  VERIFY( ranges::includes(rx, ry) );
-
-  rx.bounds.first = x;
-  ry.bounds.first = y;
-  VERIFY( ranges::includes(rx, ry,
-			   ranges::greater{},
-			   std::negate<>{},
-			   std::negate<>{}) );
-
-  test_container<int, forward_iterator_wrapper> cx(x), cy(y);
-  VERIFY( ranges::includes(cx.begin(), cx.end(),
-			   cy.begin(), cy.end(),
-			   {},
-			   [] (int a) { return a+1; },
-			   [] (int a) { return a+2; }) );
-
-  VERIFY( ranges::includes(x, x+1, y, y) );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  ok &= ranges::includes((int[]){1,2,3},
-			 (int[]){1});
-  ok &= !ranges::includes((int[]){1,2,3},
-			  (int[]){1,2,3,4});
-  return true;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/inplace_merge/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/inplace_merge/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/inplace_merge/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/inplace_merge/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5};
-  for (int i = 0; i <= 5; i++)
-    for (int j = 0; j <= 5; j++)
-      {
-	std::vector<int> v(x, x+i);
-	v.insert(v.end(), x, x+j);
-	ranges::sort(v);
-
-	test_range<int, bidirectional_iterator_wrapper> rz(&v[0], &v[0]+i+j);
-	auto result = ranges::inplace_merge(rz, next(ranges::begin(rz), i));
-	VERIFY( result == rz.end() );
-
-	VERIFY( ranges::is_sorted(rz) );
-      }
-}
-
-void
-test02()
-{
-  struct X { int i, j; };
-  X x[] = { {1, 1}, {3, 4}, {5, 5}, {2, 2}, {2, 3} };
-  auto comp = ranges::greater{};
-  auto proj = [] (X a) { return -a.i; };
-  ranges::inplace_merge(x, x+3, x+5, comp, proj);
-  VERIFY( ranges::is_sorted(x, {}, &X::i) );
-  VERIFY( ranges::is_sorted(x, {}, &X::j) );
-}
-
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_partitioned/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_partitioned/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_partitioned/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_partitioned/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {2,4,6,1,3,5};
-  test_container<int, forward_iterator_wrapper> cx(x);
-  VERIFY( ranges::is_partitioned(cx, [] (int a) { return a%2==0; }) );
-
-  test_range<int, input_iterator_wrapper> rx(x);
-  VERIFY( ranges::is_partitioned(rx,
-				 [] (int a) { return a%2==1; },
-				 [] (int a) { return a+1; }) );
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1,2,3,4,5,6,1};
-  return (ranges::is_partitioned(x, x+6, [] (int a) { return a<=2; })
-	  && !ranges::is_partitioned(x, x+7, [] (int a) { return a<=2; }));
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_permutation/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_permutation/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_permutation/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_permutation/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,85 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  int x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  int y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };
-
-  VERIFY( ranges::is_permutation(x, x+6, y, y+6) );
-  VERIFY( !ranges::is_permutation(x, x+6, y, y+5) );
-
-  test_container<int, forward_iterator_wrapper> cx(x), cy(y), cz(z);
-  test_range<int, forward_iterator_wrapper> rx(x), ry(y), rz(z);
-  VERIFY( ranges::is_permutation(cx, ry) );
-  VERIFY( !ranges::is_permutation(rx, cz) );
-  VERIFY( ranges::is_permutation(rx, cy) );
-  VERIFY( !ranges::is_permutation(cx, rz) );
-}
-
-void
-test02()
-{
-  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  static constexpr X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  static constexpr int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };
-  static_assert(ranges::is_permutation(x, y, {}, &X::i, &X::i));
-  static_assert(!ranges::is_permutation(x, z, {}, &X::i));
-  static_assert(!ranges::is_permutation(z, y, {}, {}, &X::i));
-}
-
-void
-test03()
-{
-  int x[] = { 1, 2, 3, 4 };
-  int y[] = { 1, 2, 3, 3 };
-  test_container<int, bidirectional_iterator_wrapper> cx(x);
-  do
-    do
-      {
-	VERIFY( ranges::is_permutation(cx, x) );
-	VERIFY( !ranges::is_permutation(y, cx) );
-      } while (std::next_permutation(y, y+4));
-  while (std::next_permutation(std::begin(cx), std::end(cx)));
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_sorted/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_sorted/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_sorted/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_sorted/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {3,4,5,1};
-  test_container<int, forward_iterator_wrapper> cx(x);
-  VERIFY( ranges::is_sorted(cx.begin(), ranges::next(cx.begin(), 3)) );
-  VERIFY( !ranges::is_sorted(cx) );
-  VERIFY( !ranges::is_sorted(cx, ranges::greater{}) );
-  VERIFY( ranges::is_sorted(cx, {}, [] (int a) { return 0; }) );
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4,5};
-  test_range<int, forward_iterator_wrapper> rx(x);
-  VERIFY( ranges::is_sorted(rx) );
-  VERIFY( !ranges::is_sorted(ranges::begin(rx),
-			     next(ranges::begin(rx), 2),
-			     ranges::greater{}) );
-}
-
-constexpr bool
-test03()
-{
-  int x[] = { 1,2 };
-  return (ranges::is_sorted(x)
-	  && ranges::is_sorted(x, x) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_sorted_until/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_sorted_until/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/is_sorted_until/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/is_sorted_until/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,72 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {3,4,5,1};
-  test_container<int, forward_iterator_wrapper> cx(x);
-  VERIFY( ranges::is_sorted_until(cx.begin(),
-				  ranges::next(cx.begin(), 3))
-	  == ranges::next(cx.begin(), 3) );
-  VERIFY( ranges::is_sorted_until(cx) == ranges::next(cx.begin(), 3) );
-  VERIFY( ranges::is_sorted_until(cx, ranges::greater{})
-	  == ranges::next(cx.begin(), 1) );
-  VERIFY( ranges::is_sorted_until(cx, {}, [] (int a) { return 0; })
-	  == cx.end() );
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4,5};
-  test_range<int, forward_iterator_wrapper> rx(x);
-  VERIFY( ranges::is_sorted_until(rx) == ranges::end(rx) );
-  VERIFY( ranges::is_sorted_until(ranges::begin(rx),
-				  next(ranges::begin(rx), 2),
-				  ranges::greater{})
-	  == next(ranges::begin(rx), 1) );
-}
-
-constexpr bool
-test03()
-{
-  int x[] = { 1,2 };
-  return (ranges::is_sorted_until(x) == x+2
-	  && ranges::is_sorted_until(x, x) == x );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,164 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  char y[] = {1, 2, 3, 5};
-  long z[] = {1, 2, 3, 4, 5, 6};
-
-    {
-      test_range<int, input_iterator_wrapper> rx(x);
-      test_range<char, input_iterator_wrapper> ry(y);
-      test_range<long, input_iterator_wrapper> rz(z);
-
-      VERIFY( ranges::lexicographical_compare(rx, ry) );
-      rx.bounds.first = x;
-      ry.bounds.first = y;
-      VERIFY( !ranges::lexicographical_compare(ry, rx) );
-    }
-
-  test_range<int, forward_iterator_wrapper> rx(x);
-  test_range<char, forward_iterator_wrapper> ry(y);
-  test_range<long, forward_iterator_wrapper> rz(z);
-
-  VERIFY( ranges::lexicographical_compare(rx, rz) );
-  VERIFY( !ranges::lexicographical_compare(rz, rx) );
-
-  VERIFY( !ranges::lexicographical_compare(rx, rx) );
-  VERIFY( ranges::lexicographical_compare(rx, rx, {}, std::negate<>{}) );
-  VERIFY( ranges::lexicographical_compare(rx, rx, std::greater{},
-					  {}, std::negate<>{}) );
-
-  VERIFY( !ranges::lexicographical_compare(rx, ry, {},
-					   std::negate<>{},
-					   std::negate<>{}) );
-  VERIFY( ranges::lexicographical_compare(ry, rx, {},
-					  std::negate<>{},
-					  std::negate<>{}) );
-
-  VERIFY( ranges::lexicographical_compare(rx, rz, ranges::greater{}) );
-  VERIFY( !ranges::lexicographical_compare(rz, rx, ranges::greater{}) );
-
-  VERIFY( ranges::lexicographical_compare(rx, ry, ranges::greater{},
-					  std::negate<>{},
-					  std::negate<>{}) );
-  VERIFY( !ranges::lexicographical_compare(ry, rx, ranges::greater{},
-					   std::negate<>{},
-					   std::negate<>{}) );
-}
-
-void
-test02()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  int y[] = {1, 2, 3, 5};
-  int z[] = {1, 2, 3, 4, 5, 6};
-
-  VERIFY( ranges::lexicographical_compare(x, y) );
-  VERIFY( !ranges::lexicographical_compare(y, x) );
-
-  VERIFY( ranges::lexicographical_compare(x, z) );
-  VERIFY( !ranges::lexicographical_compare(z, x) );
-
-  VERIFY( !ranges::lexicographical_compare(x, x) );
-
-  VERIFY( !ranges::lexicographical_compare(x, y, {},
-					   std::negate<>{},
-					   std::negate<>{}) );
-  VERIFY( ranges::lexicographical_compare(y, x, {},
-					  std::negate<>{},
-					  std::negate<>{}) );
-
-  VERIFY( ranges::lexicographical_compare(x, z, ranges::greater{}) );
-  VERIFY( !ranges::lexicographical_compare(z, x, ranges::greater{}) );
-
-  VERIFY( ranges::lexicographical_compare(x, y, ranges::greater{},
-					  std::negate<>{},
-					  std::negate<>{}) );
-  VERIFY( !ranges::lexicographical_compare(y, x, ranges::greater{},
-					   std::negate<>{},
-					   std::negate<>{}) );
-}
-
-void
-test03()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  int y[] = {1, 2, 5, 3};
-  int z[] = {1, 2, 3, 5};
-
-  do
-    {
-      VERIFY( ranges::lexicographical_compare(x, y) );
-      VERIFY( !ranges::lexicographical_compare(x, y, ranges::greater{}) );
-      VERIFY( !ranges::lexicographical_compare(y, x) );
-      VERIFY( ranges::lexicographical_compare(y, x, ranges::greater{}) );
-
-      test_container<int, forward_iterator_wrapper> cy(y);
-      VERIFY( ranges::lexicographical_compare(x, cy) );
-      VERIFY( !ranges::lexicographical_compare(x, cy, ranges::greater{}) );
-      VERIFY( !ranges::lexicographical_compare(cy, x) );
-      VERIFY( ranges::lexicographical_compare(cy, x, ranges::greater{}) );
-
-      test_container<int, forward_iterator_wrapper> cz(z);
-      VERIFY( ranges::lexicographical_compare(cz.begin(), cz.end(),
-					      cy.begin(), cy.end()) );
-      VERIFY( !ranges::lexicographical_compare(cy.begin(), cy.end(),
-					       cz.begin(), cz.end()) );
-
-      std::vector<int> vx(x, x+5), vy(y, y+5);
-      VERIFY( ranges::lexicographical_compare(vx, vy) );
-      VERIFY( !ranges::lexicographical_compare(vx, vy, ranges::greater{}) );
-      VERIFY( !ranges::lexicographical_compare(vy, vx) );
-      VERIFY( ranges::lexicographical_compare(vy, vx, ranges::greater{}) );
-    } while (ranges::next_permutation(y).found);
-}
-
-constexpr bool
-test04()
-{
-  int x[] = {1};
-  int y[] = {1};
-  return (ranges::lexicographical_compare((int[]){1,2,3,5},
-					  (int[]){1,2,4})
-	  && !ranges::lexicographical_compare(x, x, y, y));
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  static_assert(test04());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/lower_bound/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/lower_bound/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/lower_bound/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/lower_bound/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1, 2, 3, 4, 5, 5, 6, 7};
-  for (unsigned i = 0; i < 5; i++)
-    for (unsigned j = 5; j < 8; j++)
-      {
-	test_container<int, forward_iterator_wrapper> cx(x);
-	auto result = ranges::lower_bound(std::next(cx.begin(), i),
-					  std::next(cx.begin(), j),
-					  4, {}, [] (int a) { return a-1; });
-	VERIFY( result.ptr == x+4 );
-      }
-
-  ranges::reverse(x);
-  test_range<int, forward_iterator_wrapper> rx(x);
-  auto result = ranges::lower_bound(rx, 5, ranges::greater{},
-				    [] (int a) { return a+1; });
-  VERIFY( result.ptr == x+4 );
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  return (ranges::lower_bound(x, 6) == x+5
-	  && ranges::lower_bound(x, x, 6) == x
-	  && ranges::lower_bound(x, 1) == x);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/max/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/max/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/max/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/max/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i, j;
-};
-
-void
-test01()
-{
-  VERIFY( ranges::max(1, 2) == 2);
-  VERIFY( ranges::max(2, 1) == 2);
-  VERIFY( ranges::max(1, 2, ranges::greater{}) == 1);
-  VERIFY( ranges::max(1, 2, ranges::greater{}, std::negate<>{}) == 2);
-  VERIFY( ranges::max(1, 2, {}, std::negate<>{}) == 1);
-  VERIFY( ranges::max(X{1,2}, X{1,3}, {}, &X::i).j == 2 );
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4};
-  do
-    {
-      test_range<int, input_iterator_wrapper> cx(x);
-      VERIFY( ranges::max(cx) == 4 );
-      cx.bounds.first = x;
-      VERIFY( ranges::max(cx, ranges::greater{}) == 1 );
-      cx.bounds.first = x;
-      VERIFY( ranges::max(cx, {}, std::negate<>{}) == 1);
-      cx.bounds.first = x;
-      VERIFY( ranges::max(cx, ranges::greater{}, std::negate<>{}) == 4 );
-    } while (ranges::next_permutation(x).found);
-
-  constexpr X y[] = {{0,5},{1,2},{1,3}};
-  static_assert(ranges::max(y, {}, &X::i).j == 2);
-}
-
-void
-test03()
-{
-  VERIFY( ranges::max({2,3,1,4}) == 4 );
-  VERIFY( ranges::max({2,3,1,4}, ranges::greater{}) == 1 );
-  VERIFY( ranges::max({2,3,1,4}, {}, std::negate<>{}) == 1 );
-  VERIFY( ranges::max({2,3,1,4}, ranges::greater{}, std::negate<>{}) == 4 );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/max_element/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/max_element/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/max_element/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/max_element/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i, j;
-};
-
-void
-test01()
-{
-  int x[] = {1,2,3,4};
-  do
-    {
-      test_range<int, forward_iterator_wrapper> cx(x);
-      VERIFY( *ranges::max_element(cx) == 4 );
-      VERIFY( *ranges::max_element(cx, ranges::greater{}) == 1 );
-      VERIFY( *ranges::max_element(cx, {}, std::negate<>{}) == 1);
-      VERIFY( *ranges::max_element(cx, ranges::greater{}, std::negate<>{}) == 4 );
-    } while (ranges::next_permutation(x).found);
-
-  test_container<int, forward_iterator_wrapper> cx(x);
-  VERIFY( ranges::max_element(cx.begin(), cx.begin()) == cx.begin() );
-
-  constexpr X y[] = {{0,5},{1,2},{1,3}};
-  static_assert(ranges::max_element(y, y+3, {}, &X::i)->j == 2);
-}
-
-int
-main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/merge/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/merge/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/merge/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/merge/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5};
-  for (int i = 0; i <= 5; i++)
-    for (int j = 0; j <= 5; j++)
-      {
-	int z[10];
-	test_range<int, input_iterator_wrapper> rx(x, x+i), ry(x, x+j);
-	test_range<int, output_iterator_wrapper> rz(z, z+i+j);
-	auto [in1,in2,out] = ranges::merge(rx, ry, rz.begin());
-	VERIFY( in1 == rx.end() );
-	VERIFY( in2 == ry.end() );
-	VERIFY( out == rz.end() );
-
-	std::vector<int> v(x, x+i);
-	v.insert(v.end(), x, x+j);
-	ranges::sort(v);
-
-	VERIFY( ranges::equal(v.begin(), v.end(), z, z+i+j) );
-      }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {-1,-3,-5};
-  int y[] = {2,4,6};
-  int z[6];
-  ranges::merge(x, x+3, y, y+3, z,
-		ranges::greater{}, {}, [] (int a) { return -a; });
-
-  const int w[6] = {-1, 2, -3, 4, -5, 6};
-  return ranges::equal(w, z);
-}
-
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/min/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/min/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/min/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/min/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i, j;
-};
-
-void
-test01()
-{
-  VERIFY( ranges::min(1, 2) == 1);
-  VERIFY( ranges::min(2, 1) == 1);
-  VERIFY( ranges::min(1, 2, ranges::greater{}) == 2);
-  VERIFY( ranges::min(1, 2, ranges::greater{}, std::negate<>{}) == 1);
-  VERIFY( ranges::min(1, 2, {}, std::negate<>{}) == 2);
-  VERIFY( ranges::min(X{1,2}, X{1,3}, {}, &X::i).j == 2 );
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4};
-  do
-    {
-      test_range<int, input_iterator_wrapper> cx(x);
-      VERIFY( ranges::min(cx) == 1 );
-      cx.bounds.first = x;
-      VERIFY( ranges::min(cx, ranges::greater{}) == 4 );
-      cx.bounds.first = x;
-      VERIFY( ranges::min(cx, {}, std::negate<>{}) == 4);
-      cx.bounds.first = x;
-      VERIFY( ranges::min(cx, ranges::greater{}, std::negate<>{}) == 1 );
-    } while (ranges::next_permutation(x).found);
-
-  constexpr X y[] = {{5,0},{1,2},{1,3}};
-  static_assert(ranges::min(y, {}, &X::i).j == 2);
-}
-
-void
-test03()
-{
-  VERIFY( ranges::min({2,3,1,4}) == 1 );
-  VERIFY( ranges::min({2,3,1,4}, ranges::greater{}) == 4 );
-  VERIFY( ranges::min({2,3,1,4}, {}, std::negate<>{}) == 4 );
-  VERIFY( ranges::min({2,3,1,4}, ranges::greater{}, std::negate<>{}) == 1 );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/min_element/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/min_element/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/min_element/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/min_element/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i, j;
-};
-
-void
-test01()
-{
-  int x[] = {1,2,3,4};
-  do
-    {
-      test_range<int, forward_iterator_wrapper> cx(x);
-      VERIFY( *ranges::min_element(cx) == 1 );
-      VERIFY( *ranges::min_element(cx, ranges::greater{}) == 4 );
-      VERIFY( *ranges::min_element(cx, {}, std::negate<>{}) == 4);
-      VERIFY( *ranges::min_element(cx, ranges::greater{}, std::negate<>{}) == 1 );
-    } while (ranges::next_permutation(x).found);
-
-  test_container<int, forward_iterator_wrapper> cx(x);
-  VERIFY( ranges::min_element(cx.begin(), cx.begin()) == cx.begin() );
-
-  constexpr X y[] = {{5,0},{1,2},{1,3}};
-  static_assert(ranges::min_element(y, y+3, {}, &X::i)->j == 2);
-}
-
-int
-main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-template<typename T1, typename T2>
-constexpr bool
-operator==(const ranges::minmax_result<T1>& lhs,
-	   const ranges::minmax_result<T2>& rhs)
-{
-  return (lhs.min == rhs.min
-	  && rhs.max == rhs.max);
-}
-
-
-struct X
-{
-  int i, j;
-};
-
-using res_t = ranges::minmax_result<int>;
-
-void
-test01()
-{
-  VERIFY( ranges::minmax(1, 2) == res_t(1,2) );
-  VERIFY( ranges::minmax(2, 1) == res_t(1,2) );
-  VERIFY( ranges::minmax(1, 2, ranges::greater{}) == res_t(2,1) );
-  VERIFY( ranges::minmax(1, 2, ranges::greater{}, std::negate<>{}) == res_t(1,2) );
-  VERIFY( ranges::minmax(1, 2, {}, std::negate<>{}) == res_t(2,1) );
-  VERIFY( ranges::minmax(X{1,2}, X{1,3}, {}, &X::i).min.j == 2 );
-  VERIFY( ranges::minmax(X{1,2}, X{1,3}, {}, &X::i).max.j == 3 );
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4};
-  do
-    {
-      test_range<int, input_iterator_wrapper> cx(x);
-      VERIFY( ranges::minmax(cx) == res_t(1,4) );
-      cx.bounds.first = x;
-      VERIFY( ranges::minmax(cx, ranges::greater{}) == res_t(4,1) );
-      cx.bounds.first = x;
-      VERIFY( ranges::minmax(cx, {}, std::negate<>{}) == res_t(4,1));
-      cx.bounds.first = x;
-      VERIFY( ranges::minmax(cx, ranges::greater{}, std::negate<>{})
-	      == res_t(1,4) );
-    } while (ranges::next_permutation(x).found);
-
-  constexpr X y[] = {{1,5},{1,2},{1,3}};
-  static_assert(ranges::minmax(y, {}, &X::i).min.j == 5);
-  static_assert(ranges::minmax(y, {}, &X::i).max.j == 3);
-}
-
-void
-test03()
-{
-  VERIFY( ranges::minmax({2,3,1,4}) == res_t(1,4) );
-  VERIFY( ranges::minmax({2,3,1,4}, ranges::greater{}) == res_t(4,1) );
-  VERIFY( ranges::minmax({2,3,1,4}, {}, std::negate<>{}) == res_t(4,1) );
-  VERIFY( ranges::minmax({2,3,1,4}, ranges::greater{}, std::negate<>{})
-	  == res_t(1,4) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i, j;
-};
-
-void
-test01()
-{
-  int x[] = {1,2,3,4};
-  do
-    {
-      test_range<int, forward_iterator_wrapper> cx(x);
-      VERIFY( *ranges::minmax_element(cx).min == 1 );
-      VERIFY( *ranges::minmax_element(cx).max == 4 );
-      VERIFY( *ranges::minmax_element(cx, ranges::greater{}).min == 4 );
-      VERIFY( *ranges::minmax_element(cx, ranges::greater{}).max == 1 );
-      VERIFY( *ranges::minmax_element(cx, {}, std::negate<>{}).min == 4);
-      VERIFY( *ranges::minmax_element(cx, {}, std::negate<>{}).max == 1);
-      VERIFY( *ranges::minmax_element(cx, ranges::greater{}, std::negate<>{}).min
-	      == 1 );
-      VERIFY( *ranges::minmax_element(cx, ranges::greater{}, std::negate<>{}).max
-	      == 4 );
-    } while (ranges::next_permutation(x).found);
-
-  test_container<int, forward_iterator_wrapper> cx(x);
-  VERIFY( ranges::minmax_element(cx.begin(), cx.begin()).min == cx.begin() );
-  VERIFY( ranges::minmax_element(cx.begin(), cx.begin()).max == cx.begin() );
-
-  constexpr X y[] = {{1,5},{1,2},{1,3}};
-  static_assert(ranges::minmax_element(y, y+3, {}, &X::i).min->j == 5);
-  static_assert(ranges::minmax_element(y, y+3, {}, &X::i).max->j == 3);
-}
-
-int
-main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/mismatch/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/mismatch/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/mismatch/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/mismatch/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X xa[] = { {1}, {2}, {3}, {4}, {5}, {6} };
-  X xb[] = { {1}, {2}, {3}, {3}, {5}, {6} };
-  auto res = ranges::mismatch(xa, xa+6, xb, xb+6, {}, &X::i, &X::i);
-  VERIFY( res.in1 == xa+3 && res.in2 == xb+3 );
-
-  test_container<X, forward_iterator_wrapper> ca(xa);
-  test_container<X, forward_iterator_wrapper> cb(xb);
-  auto res2 = ranges::mismatch(ca, cb, {}, &X::i, &X::i);
-  VERIFY( res2.in1->i == 4 && res2.in2->i == 3 );
-  res2 = ranges::mismatch(ca, ca, {}, &X::i, &X::i);
-  VERIFY( res2.in1 == ranges::end(ca) && res2.in2 == ranges::end(ca) );
-
-  test_range<X, input_iterator_wrapper> ra(xa);
-  test_range<X, input_iterator_wrapper> rb(xb);
-  auto res3 = ranges::mismatch(ra, rb, {}, &X::i, &X::i);
-  VERIFY( res3.in1->i == 4 && res3.in2->i == 3 );
-
-  test_range<X, input_iterator_wrapper> ra2(xa);
-  ra.bounds.first = xa;
-  res3 = ranges::mismatch(ra, ra2, {}, &X::i, &X::i);
-  VERIFY( res3.in1 == ranges::end(ra) && res3.in2 == ranges::end(ra2) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y ya[] = { {1,2}, {2,4}, {3,6}, {1,6} };
-  static constexpr Y yb[] = { {2,1}, {4,2}, {4,2}, {7,1} };
-  static_assert(ranges::mismatch(ya, yb, {}, &Y::i, &Y::j).in1 == ya+2);
-  static_assert(ranges::mismatch(ya, yb, {}, &Y::i, &Y::j).in2 == yb+2);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/move/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,203 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-  int moved = 0;
-
-  constexpr X() : i(0) { }
-  constexpr X(int a) : i(a) { }
-
-  constexpr X(const X&) = delete;
-  constexpr X& operator=(const X&) = delete;
-
-  constexpr X(X&& other)
-  {
-    *this = std::move(other);
-  }
-
-  constexpr X&
-  operator=(X&& other)
-  {
-    other.moved++;
-    i = other.i;
-    return *this;
-  }
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  { return a.i == b.i; }
-};
-
-void
-test01()
-{
-    {
-      X x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      X y[7] = { 0, 0, 0, 0, 0, 0, 0 };
-      X z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      auto [in, out] = ranges::move(x, y);
-      VERIFY( ranges::equal(x, y) && in == x+7 && out == y+7 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      int x[3] = { 1, 2, 3 };
-      char y[4] = { 0 };
-      int z[3] = { 1, 2, 3 };
-      test_container<int, forward_iterator_wrapper> cx(x);
-      test_container<char, forward_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::move(cx, cy.begin());
-      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      char x[3] = { 1, 2, 3 };
-      int y[4] = { 0 };
-      int z[3] = { 1, 2, 3 };
-      test_range<char, input_iterator_wrapper> cx(x);
-      test_range<int, output_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::move(cx, ranges::begin(cy));
-      VERIFY( ranges::equal(x, x+3, y, y+3) && in.ptr == x+3 && out.ptr == y+3 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x= {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::move(x, ranges::begin(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::move(x, ranges::begin(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::move(make_reverse_iterator(x.end()),
-				   make_reverse_iterator(x.begin()),
-				   make_reverse_iterator(y.end()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::move(make_reverse_iterator(x.end()),
-				   make_reverse_iterator(x.begin()),
-				   make_reverse_iterator(y.end()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-}
-
-void
-test02()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10} };
-  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  X z[] = { {2}, {2}, {6}, {8}, {10} };
-  auto [in, out] = ranges::move(x, y);
-  VERIFY( ranges::equal(x, x+5, y, y+5) );
-  VERIFY( in == x+5 );
-  VERIFY( out == y+5 );
-  VERIFY( y[5].i == 2 );
-  VERIFY( ranges::equal(x, z) );
-  VERIFY( ranges::count(x, 1, &X::moved) == 5 );
-  VERIFY( ranges::count(y, 0, &X::moved) == 6 );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  X x[] = { {2}, {2}, {6}, {8}, {10} };
-  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  X z[] = { {2}, {2}, {6}, {8}, {10} };
-  auto [in, out] = ranges::move(x, y);
-  ok &= ranges::equal(x, x+5, y, y+5);
-  ok &= (in == x+5);
-  ok &= (out == y+5);
-  ok &= (y[5].i == 2);
-  ok &= ranges::equal(x, z);
-  ok &= ranges::count(x, 1, &X::moved) == 5;
-  ok &= ranges::count(y, 0, &X::moved) == 6;
-  return ok;
-}
-
-void
-test04()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10} };
-  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  X z[] = { {2}, {2}, {6}, {8}, {10} };
-  test_range<X, input_iterator_wrapper> rx(x);
-  auto [in, out] = ranges::move(std::move_iterator{ranges::begin(rx)},
-				std::move_sentinel{ranges::end(rx)},
-				ranges::begin(y));
-  VERIFY( ranges::equal(x, x+5, y, y+5) );
-  VERIFY( std::move(in).base().ptr == x+5 );
-  VERIFY( out == y+5 );
-  VERIFY( y[5].i == 2 );
-  VERIFY( ranges::equal(x, z) );
-  VERIFY( ranges::count(x, 1, &X::moved) == 5 );
-  VERIFY( ranges::count(y, 0, &X::moved) == 6 );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-  test04();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/move_backward/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/move_backward/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/move_backward/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/move_backward/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,170 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-  int moved = 0;
-
-  constexpr X() : i(0) { }
-  constexpr X(int a) : i(a) { }
-
-  constexpr X(const X&) = delete;
-  constexpr X& operator=(const X&) = delete;
-
-  constexpr X(X&& other)
-  {
-    *this = std::move(other);
-  }
-
-  constexpr X&
-  operator=(X&& other)
-  {
-    other.moved++;
-    i = other.i;
-    return *this;
-  }
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  { return a.i == b.i; }
-};
-
-void
-test01()
-{
-    {
-      X x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      X y[7] = { 0, 0, 0, 0, 0, 0, 0 };
-      X z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      auto [in, out] = ranges::move_backward(x, y+7);
-      VERIFY( ranges::equal(x, y) && in == x+7 && out == y );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      int x[3] = { 1, 2, 3 };
-      char y[4] = { 0 };
-      int z[3] = { 1, 2, 3 };
-      test_container<int, bidirectional_iterator_wrapper> cx(x);
-      test_container<char, bidirectional_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::move_backward(cx, cy.end());
-      VERIFY( ranges::equal(x, x+3, y+1, y+4) && in.ptr == x+3 && out.ptr == y+1 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x= {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::move_backward(x, ranges::end(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in, out] = ranges::move_backward(x, ranges::end(y));
-      VERIFY( in.base() == x.data()+3 );
-      VERIFY( out.base() == y.data() );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<int> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::move_backward(make_reverse_iterator(x.end()),
-					    make_reverse_iterator(x.begin()),
-					    make_reverse_iterator(y.begin()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-
-    {
-      std::vector<char> x = {1,2,3};
-      std::vector<int> y(3);
-      const int z[3] = { 1, 2, 3 };
-      auto [in,out] = ranges::move_backward(make_reverse_iterator(x.end()),
-					    make_reverse_iterator(x.begin()),
-					    make_reverse_iterator(y.begin()));
-      VERIFY( in.base().base() == x.data()+3 );
-      VERIFY( out.base().base() == y.data()+3 );
-      VERIFY( ranges::equal(y, z) && ranges::equal(x, z) );
-    }
-}
-
-void
-test02()
-{
-  X x[] = { {2}, {2}, {6}, {8}, {10} };
-  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  const X z[] = { {2}, {2}, {6}, {8}, {10} };
-  auto [in, out] = ranges::move_backward(x, ranges::end(y));
-  VERIFY( ranges::equal(x, x+5, y+1, y+6) );
-  VERIFY( in == x+5 );
-  VERIFY( out == y+1 );
-  VERIFY( y[0].i == 2 );
-  VERIFY( ranges::equal(x, z) );
-  VERIFY( ranges::count(x, 1, &X::moved) == 5 );
-  VERIFY( ranges::count(y, 0, &X::moved) == 6 );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  X x[] = { {2}, {2}, {6}, {8}, {10} };
-  X y[] = { {2}, {6}, {8}, {10}, {11}, {2} };
-  const X z[] = { {2}, {2}, {6}, {8}, {10} };
-  auto [in, out] = ranges::move_backward(x, ranges::end(y));
-  ok &= ranges::equal(x, x+5, y+1, y+6);
-  ok &= (in == x+5);
-  ok &= (out == y+1);
-  ok &= (y[0].i == 2);
-  ok &= ranges::equal(x, z);
-  ok &= ranges::count(x, 1, &X::moved) == 5;
-  ok &= ranges::count(y, 0, &X::moved) == 6;
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  int y[] = {1, 2, 3, 4, 5};
-
-  for (int i = 0; i <= 5; i++)
-    {
-      test_container<int, bidirectional_iterator_wrapper> cx(x, x+i);
-      test_container<int, bidirectional_iterator_wrapper> cy(y, y+i);
-      for (int j = 0; ; j++)
-	{
-	  auto found1 = std::next_permutation(cx.begin(), cx.end());
-	  auto [found2,last] = ranges::next_permutation(cy.begin(), cy.end());
-	  VERIFY( found1 == found2 );
-	  VERIFY( ranges::equal(cx, cy) );
-	  if (!found2)
-	    break;
-	}
-    }
-}
-
-void
-test02()
-{
-  int x[] = {5, 4, 3, 2, 1};
-  test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto [found,last] = ranges::next_permutation(rx, ranges::greater{});
-  VERIFY( found && last == rx.end() );
-  VERIFY( last == rx.end() );
-  VERIFY( ranges::equal(rx, (int[]){5,4,3,1,2}) );
-  ranges::next_permutation(rx, {}, [] (int a) { return -a; });
-  VERIFY( ranges::equal(rx, (int[]){5,4,2,3,1}) );
-
-  VERIFY( !ranges::next_permutation(x, x).found );
-  VERIFY( !ranges::next_permutation(x, x+1).found );
-}
-
-constexpr bool
-test03()
-{
-  int x[] = {1,2,3};
-  ranges::next_permutation(x);
-  return ranges::equal(x, (int[]){1,3,2});
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/none_of/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/none_of/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/none_of/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/none_of/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-struct XLess
-{
-  int val;
-  bool operator()(X& x) const { return x.i < val; }
-};
-
-struct ILess
-{
-  int val;
-  bool operator()(int& i) const { return i < val; }
-};
-
-template<typename T>
-struct NotZero
-{
-  bool operator()(T& t) const { return t != 0; }
-};
-
-void
-test01()
-{
-  X x[] = { {2}, {4}, {6}, {8}, {10}, {11} };
-
-  VERIFY( !ranges::none_of(x, x+6, XLess{3}) );
-  VERIFY( !ranges::none_of(x, x+6, ILess{3}, &X::i) );
-  VERIFY( ranges::none_of(x+1, x+6, XLess{3}) );
-  VERIFY( ranges::none_of(x+1, x+6, ILess{3}, &X::i) );
-  VERIFY( !ranges::none_of(x, XLess{5}) );
-  VERIFY( !ranges::none_of(x, ILess{5}, &X::i) );
-
-  test_container<X, forward_iterator_wrapper> c(x);
-  VERIFY( !ranges::none_of(c, NotZero<int>{}, &X::i) );
-
-  test_range<X, input_iterator_wrapper> r(x);
-  VERIFY( !ranges::none_of(r, NotZero<int>{}, &X::i) );
-  VERIFY( !ranges::none_of(r, NotZero<X* const>{}, [](X& x) { return &x; }) );
-}
-
-struct Y { int i; int j; };
-
-void
-test02()
-{
-  static constexpr Y y[] = { {1,2}, {2,4}, {3,6} };
-  static_assert(!ranges::none_of(y, [](int i) { return i%2 == 0; }, &Y::i));
-  static_assert(!ranges::none_of(y, [](const Y& y) { return y.i + y.j == 3; }));
-  static_assert(ranges::none_of(y, [](const Y& y) { return y.i == y.j; }));
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/nth_element/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/nth_element/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/nth_element/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/nth_element/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[50];
-  std::iota(x, x+50, 0);
-
-  auto pred = std::greater{};
-  auto proj = [] (int a) { return -a; };
-  for (int i = 0; i < 50; i++)
-    {
-      test_range<int, random_access_iterator_wrapper> rx(x);
-      std::ranlux48_base g(i);
-      ranges::shuffle(rx, g);
-
-      auto result = ranges::nth_element(rx, rx.begin()+i, pred, proj);
-      VERIFY( result == rx.end() );
-      VERIFY( x[i] == i );
-      for (int j = 0; j < i; j++)
-	for (int k = i; k < 50; k++)
-	  VERIFY( !pred(proj(x[k]), proj(x[j])) );
-
-      result = ranges::nth_element(rx, rx.begin()+i, pred);
-      VERIFY( result == rx.end() );
-      VERIFY( x[i] == 49-i );
-      for (int j = 0; j < i; j++)
-	for (int k = i; k < 50; k++)
-	  VERIFY( !pred(x[k], x[j]) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {5,2,1,3,4};
-  ranges::nth_element(x, x+3);
-  return x[3] == 4;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partial_sort/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partial_sort/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partial_sort/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partial_sort/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  for (unsigned size = 0; size < 50; ++size)
-    {
-      std::vector<int> vref(size);
-      std::iota(vref.begin(), vref.end(), 0);
-      std::vector<int> v1(vref), v2(vref);
-      test_container<int, random_access_iterator_wrapper> c
-	= {&v1[0], &v1[0] + size};
-      test_range<int, random_access_iterator_wrapper> r
-	= {&v2[0], &v2[0] + size};
-
-      std::ranlux48_base g1(size), g2(size + 1);
-      ranges::shuffle(c, g1);
-      ranges::shuffle(ranges::begin(r), ranges::end(r), g2);
-
-      for (unsigned middle = 0; middle < std::min(size, 10U); ++middle)
-	{
-	  auto res1 = ranges::partial_sort(c.begin(), c.begin()+middle, c.end(),
-					   {}, std::negate<>{});
-	  VERIFY( res1 == c.end() );
-
-	  auto res2 = ranges::partial_sort(r,
-					   ranges::begin(r)+middle,
-					   ranges::greater{});
-	  VERIFY( res2 == ranges::end(r) );
-
-	  VERIFY( ranges::equal(c.begin(), c.begin()+middle,
-				r.begin(), r.begin()+middle) );
-	  VERIFY( ranges::equal(c.begin(), c.begin()+middle,
-				vref.rbegin(), vref.rbegin()+middle) );
-	}
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = { 5,4,1,3,2 };
-  const int y[] = { 1,2,3 };
-  ranges::partial_sort(x, x+3, x+5);
-  return ranges::equal(x, x+3, y, y+3);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  for (unsigned size = 0; size < 50; ++size)
-    {
-      std::vector<int> vref(size);
-      std::iota(vref.begin(), vref.end(), 0);
-      std::vector<int> v1(vref), v2(vref);
-
-      std::ranlux48_base g1(size), g2(size + 1);
-      ranges::shuffle(v1, g1);
-      ranges::shuffle(v2, g2);
-
-      for (unsigned middle = 0; middle < 10; ++middle)
-	{
-	  test_container<int, forward_iterator_wrapper> c
-	    = {&v1[0], &v1[0] + size};
-	  test_range<int, input_iterator_wrapper> r
-	    = {&v2[0], &v2[0] + size};
-
-	  std::vector<int> o1(middle), o2(middle);
-	  test_range<int, random_access_iterator_wrapper> w1
-	    = {&o1[0], &o1[0]+middle};
-	  test_range<int, random_access_iterator_wrapper> w2
-	    = {&o2[0], &o2[0]+middle};
-
-	  auto [in1, out1] = ranges::partial_sort_copy(c.begin(), c.end(),
-						       w1.begin(), w1.end(),
-						       {},
-						       std::negate<>{},
-						       std::negate<>{});
-	  VERIFY( in1 == c.end() );
-	  VERIFY( out1 == w1.begin() + std::min(size, middle) );
-
-	  auto [in2,out2] = ranges::partial_sort_copy(r, w2, ranges::greater{});
-	  VERIFY( in2 == ranges::end(r) );
-	  VERIFY( out2 == w2.begin() + std::min(size, middle) );
-
-	  VERIFY( ranges::equal(w1.begin(), out1, w2.begin(), out2) );
-	  VERIFY( ranges::equal(w1.begin(), out1,
-				vref.rbegin(),
-				vref.rbegin()+(out1-w1.begin())) );
-	}
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = { 5,4,1,3,2 };
-  int w[3];
-  const int y[] = { 1,2,3 };
-  ranges::partial_sort_copy(x, x+5, w, w+3);
-  return ranges::equal(w, y);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partition/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partition/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partition/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partition/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-template<template<typename> typename wrapper>
-void
-test01()
-{
-    {
-      int x[] = {1,2,3,4,5,6,7,8,9,10};
-      test_container<int, wrapper> cx(x);
-      auto range = ranges::partition(cx, [] (int a) { return a%2==0; });
-      VERIFY( range.begin().ptr == x+5 );
-      VERIFY( range.end().ptr == x+10 );
-      VERIFY( ranges::is_partitioned(cx, [] (int a) { return a%2==0; }) );
-    }
-
-    {
-      int x[] = {1,2,3,4,5,6,7,8};
-      test_range<int, wrapper> rx(x);
-      auto range = ranges::partition(rx,
-				     [] (int a) { return a%2==0; },
-				     [] (int a) { return a+1; });
-      VERIFY( range.begin().ptr == x+4 );
-      VERIFY( range.end().ptr == x+8 );
-      VERIFY( ranges::is_partitioned(rx, [] (int a) { return a%2==1; }) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1,2,3,4,5,6,7,8,9,10};
-  auto range = ranges::partition(x, x+9, [] (int a) { return a < 100; });
-  return (range.begin() == x+9 && range.end() == x+9);
-}
-
-int
-main()
-{
-  test01<forward_iterator_wrapper>();
-  test01<bidirectional_iterator_wrapper>();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partition_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partition_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partition_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partition_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-    {
-      int x[] = {1,2,3,4,5,6,7,8,9,10,11};
-      int y[5], z[6];
-      test_container<int, forward_iterator_wrapper> cx(x);
-      test_container<int, forward_iterator_wrapper> cy(y), cz(z);
-      auto pred = [] (int a) { return a%2==0; };
-      auto [in,out_true,out_false]
-	= ranges::partition_copy(cx, cy.begin(), cz.begin(), pred);
-      VERIFY( in.ptr == x+11 );
-      VERIFY( out_true.ptr == y+5 );
-      VERIFY( out_false.ptr == z+6 );
-      VERIFY( ranges::all_of(cy, pred) );
-      VERIFY( ranges::none_of(cz, pred) );
-    }
-
-    {
-      int x[] = {1,2,3,4,5,6,7,8,9,10,11};
-      int y[6], z[5];
-      test_range<int, input_iterator_wrapper> cx(x);
-      test_range<int, output_iterator_wrapper> cy(y), cz(z);
-      auto pred = [] (int a) { return a%2==0; };
-      auto proj = [] (int a) { return a+1; };
-      auto [in,out_true,out_false]
-	= ranges::partition_copy(cx, cy.begin(), cz.begin(), pred, proj);
-      VERIFY( in.ptr == x+11 );
-      VERIFY( out_true.ptr == y+6 );
-      VERIFY( out_false.ptr == z+5 );
-      VERIFY( ranges::none_of(y, pred) );
-      VERIFY( ranges::all_of(z, pred) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1,2,3,4,5,6,7,8,9,10};
-  auto range = ranges::partition(x, x+9, [] (int a) { return a < 100; });
-  return (range.begin() == x+9 && range.end() == x+9);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partition_point/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partition_point/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/partition_point/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/partition_point/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  for (int k = 1; k <= 7; k++)
-    {
-      int x[] = {1,2,3,4,5,6,7};
-      test_container<int, forward_iterator_wrapper> cx(x);
-      auto pred = [&] (int a) { return a <= k; };
-      auto middle = ranges::partition_point(cx, pred);
-      VERIFY( middle.ptr == x+k );
-    }
-
-  for (int k = 1; k <= 8; k++)
-    {
-      int x[] = {1,2,3,4,5,6,7,8};
-      test_range<int, forward_iterator_wrapper> rx(x);
-      auto pred = [&] (int a) { return a > -k; };
-      auto proj = [] (int a) { return -a; };
-      auto middle = ranges::partition_point(rx, pred, proj);
-      VERIFY( middle.ptr == x+k-1 );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1,2,3,4,5};
-  return (ranges::partition_point(x, x+5, [] (int a) { return a < 6; }) == x+5
-	  && ranges::partition_point(x, x+5, [] (int a) { return a < 0; }) == x);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {5, 4, 3, 2, 1};
-  int y[] = {5, 4, 3, 2, 1};
-
-  for (int i = 0; i <= 5; i++)
-    {
-      test_container<int, bidirectional_iterator_wrapper> cx(x, x+i);
-      test_container<int, bidirectional_iterator_wrapper> cy(y, y+i);
-      for (int j = 0; ; j++)
-	{
-	  auto found1 = std::prev_permutation(cx.begin(), cx.end());
-	  auto [found2,last] = ranges::prev_permutation(cy.begin(), cy.end());
-	  VERIFY( found1 == found2 );
-	  VERIFY( ranges::equal(cx, cy) );
-	  if (!found2)
-	    break;
-	}
-    }
-}
-
-void
-test02()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto [found,last] = ranges::prev_permutation(rx, ranges::greater{});
-  VERIFY( found && last == rx.end() );
-  VERIFY( last == rx.end() );
-  VERIFY( ranges::equal(rx, (int[]){1,2,3,5,4}) );
-  ranges::prev_permutation(rx, {}, [] (int a) { return -a; });
-  VERIFY( ranges::equal(rx, (int[]){1,2,4,3,5}) );
-
-  VERIFY( !ranges::prev_permutation(x, x).found );
-  VERIFY( !ranges::prev_permutation(x, x+1).found );
-}
-
-constexpr bool
-test03()
-{
-  int x[] = {3,2,1};
-  ranges::prev_permutation(x);
-  return ranges::equal(x, (int[]){3,1,2});
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
-
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-};
-
-void
-test01()
-{
-  int x[5] = { 1, 2, 3, 4, 5 };
-  const int y[4] = { 1, 2, 4, 5 };
-  auto res = ranges::remove(x, 3);
-  VERIFY( res.begin() == x+4 && res.end() == x+5 );
-  VERIFY( ranges::equal(x, x+4, y, y+4) );
-}
-
-void
-test02()
-{
-  int x[1];
-  test_container<int, forward_iterator_wrapper> c(x, x);
-  auto res = ranges::remove(c, 1);
-  VERIFY( res.begin().ptr == x && res.end().ptr == x );
-}
-
-void
-test03()
-{
-  int x[1] = {1};
-  test_container<int, forward_iterator_wrapper> c(x);
-  auto res = ranges::remove(c, 0);
-  VERIFY( res.begin().ptr == x+1 && res.end().ptr == x+1 );
-  res = ranges::remove(c, 1);
-  VERIFY( res.begin().ptr == x && res.end().ptr == x+1 );
-}
-
-void
-test04()
-{
-  X x[8] = { {0}, {1}, {0}, {1}, {0}, {0}, {1}, {1} };
-  const int y[4] = { 0, 0, 0, 0 };
-  test_container<X, forward_iterator_wrapper> c(x);
-  auto res = ranges::remove(c, 1, &X::i);
-  VERIFY( res.begin().ptr == x+4 && res.end().ptr == x+8 );
-  VERIFY( ranges::equal(x, x+4, y, y+4, {}, &X::i) );
-}
-
-constexpr bool
-test05()
-{
-  int x[6] = { 3, 2, 3, 3, 5, 3 };
-  const int y[2] = { 2, 5 };
-  auto res = ranges::remove(x, 3);
-  return ranges::equal(x, res.begin(), y, y+2);
-}
-
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  test04();
-  static_assert(test05());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  {
-    return a.i == b.i;
-  }
-};
-
-void
-test01()
-{
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[4];
-      X z[4] = { {2}, {2}, {6}, {10} };
-      auto [in,out] = ranges::remove_copy(x, x+5, y, 8, &X::i);
-      VERIFY( in == x+5 && out == y+4 );
-      VERIFY( ranges::equal(y, z) );
-    }
-
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[5];
-      X z[5] = { {2}, {2}, {6}, {8}, {10} };
-      auto [in,out] = ranges::remove_copy(x, x+5, y, 11, &X::i);
-      VERIFY( in == x+5 && out == y+5 );
-      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {2} };
-      X y[3];
-      X z[3] = { {6}, {8}, {10} };
-      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);
-      auto [in, out] = ranges::remove_copy(cx, cy.begin(), 2, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(cy, cz) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[4];
-      const X z[4] = { {6}, {8}, {10}, {11} };
-      test_range<X, input_iterator_wrapper> cx(x);
-      test_range<X, output_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::remove_copy(cx, cy.begin(), 2, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(y, z) );
-    }
-}
-
-struct Y { int i; int j; };
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  Y x[3] = { {3,2}, {2,4}, {3,6} };
-  Y y[1];
-  Y z[1] = { {2,4} };
-  auto [in, out] = ranges::remove_copy(x, y, 3, &Y::i);
-  ok &= in == x+3;
-  ok &= out == y+1;
-  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);
-  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove_copy_if/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove_copy_if/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove_copy_if/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove_copy_if/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  {
-    return a.i == b.i;
-  }
-};
-
-void
-test01()
-{
-  auto is_negative_p = [] (int a) { return a < 0; };
-  auto is_two_p = [] (int a) { return a == 2; };
-
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {2}, {11} };
-      X y[2];
-      X z[2] = { {6}, {8} };
-      auto [in, out] = ranges::remove_copy_if(x, x+5, y, is_two_p, &X::i);
-      VERIFY( in == x+5 && out == y+2 );
-      VERIFY( ranges::equal(y, z) );
-    }
-
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[5];
-      X z[5] = { {2}, {2}, {6}, {8}, {10} };
-      auto [in, out] = ranges::remove_copy_if(x, x+5, y, is_negative_p, &X::i);
-      VERIFY( in == x+5 && out == y+5 );
-      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[4];
-      X z[4] = { {6}, {8}, {10}, {11} };
-      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);
-      auto [in, out] = ranges::remove_copy_if(cx, cy.begin(), is_two_p, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(cy, cz) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[4];
-      const X z[4] = { {6}, {8}, {10}, {11} };
-      test_range<X, input_iterator_wrapper> cx(x);
-      test_range<X, output_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::remove_copy_if(cx, cy.begin(), is_two_p, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(y, z) );
-    }
-}
-
-struct Y { int i; int j; };
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  Y x[3] = { {3,2}, {2,4}, {3,6} };
-  Y y[1];
-  Y z[1] = { {2,4} };
-  auto [in, out]
-    = ranges::remove_copy_if(x, y, [] (int a) { return a%2 == 1; }, &Y::i);
-  ok &= in == x+3;
-  ok &= out == y+1;
-  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);
-  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove_if/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove_if/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/remove_if/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/remove_if/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-};
-
-void
-test01()
-{
-  int x[5] = { 1, 2, 3, 4, 5 };
-  const int y[4] = { 1, 2, 4, 5 };
-  auto res = ranges::remove_if(x, [] (int a) { return a == 3; });
-  VERIFY( res.begin() == x+4 && res.end() == x+5 );
-  VERIFY( ranges::equal(x, x+4, y, y+4) );
-}
-
-void
-test02()
-{
-  int x[1];
-  test_container<int, forward_iterator_wrapper> c(x, x);
-  auto res = ranges::remove_if(c, [] (int a) { return a == 1; });
-  VERIFY( res.begin().ptr == x && res.end().ptr == x );
-}
-
-void
-test03()
-{
-  int x[1] = {1};
-  test_container<int, forward_iterator_wrapper> c(x);
-  auto res = ranges::remove_if(c, [] (int a) { return a == 0; });
-  VERIFY( res.begin().ptr == x+1 && res.end().ptr == x+1 );
-  res = ranges::remove_if(c, [] (int a) { return a == 1; });
-  VERIFY( res.begin().ptr == x && res.end().ptr == x+1 );
-}
-
-void
-test04()
-{
-  X x[8] = { {0}, {1}, {0}, {1}, {0}, {0}, {1}, {1} };
-  const int y[4] = { 0, 0, 0, 0 };
-  test_range<X, forward_iterator_wrapper> c(x);
-  auto res = ranges::remove_if(c, [] (int a) { return a == 1; }, &X::i);
-  VERIFY( res.begin().ptr == x+4 && res.end().ptr == x+8 );
-  VERIFY( ranges::equal(x, x+4, y, y+4, {}, &X::i) );
-}
-
-constexpr bool
-test05()
-{
-  int x[6] = { 3, 2, 3, 3, 5, 3 };
-  const int y[2] = { 2, 5 };
-  auto res = ranges::remove_if(x, [] (int a) { return a == 3; });
-  return ranges::equal(x, res.begin(), y, y+2);
-}
-
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  test04();
-  static_assert(test05());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,104 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  {
-    return a.i == b.i;
-  }
-};
-
-void
-test01()
-{
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6] = { {2}, {2}, {6}, {9}, {10}, {11} };
-      auto res = ranges::replace(x, x+5, 8, X{9}, &X::i);
-      VERIFY( res == x+5 );
-      VERIFY( ranges::equal(x, y) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      auto res = ranges::replace(x, x+5, 7, X{9}, &X::i);
-      VERIFY( res == x+5 );
-      VERIFY( ranges::equal(x, y) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6] = { {7}, {7}, {6}, {8}, {10}, {11} };
-      test_container<X, forward_iterator_wrapper> cx(x), cy(y);
-      auto res = ranges::replace(cx, 2, X{7}, &X::i);
-      VERIFY( res == cx.end() );
-      VERIFY( ranges::equal(cx, cy) );
-    }
-
-    {
-      int x[6] = { {2}, {2}, {6}, {8}, {10}, {2} };
-      int y[6] = { {7}, {7}, {6}, {8}, {10}, {7} };
-      test_range<int, input_iterator_wrapper> rx(x), ry(y);
-      auto res = ranges::replace(rx, 2, 7);
-      VERIFY( res == rx.end() );
-
-      rx.bounds.first = x;
-      ry.bounds.first = y;
-      VERIFY( ranges::equal(rx, ry) );
-    }
-}
-
-struct Y { int i; int j; };
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  Y x[] = { {3,2}, {2,4}, {3,6} };
-  Y y[] = { {4,5}, {2,4}, {4,5} };
-  auto res = ranges::replace(x, 3, Y{4,5}, &Y::i);
-  ok &= res == x+3;
-  ok &= ranges::equal(x, y, {}, &Y::i, &Y::i);
-  ok &= ranges::equal(x, y, {}, &Y::j, &Y::j);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  {
-    return a.i == b.i;
-  }
-};
-
-void
-test01()
-{
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[5];
-      X z[5] = { {2}, {2}, {6}, {9}, {10} };
-      auto [in,out] = ranges::replace_copy(x, x+5, y, 8, X{9}, &X::i);
-      VERIFY( in == x+5 && out == y+5 );
-      VERIFY( ranges::equal(y, z) );
-    }
-
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[5];
-      X z[5] = { {2}, {2}, {6}, {8}, {10} };
-      auto [in,out] = ranges::replace_copy(x, x+5, y, 7, X{9}, &X::i);
-      VERIFY( in == x+5 && out == y+5 );
-      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6];
-      X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };
-      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);
-      auto [in, out] = ranges::replace_copy(cx, cy.begin(), 2, X{7}, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(cy, cz) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6];
-      const X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };
-      test_range<X, input_iterator_wrapper> cx(x);
-      test_range<X, output_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::replace_copy(cx, cy.begin(), 2, X{7}, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(y, z) );
-    }
-}
-
-struct Y { int i; int j; };
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  Y x[] = { {3,2}, {2,4}, {3,6} };
-  Y y[] = { {4,5}, {2,4}, {4,5} };
-  Y z[] = { {4,5}, {2,4}, {4,5} };
-  auto [in, out] = ranges::replace_copy(x, y, 3, Y{4,5}, &Y::i);
-  ok &= in == x+3;
-  ok &= out == y+3;
-  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);
-  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace_copy_if/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace_copy_if/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace_copy_if/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace_copy_if/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,118 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  {
-    return a.i == b.i;
-  }
-};
-
-void
-test01()
-{
-  auto is_negative_p = [] (int a) { return a < 0; };
-  auto is_two_p = [] (int a) { return a == 2; };
-
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[5];
-      X z[5] = { {9}, {9}, {6}, {8}, {10} };
-      auto [in, out] = ranges::replace_copy_if(x, x+5, y,
-					       is_two_p, X{9}, &X::i);
-      VERIFY( in == x+5 && out == y+5 );
-      VERIFY( ranges::equal(y, z) );
-    }
-
-    {
-      const X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[5];
-      X z[5] = { {2}, {2}, {6}, {8}, {10} };
-      auto [in, out] = ranges::replace_copy_if(x, x+5, y,
-					       is_negative_p, X{9}, &X::i);
-      VERIFY( in == x+5 && out == y+5 );
-      VERIFY( ranges::equal(x, x+5, y, y+5) && ranges::equal(y, z) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6];
-      X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };
-      test_container<X, forward_iterator_wrapper> cx(x), cy(y), cz(z);
-      auto [in, out] = ranges::replace_copy_if(cx, cy.begin(),
-					       is_two_p, X{7}, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(cy, cz) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6];
-      const X z[6] = { {7}, {7}, {6}, {8}, {10}, {11} };
-      test_range<X, input_iterator_wrapper> cx(x);
-      test_range<X, output_iterator_wrapper> cy(y);
-      auto [in, out] = ranges::replace_copy_if(cx, cy.begin(),
-					       is_two_p, X{7}, &X::i);
-      VERIFY( in == cx.end() && out == cy.end() );
-      VERIFY( ranges::equal(y, z) );
-    }
-}
-
-struct Y { int i; int j; };
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  Y x[] = { {3,2}, {2,4}, {3,6} };
-  Y y[] = { {4,5}, {2,4}, {4,5} };
-  Y z[] = { {4,5}, {2,4}, {4,5} };
-  auto [in, out]
-    = ranges::replace_copy_if(x, y,
-			      [] (int a) { return a%2 == 1; }, Y{4,5}, &Y::i);
-  ok &= in == x+3;
-  ok &= out == y+3;
-  ok &= ranges::equal(y, z, {}, &Y::i, &Y::i);
-  ok &= ranges::equal(y, z, {}, &Y::j, &Y::j);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace_if/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace_if/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/replace_if/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/replace_if/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  {
-    return a.i == b.i;
-  }
-};
-
-void
-test01()
-{
-  auto is_even_p = [] (int a) { return a%2 == 0; };
-  auto is_negative_p = [] (int a) { return a < 0; };
-  auto is_two_p = [] (int a) { return a == 2; };
-    {
-      X x[6] = { {1}, {2}, {6}, {8}, {10}, {11} };
-      X y[6] = { {1}, {9}, {9}, {9}, {9}, {11} };
-      auto res = ranges::replace_if(x, x+5, is_even_p, X{9}, &X::i);
-      VERIFY( res == x+5 );
-      VERIFY( ranges::equal(x, y) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      auto res = ranges::replace_if(x, x+5, is_negative_p, X{9}, &X::i);
-      VERIFY( res == x+5 );
-      VERIFY( ranges::equal(x, y) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {10}, {11} };
-      X y[6] = { {7}, {7}, {6}, {8}, {10}, {11} };
-      test_container<X, forward_iterator_wrapper> cx(x), cy(y);
-      auto res = ranges::replace_if(cx, is_two_p, X{7}, &X::i);
-      VERIFY( res == cx.end() );
-      VERIFY( ranges::equal(cx, cy) );
-    }
-
-    {
-      int x[6] = { {2}, {2}, {6}, {8}, {10}, {2} };
-      int y[6] = { {7}, {7}, {6}, {8}, {10}, {7} };
-      test_range<int, input_iterator_wrapper> rx(x), ry(y);
-      auto res = ranges::replace_if(rx, is_two_p, 7);
-      VERIFY( res == rx.end() );
-
-      rx.bounds.first = x;
-      ry.bounds.first = y;
-      VERIFY( ranges::equal(rx, ry) );
-    }
-}
-
-struct Y { int i; int j; };
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  Y x[] = { {3,2}, {2,4}, {3,6} };
-  Y y[] = { {4,5}, {2,4}, {4,5} };
-  auto res = ranges::replace_if(x, [] (int a) { return a%2 == 1; },
-				Y{4,5}, &Y::i);
-  ok &= res == x+3;
-  ok &= ranges::equal(x, y, {}, &Y::i, &Y::i);
-  ok &= ranges::equal(x, y, {}, &Y::j, &Y::j);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
-
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/reverse/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/reverse/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/reverse/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/reverse/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::test_container;
-using __gnu_test::bidirectional_iterator_wrapper;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-template<template<typename> typename wrapper>
-void
-test01()
-{
-  int x[] = { 1, 2, 3, 4 };
-  test_container<int, wrapper> cx(x);
-  const int y[] = { 4, 3, 2, 1 };
-
-  auto res = ranges::reverse(cx);
-  VERIFY( res == ranges::end(cx) );
-  VERIFY( ranges::equal(cx, y) );
-}
-
-template<template<typename> typename wrapper>
-void
-test02()
-{
-  int x[] = { 1, 2, 3, 4, 5 };
-  test_range<int, wrapper> rx(x);
-  const int y[] = { 5, 4, 3, 2, 1 };
-
-  auto res = ranges::reverse(rx);
-  VERIFY( res == ranges::end(rx) );
-  VERIFY( ranges::equal(rx, y) );
-}
-
-constexpr bool
-test03()
-{
-  int x[] = { 1, 2, 3 };
-  const int y[] = { 2, 1, 3 };
-  ranges::reverse(x, x+2);
-  return ranges::equal(x, y);
-}
-
-int
-main()
-{
-  test01<bidirectional_iterator_wrapper>();
-  test02<bidirectional_iterator_wrapper>();
-
-  test01<random_access_iterator_wrapper>();
-  test02<random_access_iterator_wrapper>();
-
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/reverse_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/reverse_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/reverse_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/reverse_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::test_container;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = { 1, 2, 3, 4 };
-  int w[4];
-  test_container<int, bidirectional_iterator_wrapper> cx(x), cw(w);
-  const int y[] = { 4, 3, 2, 1 };
-
-  auto [in,out] = ranges::reverse_copy(cx, cw.begin());
-  VERIFY( in == ranges::end(cx) && out == cw.end() );
-  VERIFY( ranges::equal(cw, y) );
-}
-
-void
-test02()
-{
-  int x[] = { 1, 2, 3, 4, 5 };
-  int w[5];
-  test_range<int, bidirectional_iterator_wrapper> rx(x), rw(w);
-  const int y[] = { 5, 4, 3, 2, 1 };
-
-  auto [in,out] = ranges::reverse_copy(rx, ranges::begin(rw));
-  VERIFY( in == ranges::end(rx) && out == ranges::end(rw) );
-  VERIFY( ranges::equal(rw, y) );
-}
-
-constexpr bool
-test03()
-{
-  const int x[] = { 1, 2, 3 };
-  int w[2];
-  const int y[] = { 2, 1 };
-  ranges::reverse_copy(x, x+2, w);
-  return ranges::equal(w, y);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/rotate/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/rotate/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/rotate/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/rotate/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::bidirectional_iterator_wrapper;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-  X (int a) : i(a) { }
-
-  friend bool
-  operator==(const X& lhs, const X& rhs)
-  {
-    return lhs.i == rhs.i;
-  }
-};
-
-static_assert(!std::is_trivial_v<X>);
-
-template<template<typename, template<typename> typename> typename container,
-	 template<typename> typename wrapper,
-	 typename T = int>
-void
-test01()
-{
-  for (int a = 0; a <= 7; a++)
-    {
-      T x[] = {1, 2, 3, 4, 5, 6, 7};
-      container<T, wrapper> rx(x);
-      auto i = ranges::begin(rx);
-      std::advance(i, a);
-      auto res = ranges::rotate(rx, i);
-      if (a == 0)
-	VERIFY( ranges::begin(res) == ranges::end(rx) );
-      else
-	VERIFY( ranges::begin(res)
-		 == std::next(ranges::begin(rx),
-			      ranges::distance(i, ranges::end(rx))) );
-      VERIFY( ranges::end(res) == ranges::end(rx) );
-      for (int k = 0; k < 7; k++)
-	VERIFY( x[k] == (k+a)%7 + 1 );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1, 2, 3, 4};
-  const int y[] = { 2, 3, 1, 4 };
-  ranges::rotate(x, x+1, x+3);
-  return ranges::equal(x, y);
-}
-
-int
-main()
-{
-  test01<test_container, forward_iterator_wrapper>();
-  test01<test_range, forward_iterator_wrapper>();
-
-  test01<test_container, bidirectional_iterator_wrapper>();
-  test01<test_range, bidirectional_iterator_wrapper>();
-
-  test01<test_container, random_access_iterator_wrapper>();
-  test01<test_range, random_access_iterator_wrapper>();
-
-  test01<test_container, random_access_iterator_wrapper, X>();
-  test01<test_range, random_access_iterator_wrapper, X>();
-
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/rotate_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/rotate_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/rotate_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/rotate_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-  X () : i(0) { }
-  X (int a) : i(a) { }
-
-  friend bool
-  operator==(const X& lhs, const X& rhs)
-  {
-    return lhs.i == rhs.i;
-  }
-};
-
-static_assert(!std::is_trivial_v<X>);
-
-template<template<typename, template<typename> typename> typename container,
-	 template<typename> typename wrapper,
-	 typename T = int>
-void
-test01()
-{
-  for (int a = 0; a <= 7; a++)
-    {
-      T x[] = {1, 2, 3, 4, 5, 6, 7};
-      T w[7];
-      container<T, wrapper> rx(x), rw(w);
-      auto i = ranges::begin(rx);
-      std::advance(i, a);
-      auto [in,out] = ranges::rotate_copy(rx, i, ranges::begin(rw));
-      VERIFY( in == ranges::end(rx) );
-      VERIFY( out == ranges::end(rw) );
-      for (int k = 0; k < 7; k++)
-	VERIFY( w[k] == (k+a)%7 + 1 );
-    }
-}
-
-constexpr bool
-test02()
-{
-  const int x[] = {1, 2, 3, 4};
-  int w[3];
-  const int y[] = { 2, 3, 1};
-  auto [in,out] = ranges::rotate_copy(x, x+1, x+3, w);
-  return (in == x+3
-	  && out == w+3
-	  && ranges::equal(w, y));
-}
-
-int
-main()
-{
-  test01<test_container, forward_iterator_wrapper>();
-  test01<test_range, forward_iterator_wrapper>();
-
-  test01<test_container, random_access_iterator_wrapper>();
-  test01<test_range, random_access_iterator_wrapper>();
-
-  test01<test_container, random_access_iterator_wrapper, X>();
-  test01<test_range, random_access_iterator_wrapper, X>();
-
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/search/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/search/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/search/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/search/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  X x[] = { {2}, {6}, {8}, {10}, {11} };
-  X y[] = { {10}, {11} };
-  {
-
-    test_container<X, forward_iterator_wrapper> c(x);
-    auto res = ranges::search(c, y, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(c) );
-    res = ranges::search(c, c, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res) == ranges::begin(c)
-	    && std::get<1>(res) == ranges::end(c) );
-  }
-
-  {
-    test_range<X, forward_iterator_wrapper> r(x);
-    auto res = ranges::search(r, y, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res)->i == 10 && std::get<1>(res) == ranges::end(r) );
-    res = ranges::search(r, r, {}, &X::i, &X::i);
-    VERIFY( std::get<0>(res) == ranges::begin(r)
-	    && std::get<1>(res) == ranges::end(r) );
-  }
-}
-
-void
-test02()
-{
-  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  static constexpr X y[] = { {6}, {8} };
-  static constexpr int z[] = { 2, 8 };
-  static constexpr int w[] = { 2 };
-
-  static_assert(std::get<0>(ranges::search(x, y, {}, &X::i, &X::i)) == x+2);
-  static_assert(std::get<1>(ranges::search(x, y, {}, &X::i, &X::i)) == x+4);
-
-  static_assert(std::get<0>(ranges::search(x, z, {}, &X::i)) == x+6);
-  static_assert(std::get<1>(ranges::search(x, z, {}, &X::i)) == x+6);
-
-  static_assert(std::get<0>(ranges::search(x, w, {}, &X::i)) == x+0);
-  static_assert(std::get<1>(ranges::search(x, w, {}, &X::i)) == x+1);
-
-  static_assert(std::get<0>(ranges::search(x, x+6, w, w, {}, &X::i)) == x+0);
-  static_assert(std::get<1>(ranges::search(x, x+6, w, w, {}, &X::i)) == x+0);
-
-  static_assert(std::get<0>(ranges::search(x, x, w, w+1, {}, &X::i)) == x+0);
-  static_assert(std::get<1>(ranges::search(x, x, w, w+1, {}, &X::i)) == x+0);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/search_n/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/search_n/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/search_n/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/search_n/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,80 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-  int x[] = { {2}, {2}, {6}, {8}, {10}, {11} };
-  auto res = ranges::search_n(x+0, x+6, 2, 2);
-  VERIFY( res.begin() == x+0 && res.end() == x+2 );
-
-  int z[] = { {1}, {2}, {2}, {4}, {5}, {6} };
-  res = ranges::search_n(z, 3, 3, std::greater<int>());
-  VERIFY( res.begin() == z+3 && res.end() == z+6 );
-
-  test_container<int, forward_iterator_wrapper> cx(x);
-  auto res2 = ranges::search_n(cx, 2, 2);
-  VERIFY( res2.begin() == cx.begin() && *res2.end() == 6 );
-
-  int y[] = { {2}, {2}, {8}, {2}, {2}, {2}, {5} };
-  test_range<int, forward_iterator_wrapper> ry(y);
-  auto res3 = ranges::search_n(ry, 3, 2);
-  VERIFY( *res3.begin() == 2 && *res3.end() == 5 );
-
-  auto res4 = ranges::search_n(ry, 1, 8);
-  VERIFY( res4.begin().ptr == y+2 && res4.end().ptr == y+3 );
-}
-
-void
-test02()
-{
-  static constexpr X x[] = { {2}, {2}, {6}, {8}, {10}, {2} };
-  static constexpr X y[] = { {2}, {6}, {8}, {8}, {8}, {2} };
-  static constexpr int z[] = { {2}, {6}, {8}, {10}, {2}, {2} };
-
-  static_assert(ranges::search_n(z, 0, 5).end() == z+0);
-  static_assert(ranges::search_n(z, 1, 5).begin() == z+6);
-  static_assert(ranges::search_n(x, 2, 3, {}, &X::i).begin() == x+6);
-  static_assert(ranges::search_n(x, 2, 2, {}, &X::i).end() == x+2);
-  static_assert(ranges::search_n(y, 3, 8, {}, &X::i).begin() == y+2);
-  static_assert(ranges::search_n(y, 3, 8, {}, &X::i).end() == y+5);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
-
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_difference/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_difference/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_difference/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_difference/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {4,2,1,1,0};
-  int y[] = {3,2,1};
-  int z[3];
-  test_range<int, input_iterator_wrapper> rx(x), ry(y);
-  test_range<int, output_iterator_wrapper> rz(z);
-  auto [in,out]
-    = ranges::set_difference(rx, ry, rz.begin(), ranges::greater{});
-  VERIFY( in.ptr == x+5 );
-  VERIFY( out.ptr == z+3 );
-  VERIFY( ranges::equal(z, (int[]){4,1,0}) );
-}
-
-void
-test02()
-{
-  int x[] = {3,2,1,1,0};
-  int y[] = {3,2,2,1,0};
-  int z[1];
-  test_container<int, forward_iterator_wrapper> rx(x), ry(y);
-  test_container<int, forward_iterator_wrapper> rz(z);
-  auto [in,out]
-    = ranges::set_difference(rx.begin(), rx.end(),
-			     ry.begin(), ry.end(),
-			     rz.begin(),
-			     {},
-			     std::negate<>{},
-			     std::negate<>{});
-  VERIFY( in.ptr == x+5 );
-  VERIFY( out.ptr == z+1 );
-  VERIFY( ranges::equal(z, (int[]){1}) );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  int x[1] = {0};
-  int y[1] = {1};
-  int z[1];
-  ok &= ranges::set_difference(x, x, y, y+1, z).out == z;
-  ok &= ranges::set_difference(x, x+1, y, y, z).out == z+1;
-  ok &= z[0] == 0;
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_intersection/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_intersection/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_intersection/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_intersection/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {4,2,1,1,0};
-  int y[] = {3,2,1};
-  int z[2];
-  test_range<int, input_iterator_wrapper> rx(x), ry(y);
-  test_range<int, output_iterator_wrapper> rz(z);
-  auto [in1,in2,out]
-    = ranges::set_intersection(rx, ry, rz.begin(), ranges::greater{});
-  VERIFY( in1.ptr == x+5 );
-  VERIFY( in2.ptr == y+3 );
-  VERIFY( out.ptr == z+2 );
-  VERIFY( ranges::equal(z, (int[]){2,1}) );
-}
-
-void
-test02()
-{
-  int x[] = {3,2,1,1,0};
-  int y[] = {3,2,1,0};
-  int z[4];
-  test_container<int, forward_iterator_wrapper> rx(x), ry(y);
-  test_container<int, forward_iterator_wrapper> rz(z);
-  auto [in1,in2,out]
-    = ranges::set_intersection(rx.begin(), rx.end(),
-			       ry.begin(), ry.end(),
-			       rz.begin(),
-			       {},
-			       std::negate<>{},
-			       std::negate<>{});
-  VERIFY( in1.ptr == x+5 );
-  VERIFY( in2.ptr == y+4 );
-  VERIFY( out.ptr == z+4 );
-  VERIFY( ranges::equal(z, (int[]){3,2,1,0}) );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  int x[1] = {0};
-  int y[1] = {1};
-  int z[1];
-  ok &= ranges::set_intersection(x, x, y, y+1, z).out == z;
-  ok &= ranges::set_intersection(x, x+1, y, y, z).out == z;
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {4,2,1,1,0};
-  int y[] = {3,2,2,1};
-  int z[5];
-  test_range<int, input_iterator_wrapper> rx(x), ry(y);
-  test_range<int, output_iterator_wrapper> rz(z);
-  auto [in1,in2,out]
-    = ranges::set_symmetric_difference(rx, ry, rz.begin(), ranges::greater{});
-  VERIFY( in1.ptr == x+5 );
-  VERIFY( in2.ptr == y+4 );
-  VERIFY( out.ptr == z+5 );
-  VERIFY( ranges::equal(z, (int[]){4,3,2,1,0}) );
-}
-
-void
-test02()
-{
-  int x[] = {3,2,1,1,0};
-  int y[] = {3,2,1,0};
-  int z[1];
-  test_container<int, forward_iterator_wrapper> rx(x), ry(y);
-  test_container<int, forward_iterator_wrapper> rz(z);
-  auto [in1,in2,out]
-    = ranges::set_symmetric_difference(rx.begin(), rx.end(),
-				       ry.begin(), ry.end(),
-				       rz.begin(),
-				       {},
-				       std::negate<>{},
-				       std::negate<>{});
-  VERIFY( in1.ptr == x+5 );
-  VERIFY( in2.ptr == y+4 );
-  VERIFY( out.ptr == z+1 );
-  VERIFY( ranges::equal(z, (int[]){1}) );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  int x[1] = {0};
-  int y[1] = {1};
-  int z[1];
-  ok &= ranges::set_symmetric_difference(x, x, y, y+1, z).out == z+1;
-  ok &= z[0] == 1;
-  ok &= ranges::set_symmetric_difference(x, x+1, y, y, z).out == z+1;
-  ok &= z[0] == 0;
-  return ok;
-}
-
-void
-test04()
-{
-  int x[15] = {5,5,5,5,5,4,4,4,4,3,3,3,2,2,1};
-  int y[15] = {5,5,5,5,5,4,4,4,4,3,3,3,2,2,1};
-  for (int k = 0; k < 100; k++)
-    {
-      std::ranlux48_base g(k);
-      ranges::shuffle(x, g);
-      ranges::shuffle(y, g);
-      ranges::sort(x, x+10);
-      ranges::sort(y, y+10);
-
-      int z[15];
-      auto z_out = ranges::set_symmetric_difference(x, x+10, y, y+10, z).out;
-
-      int w1[15];
-      auto w1_out = ranges::set_difference(x, x+10, y, y+10, w1).out;
-
-      int w2[15];
-      auto w2_out = ranges::set_difference(y, y+10, x, x+10, w2).out;
-
-      int w3[15];
-      auto w3_out = ranges::set_union(w1, w1_out, w2, w2_out, w3).out;
-
-      VERIFY( ranges::equal(z, z_out, w3, w3_out) );
-    }
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-  test04();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_union/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_union/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/set_union/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/set_union/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {4,2,1,1,0};
-  int y[] = {3,2,1};
-  int z[6];
-  test_range<int, input_iterator_wrapper> rx(x), ry(y);
-  test_range<int, output_iterator_wrapper> rz(z);
-  auto [in1,in2,out]
-    = ranges::set_union(rx, ry, rz.begin(),
-			ranges::greater{});
-  VERIFY( in1.ptr == x+5 );
-  VERIFY( in2.ptr == y+3 );
-  VERIFY( out.ptr == z+6 );
-  VERIFY( ranges::equal(z, (int[]){4,3,2,1,1,0}) );
-}
-
-void
-test02()
-{
-  int x[] = {4,2,1,1,0};
-  int y[] = {3,2,1,1,0};
-  int z[6];
-  test_container<int, forward_iterator_wrapper> rx(x), ry(y);
-  test_container<int, forward_iterator_wrapper> rz(z);
-  auto [in1,in2,out]
-    = ranges::set_union(rx.begin(), rx.end(),
-			ry.begin(), ry.end(),
-			rz.begin(),
-			{},
-			std::negate<>{},
-			std::negate<>{});
-  VERIFY( in1.ptr == x+5 );
-  VERIFY( in2.ptr == y+5 );
-  VERIFY( out.ptr == z+6 );
-  VERIFY( ranges::equal(z, (int[]){4,3,2,1,1,0}) );
-}
-
-constexpr bool
-test03()
-{
-  bool ok = true;
-  int x[1] = {0};
-  int y[1] = {1};
-  int z[1];
-  ranges::set_union(x, x, y, y+1, z);
-  ok &= z[0] == 1;
-  ranges::set_union(x, x+1, y, y, z);
-  ok &= z[0] == 0;
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/shuffle/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/shuffle/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/shuffle/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/shuffle/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-// This test is adapted from 25_algorithms/shuffle/1.cc.
-
-void
-test01()
-{
-  for (unsigned size = 0; size < 50; ++size)
-    {
-      std::vector<int> vref(size);
-      std::iota(vref.begin(), vref.end(), 0);
-      std::vector<int> v1(vref), v2(vref);
-      test_container<int, random_access_iterator_wrapper> c
-	= {&v1[0], &v1[0] + size};
-      test_range<int, random_access_iterator_wrapper> r
-	= {&v2[0], &v2[0] + size};
-
-      std::ranlux48_base g1(size), g2(size + 1);
-      VERIFY( ranges::shuffle(c, g1) == c.end() );
-      VERIFY( ranges::shuffle(ranges::begin(r), ranges::end(r), g2)
-	      == ranges::end(r) );
-
-      if (size >= 10)
-	{
-	  VERIFY( !ranges::equal(c, vref) );
-	  VERIFY( !ranges::equal(r, vref) );
-	  VERIFY( !ranges::equal(c, r) );
-	}
-
-      VERIFY( ranges::is_permutation(c, vref) );
-      VERIFY( ranges::is_permutation(r, vref) );
-    }
-}
-
-int
-main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/sort/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/sort/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/sort/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/sort/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  for (unsigned size = 0; size < 50; ++size)
-    {
-      std::vector<int> vref(size);
-      std::iota(vref.begin(), vref.end(), 0);
-      std::vector<int> v1(vref), v2(vref);
-      test_container<int, random_access_iterator_wrapper> c
-	= {&v1[0], &v1[0] + size};
-      test_range<int, random_access_iterator_wrapper> r
-	= {&v2[0], &v2[0] + size};
-
-      std::ranlux48_base g1(size), g2(size + 1);
-      ranges::shuffle(c, g1);
-      ranges::shuffle(ranges::begin(r), ranges::end(r), g2);
-
-      VERIFY( ranges::sort(c) == c.end() );
-      VERIFY( ranges::sort(r) == ranges::end(r) );
-
-      VERIFY( ranges::equal(c, vref) );
-      VERIFY( ranges::equal(r, vref) );
-    }
-}
-
-struct X
-{
-  int i;
-  constexpr X(int a) : i(a) { }
-};
-
-constexpr bool
-test02()
-{
-  X x[] = {3,4,2,1,5};
-  const X y[] = {4,3,2,1,5};
-
-  auto res = ranges::sort(x, x+4, ranges::greater{}, &X::i);
-  return (res == x+4
-	  && ranges::equal(x, y, {}, &X::i, &X::i));
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/stable_partition/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/stable_partition/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/stable_partition/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/stable_partition/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-    {
-      int x[] = {1,2,3,4,5,6,7,8,9,10};
-      test_container<int, bidirectional_iterator_wrapper> cx(x);
-      auto pred = [] (int a) { return a%2==0; };
-      auto range = ranges::stable_partition(cx, pred);
-      VERIFY( ranges::all_of(cx.begin(), range.begin(), pred) );
-      VERIFY( ranges::none_of(range, pred) );
-    }
-
-    {
-      int x[] = {1,2,3,4,5,6,7,8,9,10,11};
-      test_range<int, bidirectional_iterator_wrapper> cx(x);
-      auto pred = [] (int a) { return a%2==0; };
-      auto range = ranges::stable_partition(cx, pred);
-      VERIFY( ranges::all_of(cx.begin(), range.begin(), pred) );
-      VERIFY( ranges::none_of(range, pred) );
-    }
-}
-
-void
-test02()
-{
-  for (int k = 1; k <= 10; k++)
-    {
-      int x[] = {1,2,3,4,5,6,7,8,9,10};
-      auto pred = [&] (int a) { return a >= k; };
-      auto proj = [] (int a) { return a-1; };
-      auto range = ranges::stable_partition(x, x+10, pred, proj);
-      VERIFY( ranges::all_of(x, range.begin(), pred, proj) );
-      VERIFY( ranges::none_of(range, pred, proj) );
-
-      int y[] = {0,1,2,3,4,5,6,7,8,9};
-      ranges::rotate(y, y+k);
-      VERIFY( ranges::equal(x, y, {}, proj) );
-    }
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/stable_sort/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/stable_sort/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/stable_sort/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/stable_sort/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-// { dg-require-cstdint "" }
-
-#include <algorithm>
-#include <random>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-// This test doesn't verify the stability property of ranges::stable_sort,
-// because at the moment it's just defined to be a wrapper over
-// std::stable_sort.
-
-void
-test01()
-{
-  for (unsigned size = 0; size < 50; ++size)
-    {
-      std::vector<int> vref(size);
-      std::iota(vref.begin(), vref.end(), 0);
-      std::vector<int> v1(vref), v2(vref);
-      test_container<int, random_access_iterator_wrapper> c
-	= {&v1[0], &v1[0] + size};
-      test_range<int, random_access_iterator_wrapper> r
-	= {&v2[0], &v2[0] + size};
-
-      std::ranlux48_base g1(size), g2(size + 1);
-      ranges::shuffle(c, g1);
-      ranges::shuffle(ranges::begin(r), ranges::end(r), g2);
-
-      auto res1 = ranges::stable_sort(c.begin(), c.end(), {}, std::negate<>{});
-      VERIFY( res1 == c.end() );
-
-      auto res2 = ranges::stable_sort(r, ranges::greater{});
-      VERIFY( res2 == ranges::end(r) );
-
-      VERIFY( ranges::equal(c, r) );
-      VERIFY( ranges::equal(c.begin(), c.end(), vref.rbegin(), vref.rend()) );
-    }
-}
-
-int
-main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/swap_ranges/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/swap_ranges/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/swap_ranges/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/swap_ranges/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,124 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-  int moved = 0;
-
-  constexpr X(int a) : i(a) { }
-
-  constexpr X(const X&) = delete;
-  constexpr X& operator=(const X&) = delete;
-
-  constexpr X(X&& other)
-  {
-    *this = std::move(other);
-  }
-
-  constexpr X&
-  operator=(X&& other)
-  {
-    other.moved++;
-    i = other.i;
-    return *this;
-  }
-
-  friend constexpr bool
-  operator==(const X& a, const X& b)
-  { return a.i == b.i; }
-};
-
-void
-test01()
-{
-    {
-      X x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      X y[7] = { 2, 4, 3, 5, 8, 9, 1 };
-      X z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-      X w[7] = { 2, 4, 3, 5, 8, 9, 1 };
-      auto [x_iter, y_iter] = ranges::swap_ranges(x, y);
-      VERIFY( ranges::equal(y, z) && x_iter == x+7 && y_iter == y+7 );
-      VERIFY( ranges::equal(x, w) );
-    }
-
-    {
-      int x[3] = { 1, 2, 3 };
-      int y[4] = { 2, 4, 6, 0 };
-      int z[3] = { 1, 2, 3 };
-      int w[3] = { 2, 4, 6 };
-      test_container<int, forward_iterator_wrapper> cx(x);
-      test_container<int, forward_iterator_wrapper> cy(y);
-      auto [x_iter, y_iter] = ranges::swap_ranges(cx, cy);
-      VERIFY( ranges::equal(y, y+3, z, z+3) );
-      VERIFY( x_iter.ptr == x+3 && y_iter.ptr == y+3 );
-      VERIFY( y[3] == 0 );
-      VERIFY( ranges::equal(x, w) );
-    }
-
-    {
-      int x[3] = { 1, 2, 3 };
-      int y[4] = { 2, 4, 6, 0 };
-      int z[3] = { 1, 2, 3 };
-      int w[3] = { 2, 4, 6 };
-      test_range<int, input_iterator_wrapper> cx(x);
-      test_range<int, input_iterator_wrapper> cy(y);
-      auto [y_iter, x_iter] = ranges::swap_ranges(cy, cx);
-      VERIFY( ranges::equal(y, y+3, z, z+3) );
-      VERIFY( x_iter.ptr == x+3 && y_iter.ptr == y+3 );
-      VERIFY( y[3] == 0 );
-      VERIFY( ranges::equal(x, w) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  bool ok = true;
-  X x[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  X y[7] = { 2, 4, 3, 5, 8, 9, 1 };
-  X z[7] = { 1, 2, 3, 4, 5, 6, 7 };
-  X w[7] = { 2, 4, 3, 5, 8, 9, 1 };
-  auto [x_iter, y_iter] = ranges::swap_ranges(x, y);
-  ok &= ranges::equal(y, z) && x_iter == x+7 && y_iter == y+7;
-  ok &= ranges::equal(x, w);
-  return ok;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
-
-
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/transform/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/transform/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/transform/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/transform/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,148 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-struct X { int i; };
-
-void
-test01()
-{
-    {
-      int x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };
-      int y[6] = { {3}, {5}, {7}, {9}, {11}, {12} };
-      auto [in, out] = ranges::transform(x, x, [] (int a) { return a+1; });
-      VERIFY( in == x+6 && out == x+6 );
-      VERIFY( ranges::equal(x, y) );
-    }
-
-    {
-      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };
-      int y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };
-      int z[7] = { {0}, {0}, {0}, {0}, {0}, {0}, {0} };
-      test_container<X, forward_iterator_wrapper> cx(x);
-      test_container<int, forward_iterator_wrapper> cy(y), cz(z);
-      auto [in, out]
-	= ranges::transform(cx, cz.begin(), [] (int a) { return a+1; }, &X::i);
-      VERIFY( ranges::equal(cy, cz) );
-      VERIFY( in == cx.end() && ++out == cz.end() );
-    }
-
-    {
-      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };
-      X y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };
-      int z[7] = { {0}, {0}, {0}, {0}, {0}, {0}, {0} };
-      test_range<X, input_iterator_wrapper> rx(x), ry(y);
-      test_range<int, output_iterator_wrapper> rz(z);
-      auto [in, out]
-	= ranges::transform(rx, rz.begin(), [] (int a) { return a+1; }, &X::i);
-      VERIFY( ranges::equal(ry, z, {}, &X::i) );
-      VERIFY( in == rx.end() && out.ptr == z+6 );
-    }
-}
-
-struct Y { int i; int j; };
-
-constexpr bool
-test02()
-{
-  int x[] = { 1, 2, 3 };
-  Y y[] = { {1,2}, {2,4}, {3,6} };
-  ranges::transform(y, y+3, x, [] (int a) { return -a; }, &Y::i);
-  return x[0] == -1 && x[1] == -2 && x[2] == -3;
-}
-
-void
-test03()
-{
-    {
-      int x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };
-      const int y[6] = { {3}, {5}, {7}, {9}, {11}, {12} };
-      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };
-      auto [in1, in2, out] = ranges::transform(x, y, x, std::plus<>{});
-      VERIFY( in1 == x+6 && in2 == y+6 && out == x+6 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      int x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };
-      const int y[6] = { {3}, {5}, {7}, {9}, {11}, {12} };
-      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };
-      auto [in1, in2, out] = ranges::transform(y, x, x, std::plus<>{});
-      VERIFY( in1 == y+6 && in2 == x+6 && out == x+6 );
-      VERIFY( ranges::equal(x, z) );
-    }
-
-    {
-      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };
-      int y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };
-      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };
-      int w[6];
-      test_container<X, forward_iterator_wrapper> cx(x);
-      test_container<int, forward_iterator_wrapper> cy(y), cz(z), cw(w);
-      auto [in1, in2, out]
-	= ranges::transform(cx, cy, cw.begin(), std::plus<>{}, &X::i);
-      VERIFY( in1 == cx.end() && ++in2 == cy.end() && out == cw.end() );
-      VERIFY( ranges::equal(cw, cz) );
-    }
-
-    {
-      X x[6] = { {2}, {4}, {6}, {8}, {10}, {11} };
-      int y[7] = { {3}, {5}, {7}, {9}, {11}, {12}, {0} };
-      int z[6] = { {5}, {9}, {13}, {17}, {21}, {23} };
-      int w[6];
-      test_range<X, input_iterator_wrapper> rx(x);
-      test_range<int, input_iterator_wrapper> ry(y), rz(z);
-      test_range<int, output_iterator_wrapper> rw(w);
-      auto [in1, in2, out]
-	= ranges::transform(rx, ry, rw.begin(), std::plus<>{}, &X::i);
-      VERIFY( in1 == rx.end() && ++in2 == ry.end() && out.ptr == w+6 );
-      VERIFY( ranges::equal(w, rz) );
-    }
-}
-
-constexpr bool
-test04()
-{
-  int x[3];
-  const Y y[3] = { {1,2}, {2,4}, {3,6} };
-  ranges::transform(y, y+3, y, y+3, x, std::plus<>{}, &Y::i, &Y::j);
-  return x[0] == 3 && x[1] == 6 && x[2] == 9;
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-  test03();
-  static_assert(test04());
-}
-
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/unique/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/unique/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/unique/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/unique/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,143 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <list>
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-
-namespace ranges = std::ranges;
-
-struct X
-{
-  int i;
-};
-
-void
-test01()
-{
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {2}, {11} };
-      const int y[5] = { {2}, {6}, {8}, {2}, {11} };
-      test_container<X, forward_iterator_wrapper> cx(x);
-      auto res = ranges::unique(cx, {}, &X::i);
-      VERIFY( res.end() == cx.end() );
-      VERIFY( ranges::equal(cx.begin(), res.begin(), y, y+5, {}, &X::i) );
-    }
-
-    {
-      X x[6] = { {2}, {2}, {6}, {8}, {2}, {11} };
-      const int y[5] = { {2}, {6}, {8}, {2}, {11} };
-      test_range<X, forward_iterator_wrapper> rx(x);
-      auto res = ranges::unique(rx, {}, &X::i);
-      VERIFY( res.end() == rx.end() );
-      VERIFY( ranges::equal(rx.begin(), res.begin(), y, y+5, {}, &X::i) );
-    }
-}
-
-constexpr bool
-test02()
-{
-  int x[2] = {2, 2};
-  const int y[1] = {2};
-  auto res = ranges::unique(x);
-  return ranges::equal(x, res.begin(), y, y+1, ranges::equal_to{});
-}
-
-/* The following is adapted from 25_algorithms/unique/2.cc.  */
-
-namespace two_dot_cc
-{
-  const int T1[] = {1, 4, 4, 6, 1, 2, 2, 3, 1, 6, 6, 6, 5, 7, 5, 4, 4};
-  const int T2[] = {1, 1, 1, 2, 2, 1, 1, 7, 6, 6, 7, 8, 8, 8, 8, 9, 9};
-  const int N = sizeof(T1) / sizeof(int);
-
-  const int A1[] = {1, 4, 6, 1, 2, 3, 1, 6, 5, 7, 5, 4};
-  const int A2[] = {1, 4, 4, 6, 6, 6, 6, 7};
-  const int A3[] = {1, 1, 1};
-
-  const int B1[] = {1, 2, 1, 7, 6, 7, 8, 9};
-  const int B2[] = {1, 1, 1, 2, 2, 7, 7, 8, 8, 8, 8, 9, 9};
-  const int B3[] = {9, 9, 8, 8, 8, 8, 7, 6, 6, 1, 1, 1, 1, 1};
-
-  void test01()
-  {
-    using namespace std;
-
-    list<int>::iterator pos;
-
-    list<int> coll(T1, T1 + N);
-    pos = ranges::unique(coll.begin(), coll.end()).begin();
-    VERIFY( equal(coll.begin(), pos, A1) );
-
-    list<int> coll2(T2, T2 + N);
-    pos = ranges::unique(coll2.begin(), coll2.end()).begin();
-    VERIFY( equal(coll2.begin(), pos, B1) );
-  }
-
-  void test02()
-  {
-    using namespace std;
-
-    list<int>::iterator pos;
-
-    list<int> coll(T1, T1 + N);
-    pos = ranges::unique(coll.begin(), coll.end(), greater<int>()).begin();
-    VERIFY( equal(coll.begin(), pos, A2) );
-
-    list<int> coll2(T2, T2 + N);
-    pos = ranges::unique(coll2.begin(), coll2.end(), greater<int>()).begin();
-    VERIFY( equal(coll2.begin(), pos, B2) );
-  }
-
-  void test03()
-  {
-    using namespace std;
-
-    list<int>::iterator pos;
-
-    list<int> coll(T1, T1 + N);
-    pos = ranges::unique(coll.begin(), coll.end(), less<int>()).begin();
-    VERIFY( equal(coll.begin(), pos, A3) );
-
-    list<int> coll2(T2, T2 + N);
-    reverse(coll2.begin(), coll2.end());
-    pos = ranges::unique(coll2.begin(), coll2.end(), less<int>()).begin();
-    VERIFY( equal(coll2.begin(), pos, B3) );
-  }
-} // namespace two_dot_cc
-
-int main()
-{
-  test01();
-  static_assert(test02());
-
-  two_dot_cc::test01();
-  two_dot_cc::test02();
-  two_dot_cc::test03();
-
-  return 0;
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/unique_copy/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/unique_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/unique_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/unique_copy/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::input_iterator_wrapper;
-using __gnu_test::output_iterator_wrapper;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-template<template<typename> typename source_wrapper,
-	 template<typename> typename dest_wrapper>
-void
-test01()
-{
-  int x[6] = {0, 0, 0, 1, 1, 1};
-  int y[2];
-  const int z[2] = {0, 1};
-
-  test_range<int, source_wrapper> rx(x);
-  test_range<int, dest_wrapper> ry(y);
-  auto [in,out] = ranges::unique_copy(rx, ry.begin());
-  VERIFY( in == ranges::end(rx) && out == ranges::end(ry) );
-  VERIFY( ranges::equal(y, z) );
-}
-
-template<template<typename> typename source_wrapper,
-	 template<typename> typename dest_wrapper>
-void
-test02()
-{
-  int x[6] = {0, 0, 0, 1, 1, 1};
-  int y[2] = {0, 0};
-  const int z[2] = {0, 0};
-
-  test_range<int, source_wrapper> rx(x, x);
-  test_range<int, dest_wrapper> ry(y, y);
-  auto [in, out] = ranges::unique_copy(rx.begin(), rx.end(), ry.begin());
-  VERIFY( in.ptr == x && out.ptr == y );
-  VERIFY( ranges::equal(y, z) );
-}
-
-template<template<typename> typename source_wrapper,
-	 template<typename> typename dest_wrapper>
-void
-test03()
-{
-  struct X { int i; };
-  X x[6] = { {1}, {2}, {2}, {4}, {4}, {6} };
-  X y[4] = { {1}, {2}, {4}, {6} };
-  const X z[4] = { {1}, {2}, {4}, {6} };
-
-  test_range<X, source_wrapper> rx(x);
-  test_range<X, dest_wrapper> ry(y);
-  auto [in, out]
-    = ranges::unique_copy(rx, ry.begin(), ranges::equal_to{}, &X::i);
-  VERIFY( in == ranges::end(rx) && out == ranges::end(ry) );
-  VERIFY( ranges::equal(y, z, {}, &X::i, &X::i) );
-}
-
-constexpr bool
-test04()
-{
-  struct X { int i; };
-  X x[7] = { {1}, {2}, {2}, {2}, {4}, {4}, {6} };
-  X y[4] = { {1}, {2}, {4}, {6} };
-  const X z[4] = { {1}, {2}, {4}, {6} };
-
-  auto [in, out]
-    = ranges::unique_copy(x, x+7, y, ranges::equal_to{}, &X::i);
-  return (in == ranges::end(x)
-	  && out == ranges::end(y)
-	  && ranges::equal(y, z, {}, &X::i, &X::i));
-}
-
-int
-main()
-{
-  test01<input_iterator_wrapper, output_iterator_wrapper>();
-  test01<input_iterator_wrapper, forward_iterator_wrapper>();
-  test01<forward_iterator_wrapper, output_iterator_wrapper>();
-
-  test02<input_iterator_wrapper, output_iterator_wrapper>();
-  test02<input_iterator_wrapper, forward_iterator_wrapper>();
-  test02<forward_iterator_wrapper, output_iterator_wrapper>();
-
-  test03<input_iterator_wrapper, output_iterator_wrapper>();
-  test03<input_iterator_wrapper, forward_iterator_wrapper>();
-  test03<forward_iterator_wrapper, output_iterator_wrapper>();
-
-  static_assert(test04());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/upper_bound/constrained.cc gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/upper_bound/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/upper_bound/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/25_algorithms/upper_bound/constrained.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_container;
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-
-void
-test01()
-{
-  int x[] = {1, 2, 3, 4, 5, 5, 6, 7};
-  for (unsigned i = 0; i < 5; i++)
-    for (unsigned j = 6; j < 8; j++)
-      {
-	test_container<int, forward_iterator_wrapper> cx(x);
-	auto result = ranges::upper_bound(std::next(cx.begin(), i),
-					  std::next(cx.begin(), j),
-					  4, {}, [] (int a) { return a-1; });
-	VERIFY( result.ptr == x+6 );
-      }
-
-  ranges::reverse(x);
-  test_range<int, forward_iterator_wrapper> rx(x);
-  auto result = ranges::upper_bound(rx, 5, ranges::greater{},
-				    [] (int a) { return a+1; });
-  VERIFY( result.ptr == x+5 );
-}
-
-constexpr bool
-test02()
-{
-  int x[] = {1, 2, 3, 4, 5};
-  return (ranges::upper_bound(x, 6) == x+5
-	  && ranges::upper_bound(x, x, 6) == x
-	  && ranges::upper_bound(x, 1) == x+1);
-}
-
-int
-main()
-{
-  test01();
-  static_assert(test02());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/random/concept.cc gcc-10-20200202/libstdc++-v3/testsuite/26_numerics/random/concept.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/random/concept.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/26_numerics/random/concept.cc	2020-02-02 23:32:20.000000000 +0100
@@ -219,30 +219,3 @@
 };
 
 static_assert( ! std::uniform_random_bit_generator<N11> );
-
-struct N12
-{
-  unsigned operator()();
-  static unsigned min() { return 0; } // not constexpr
-  static constexpr unsigned max() { return 1; }
-};
-
-static_assert( ! std::uniform_random_bit_generator<N12> ); // LWG 3150
-
-struct N13
-{
-  unsigned operator()();
-  static constexpr unsigned min() { return 0; }
-  static unsigned max() { return 1; } // not constexpr
-};
-
-static_assert( ! std::uniform_random_bit_generator<N13> ); // LWG 3150
-
-struct N14
-{
-  unsigned operator()();
-  static constexpr unsigned min() { return 1; }
-  static constexpr unsigned max() { return 0; } // max not greater than min
-};
-
-static_assert( ! std::uniform_random_bit_generator<N14> ); // LWG 3150
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc gcc-10-20200202/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	2020-02-16 23:32:15.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	2020-02-02 23:32:20.000000000 +0100
@@ -10,6 +10,6 @@
 auto x = std::generate_canonical<std::size_t,
 			std::numeric_limits<std::size_t>::digits>(urng);
 
-// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 172 }
+// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 171 }
 
 // { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 3281 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/all.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/all.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/all.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/all.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-namespace ranges = std::ranges;
-namespace views = std::ranges::views;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5};
-  auto v = views::all(x);
-
-  static_assert(ranges::view<decltype(v)>);
-  static_assert(ranges::random_access_range<decltype(v)>);
-
-  VERIFY( ranges::size(v) == 5 );
-  VERIFY( ranges::size(x | views::all) == 5 );
-  VERIFY( ranges::size(v | views::all | views::all) == 5 );
-  VERIFY( ranges::size(v | (views::all | views::all)) == 5 );
-
-  ranges::reverse(v);
-  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );
-}
-
-void
-test02()
-{
-  int x[5] = { 0 };
-  int k = 0;
-  for (auto&& i : ranges::ref_view{x})
-    i += ++k;
-  VERIFY( ranges::equal(x, (int[]){1,2,3,4,5}) );
-}
-
-constexpr bool
-test03()
-{
-  std::array ints{0,1,2,3,4,5};
-  auto even = [] (int i) { return i%2==0; };
-  auto odd = [] (int i) { return i%2==1; };
-  auto square = [] (int i) { return i*i; };
-  int sum = 0;
-  for (auto v : (ints
-		 | (views::all
-		    | (views::filter(even)
-		    | (views::filter(odd) | views::all)))
-		 | views::transform(square)))
-    sum += v;
-  return sum == 0;
-}
-
-constexpr bool
-test04()
-{
-  auto odd = [] (int i) { return i%2==1; };
-  auto square = [] (int i) { return i*i; };
-  auto increment = [] (int i) { return i+1; };
-  auto small = [] (int i) { return i<30; };
-  auto non_negative = [] (int i) { return i>=0; };
-  auto negative = [] (int i) { return i<0; };
-  return ranges::equal(views::iota(-5)
-		       | views::drop_while(negative)
-		       | views::take_while(non_negative)
-		       | views::transform(increment)
-		       | views::filter(odd)
-		       | views::take(3)
-		       | views::all
-		       | views::transform(square),
-		       views::iota(-5)
-		       | views::drop_while(negative)
-		       | views::drop(1)
-		       | views::filter(odd)
-		       | views::transform(square)
-		       | views::take_while(small)
-		       | views::take_while(small));
-}
-
-static_assert(std::is_empty_v<decltype(views::common
-				       | views::join
-				       | views::all
-				       | views::common
-				       | views::keys
-				       | views::reverse)>);
-static_assert(sizeof(decltype(views::take(5) | views::drop(5)))
-	      == sizeof(decltype(views::take(5)
-				 | views::join
-				 | views::common
-				 | views::all
-				 | views::keys
-				 | views::drop(5)
-				 | views::reverse)));
-
-int
-main()
-{
-  test01();
-  test02();
-  static_assert(test03());
-  static_assert(test04());
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/common.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/common.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/common.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/common.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = ranges::views;
-
-void
-test01()
-{
-  int x[] = {1,2,1,3};
-  auto v = x | views::common;
-  VERIFY( std::count(v.begin(), v.end(), 1) == 2);
-  static_assert(ranges::common_range<decltype(v)>);
-  static_assert(ranges::view<decltype(v)>);
-  static_assert(ranges::random_access_range<decltype(v)>);
-  static_assert(std::same_as<decltype(v), decltype(views::common(v))>);
-
-  auto v2 = v | (views::common | views::common);
-  VERIFY( std::count(v2.begin(), v2.end(), 1) == 2);
-}
-
-void
-test02()
-{
-  int x[] = {1,2,1,3};
-  test_range<int, forward_iterator_wrapper> rx(x);
-  auto v = ranges::common_view(rx);
-  VERIFY( std::count(v.begin(), v.end(), 1) == 2);
-  static_assert(ranges::common_range<decltype(v)>);
-  static_assert(ranges::view<decltype(v)>);
-  static_assert(ranges::forward_range<decltype(v)>);
-  static_assert(std::same_as<decltype(v), decltype(views::common(v))>);
-
-  auto v2 = v | (views::common | views::common);
-  VERIFY( std::count(v2.begin(), v2.end(), 1) == 2);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/counted.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/counted.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/counted.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/counted.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = ranges::views;
-
-void
-test01()
-{
-  int x[] = {0,1,2,3,4,5,0,1,2,3,4,5};
-  auto v = views::counted(x, 5);
-  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(ranges::sized_range<R>);
-  static_assert(ranges::common_range<R>);
-  static_assert(ranges::random_access_range<R>);
-}
-
-void
-test02()
-{
-  int x[] = {0,1,2,3,4,5,0,1,2,3,4,5};
-  test_range<int, forward_iterator_wrapper> rx(x);
-  auto v = views::counted(rx.begin(), 5);
-  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(ranges::sized_range<R>);
-  static_assert(!ranges::common_range<R>);
-  static_assert(!ranges::bidirectional_range<R>);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/drop.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/drop.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/drop.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/drop.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = ranges::views;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5};
-  auto v = x | views::drop(3);
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(ranges::sized_range<R>);
-  static_assert(ranges::random_access_range<R>);
-  VERIFY( ranges::equal(v, (int[]){4,5}) );
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4,5};
-  auto t = views::drop(3) | views::reverse;
-  auto v = x | t;
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(ranges::sized_range<R>);
-  static_assert(ranges::random_access_range<R>);
-  VERIFY( ranges::equal(v, (int[]){5,4}) );
-}
-
-void
-test03()
-{
-  int x[] = {1,2,3,4,5};
-  test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto v = rx | views::drop(3);
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::sized_range<R>);
-  static_assert(ranges::bidirectional_range<R>);
-  VERIFY( ranges::equal(v, (int[]){4,5}) );
-}
-
-
-void
-test04()
-{
-  auto v = views::iota(0) | views::drop(10);
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::sized_range<R>);
-  VERIFY( ranges::equal(v | views::take(3), (int[]){10,11,12}) );
-}
-
-void
-test05()
-{
-  int x[] = {1,2,3};
-  auto r = ranges::subrange(x, x+1);
-  auto v = views::drop(r, 2);
-  VERIFY( ranges::begin(v) == x+1 );
-  VERIFY( ranges::size(v) == 0 );
-}
-
-void
-test06()
-{
-  int x[] = {1,2,3};
-  VERIFY( ranges::empty(x | views::drop(10)) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  test04();
-  test05();
-  test06();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/drop_while.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/drop_while.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/drop_while.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/drop_while.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = std::ranges::views;
-
-void
-test01()
-{
-  auto p = [] (int i) { return i != 16; };
-  auto v = views::iota(10) | views::drop_while(p);
-  VERIFY( ranges::equal(v | views::take(5), (int[]){16,17,18,19,20}) );
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::common_range<R>);
-  static_assert(ranges::random_access_range<R>);
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4,5};
-  test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto v = rx | views::drop_while([] (int i) { return i<4; });
-  VERIFY( ranges::equal(v, (int[]){4,5}) );
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::common_range<R>);
-  static_assert(ranges::bidirectional_range<R>);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
-
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-#include <tuple>
-
-namespace ranges = std::ranges;
-namespace views = ranges::views;
-
-void
-test01()
-{
-  std::tuple<int, int> x[] = {{1,2},{3,4},{5,6}};
-  auto v0 = x | views::elements<0>;
-  VERIFY( ranges::equal(v0, (int[]){1,3,5}) );
-  VERIFY( ranges::equal(v0, x | views::keys) );
-  VERIFY( ranges::size(v0) == 3 );
-
-  using R0 = decltype(v0);
-  static_assert(ranges::random_access_range<R0>);
-  static_assert(ranges::sized_range<R0>);
-
-  auto v1 = x | views::reverse | views::elements<1> | views::reverse;
-  VERIFY( ranges::equal(v1, (int[]){2,4,6}) );
-  VERIFY( ranges::equal(v1, x | views::values) );
-}
-
-int
-main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = std::ranges::views;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5,6};
-  auto is_odd = [] (int i) { return i%2==1; };
-  auto v = x | views::filter(is_odd);
-  using R = decltype(v);
-  static_assert(std::same_as<int&, decltype(*v.begin())>);
-  static_assert(ranges::view<R>);
-  static_assert(ranges::input_range<R>);
-  static_assert(ranges::common_range<R>);
-  static_assert(!ranges::sized_range<R>);
-  static_assert(ranges::bidirectional_range<R>);
-  static_assert(!ranges::random_access_range<R>);
-  static_assert(ranges::range<ranges::all_view<R>>);
-  VERIFY( ranges::equal(v, (int[]){1,3,5}) );
-  VERIFY( ranges::equal(v | views::reverse, (int[]){5,3,1}) );
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4,5,6};
-  auto f = [flag=false] (int) mutable { return flag = !flag; };
-  auto v = views::filter(f)(x);
-  using R = decltype(v);
-  static_assert(std::same_as<int&, decltype(*v.begin())>);
-  static_assert(ranges::range<R>);
-  static_assert(std::copyable<R>);
-  static_assert(!ranges::view<const R>);
-  VERIFY( ranges::equal(v, (int[]){1,3,5}) );
-}
-
-struct X
-{
-  int i, j;
-};
-
-void
-test03()
-{
-  X x[] = {{1,3}, {2,5}, {3,7}, {4,9}};
-  test_range<X, bidirectional_iterator_wrapper> rx(x);
-  auto v = rx | views::filter([] (auto&& p) { return p.i%2==0; });
-  int sum = 0;
-  for (auto i = v.begin(); i != v.end(); ++i)
-    sum += i->j;
-  VERIFY( sum == 14 );
-}
-
-void
-test04()
-{
-  auto yes = [] (int) { return true; };
-  VERIFY( ranges::equal(views::iota(0) | views::filter(yes) | views::take(1),
-			(int[]){0}) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  test04();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <string>
-#include <string_view>
-#include <vector>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-namespace ranges = std::ranges;
-namespace views = std::ranges::views;
-
-void
-test01()
-{
-  using namespace std::literals;
-  std::string_view cs[] = {"the", "quick", "brown", "fox"};
-  auto v = cs | views::join;
-  VERIFY( ranges::equal(v, "thequickbrownfox"sv) );
-  using R = decltype(v);
-  static_assert(ranges::bidirectional_range<R>);
-  static_assert(ranges::bidirectional_range<const R>);
-  static_assert(ranges::common_range<R>);
-  static_assert(ranges::common_range<const R>);
-}
-
-void
-test02()
-{
-  auto v = (views::iota(0,4)
-	    | views::transform([] (int i) { return views::iota(0,i); })
-	    | views::join);
-  VERIFY( ranges::equal(v, (int[]){0,0,1,0,1,2}) );
-  using R = decltype(v);
-  static_assert(ranges::input_range<R>);
-  static_assert(!ranges::range<const R>);
-  static_assert(!ranges::forward_range<R>);
-  static_assert(!ranges::common_range<const R>);
-}
-
-void
-test03()
-{
-  auto v = (views::iota(0,4)
-	    | views::transform([] (int i) { return views::iota(0,i); })
-	    | views::filter([] (auto) { return true; })
-	    | views::join);
-  VERIFY( ranges::equal(v, (int[]){0,0,1,0,1,2}) );
-  using R = decltype(v);
-  static_assert(ranges::input_range<R>);
-  static_assert(!ranges::range<const R>);
-  static_assert(!ranges::forward_range<R>);
-  static_assert(!ranges::common_range<const R>);
-}
-
-void
-test04()
-{
-  auto v = (views::iota(0,4)
-	    | views::transform([] (int i) { return views::iota(0,i); }));
-  auto v2 = ranges::ref_view{v};
-  VERIFY( ranges::equal(v2 | views::join, (int[]){0,0,1,0,1,2}) );
-  using R = decltype(v2);
-  static_assert(ranges::random_access_range<R>);
-  static_assert(ranges::range<const R>);
-  static_assert(ranges::common_range<const R>);
-  static_assert(ranges::random_access_range<ranges::range_reference_t<R>>);
-  static_assert(!std::is_reference_v<ranges::range_reference_t<R>>);
-}
-
-void
-test05()
-{
-  using namespace std::literals;
-  std::vector<std::string> x = {"the", " ", "quick", " ", "brown", " ", "fox"};
-  auto v = x | views::join | views::split(' ');
-  auto i = v.begin();
-  VERIFY( ranges::equal(*i++, "the"sv) );
-  VERIFY( ranges::equal(*i++, "quick"sv) );
-  VERIFY( ranges::equal(*i++, "brown"sv) );
-  VERIFY( ranges::equal(*i++, "fox"sv) );
-  VERIFY( i == v.end() );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  test04();
-  test05();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = ranges::views;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5};
-  auto v = x | views::reverse;
-  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );
-  VERIFY( ranges::equal(v | views::reverse, x) );
-  static_assert(ranges::view<decltype(v)>);
-  static_assert(ranges::sized_range<decltype(v)>);
-  static_assert(ranges::common_range<decltype(v)>);
-  static_assert(ranges::random_access_range<decltype(v)>);
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4,5};
-  test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto v = views::reverse(rx);
-  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );
-  VERIFY( ranges::equal(v | views::reverse, rx) );
-  static_assert(ranges::view<decltype(v)>);
-  static_assert(!ranges::sized_range<decltype(v)>);
-  static_assert(ranges::common_range<decltype(v)>);
-  static_assert(!ranges::random_access_range<decltype(v)>);
-  static_assert(ranges::bidirectional_range<decltype(v)>);
-}
-
-void
-test03()
-{
-  int x[] = {1,7,3,6,5,2,4,8};
-  auto is_even = [] (int i) { return i%2==0; };
-  int sum = 0;
-  for (auto i : x | views::reverse | views::filter(is_even))
-    sum += i;
-  VERIFY( sum == 20 );
-}
-
-void
-test04()
-{
-  int x[] = {1,2,3,4,5};
-  VERIFY( ranges::equal(x | views::reverse | (views::reverse | views::reverse),
-			(int[]){5,4,3,2,1}) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  test04();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/split.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <string>
-#include <string_view>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = std::ranges::views;
-
-using namespace std::literals;
-
-void
-test01()
-{
-  auto x = "the  quick  brown  fox"sv;
-  auto p = std::string{"  "};
-  auto v = x | views::split(p);
-  auto i = v.begin();
-  VERIFY( ranges::equal(*i++, "the"sv) );
-  VERIFY( ranges::equal(*i++, "quick"sv) );
-  VERIFY( ranges::equal(*i++, "brown"sv) );
-  VERIFY( ranges::equal(*i++, "fox"sv) );
-  VERIFY( i == v.end() );
-}
-
-void
-test02()
-{
-  auto x = "the quick brown fox"sv;
-  auto v = x | views::split(' ');
-  auto i = v.begin();
-  VERIFY( ranges::equal(*i++, "the"sv) );
-  VERIFY( ranges::equal(*i++, "quick"sv) );
-  VERIFY( ranges::equal(*i++, "brown"sv) );
-  VERIFY( ranges::equal(*i++, "fox"sv) );
-  VERIFY( i == v.end() );
-}
-
-void
-test03()
-{
-  char x[] = "the quick brown fox";
-  test_range<char, forward_iterator_wrapper> rx(x);
-  auto v = rx | views::split(' ');
-  auto i = v.begin();
-  VERIFY( ranges::equal(*i++, "the"sv) );
-  VERIFY( ranges::equal(*i++, "quick"sv) );
-  VERIFY( ranges::equal(*i++, "brown"sv) );
-  VERIFY( ranges::equal(*i++, "fox"sv) );
-  VERIFY( i == v.end() );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/take.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/take.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/take.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/take.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::bidirectional_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = ranges::views;
-
-void
-test01()
-{
-  auto v = views::iota(0) | views::take(5);
-  static_assert(ranges::view<decltype(v)>);
-  static_assert(!ranges::sized_range<decltype(v)>);
-  static_assert(!ranges::common_range<decltype(v)>);
-  static_assert(ranges::random_access_range<decltype(v)>);
-  static_assert(!ranges::contiguous_range<decltype(v)>);
-  static_assert(ranges::range<const decltype(v)>);
-  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );
-}
-
-void
-test02()
-{
-  auto v = views::take(views::iota(0, 20), 5);
-  static_assert(ranges::view<decltype(v)>);
-  static_assert(ranges::sized_range<decltype(v)>);
-  static_assert(ranges::common_range<decltype(v)>);
-  static_assert(ranges::random_access_range<decltype(v)>);
-  static_assert(!ranges::contiguous_range<decltype(v)>);
-  static_assert(ranges::range<const decltype(v)>);
-  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );
-}
-
-void
-test03()
-{
-  int x[] = {0,1,2,3,4,5};
-  auto is_odd = [] (int i) { return i%2 == 1; };
-  auto v = x | views::filter(is_odd) | views::take(3);
-  ranges::begin(v);
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::sized_range<R>);
-  static_assert(!ranges::common_range<R>);
-  static_assert(ranges::forward_range<R>);
-  static_assert(!ranges::random_access_range<R>);
-  static_assert(!ranges::range<const R>);
-  VERIFY( ranges::equal(v, (int[]){1,3,5}) );
-}
-
-void
-test04()
-{
-  int x[] = {1,2,3,4,5};
-  test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto v = ranges::take_view{rx, 3};
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::sized_range<R>);
-  static_assert(ranges::bidirectional_range<R>);
-  VERIFY( ranges::equal(v | views::take(5), (int[]){1,2,3}) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-  test04();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/take_while.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/take_while.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/take_while.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/take_while.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::forward_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = std::ranges::views;
-
-void
-test01()
-{
-  auto p = [] (int i) { return i != 16; };
-  auto v = views::iota(10) | views::take_while(p);
-  VERIFY( ranges::equal(v, (int[]){10,11,12,13,14,15}) );
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::common_range<R>);
-  static_assert(ranges::random_access_range<R>);
-}
-
-void
-test02()
-{
-  int x[] = {1,2,3,4,5};
-  test_range<int, forward_iterator_wrapper> rx(x);
-  auto v = rx | views::take_while([] (int i) { return i<4; });
-  VERIFY( ranges::equal(v, (int[]){1,2,3}) );
-  using R = decltype(v);
-  static_assert(ranges::view<R>);
-  static_assert(!ranges::common_range<R>);
-  static_assert(ranges::forward_range<R>);
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-
-using __gnu_test::test_range;
-using __gnu_test::random_access_iterator_wrapper;
-
-namespace ranges = std::ranges;
-namespace views = std::ranges::views;
-
-void
-test01()
-{
-  int x[] = {1,2,3,4,5};
-  auto is_odd = [] (int i) { return i%2==1; };
-  auto v = x | views::transform(is_odd);
-  VERIFY( ranges::equal(v, (int[]){1,0,1,0,1}) );
-  using R = decltype(v);
-  static_assert(std::same_as<bool, decltype(*ranges::begin(v))>);
-  static_assert(ranges::view<R>);
-  static_assert(ranges::sized_range<R>);
-  static_assert(ranges::random_access_range<R>);
-}
-
-struct X
-{
-  int i,j;
-};
-
-void
-test02()
-{
-  X x[] = {{1,2},{3,4},{5,6},{7,8},{9,10}};
-  test_range<X, random_access_iterator_wrapper> rx(x);
-  auto v = rx | views::transform(&X::i);
-  VERIFY( ranges::size(v) == 5 );
-  VERIFY( ranges::distance(v.begin(), v.end()) == 5 );
-  VERIFY( ranges::equal(v, (int[]){1,3,5,7,9}) );
-  VERIFY( ranges::equal(v | views::reverse, (int[]){9,7,5,3,1}) );
-  using R = decltype(v);
-  static_assert(std::same_as<int&, decltype(*ranges::begin(v))>);
-  static_assert(std::same_as<int, std::iter_value_t<ranges::iterator_t<R>>>);
-  static_assert(ranges::view<R>);
-  static_assert(ranges::sized_range<R>);
-  static_assert(!ranges::common_range<R>);
-  static_assert(ranges::random_access_range<R>);
-}
-
-void
-test03()
-{
-  auto id = [] (int i) { return i; };
-  auto v = views::iota(0) | (views::filter(id)
-			     | views::transform(id)
-			     | views::take(5));
-  VERIFY( ranges::equal(v, (int[]){1,2,3,4,5}) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/iota/iterator.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/iota/iterator.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/iota/iterator.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/iota/iterator.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <ranges>
-
-auto i = std::ranges::iota_view<int>{}.begin();
-static_assert( std::three_way_comparable<decltype(i)> );
-
-struct Inc {
-  Inc& operator++();
-  Inc operator++(int);
-  friend long operator-(Inc, Inc);
-};
-static_assert( ! std::three_way_comparable<Inc> );
-
-// Instantiating iterator type must be valid despite !three_way_comparable<Inc>
-auto j = std::ranges::iota_view<Inc>{}.begin();
-static_assert( ! std::three_way_comparable<decltype(j)> );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/istream_view.cc gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/istream_view.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/istream_view.cc	2020-02-16 23:32:16.000000000 +0100
+++ gcc-10-20200202/libstdc++-v3/testsuite/std/ranges/istream_view.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-// Copyright (C) 2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do run { target c++2a } }
-
-#include <algorithm>
-#include <ranges>
-#include <sstream>
-#include <testsuite_hooks.h>
-#include <testsuite_iterators.h>
-#include <testsuite_rvalref.h>
-
-namespace ranges = std::ranges;
-namespace views = std::views;
-
-struct X : __gnu_test::rvalstruct
-{
-  char c;
-
-  friend std::istream&
-  operator>>(std::istream& is, X& m)
-  {
-    is >> m.c;
-    return is;
-  }
-};
-
-
-void
-test01()
-{
-  std::string s = "0123456789";
-  auto ss = std::istringstream{s};
-  auto v = ranges::istream_view<X>(ss);
-  VERIFY( ranges::equal(v, s, {}, &X::c) );
-}
-
-void
-test02()
-{
-  auto ints = std::istringstream{"0 1  2   3     4"};
-  int x[5];
-  ranges::copy(ranges::istream_view<int>(ints), x);
-  VERIFY( ranges::equal(x, (int[]){0,1,2,3,4}) );
-}
-
-void
-test03()
-{
-  auto input = std::istringstream{"0 1 2 3 4 5 6 7 8 9"};
-  auto small = [](const auto x) noexcept { return x < 5; };
-  auto v = ranges::istream_view<int>(input) | views::take_while(small);
-  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );
-}
-
-int
-main()
-{
-  test01();
-  test02();
-  test03();
-}
