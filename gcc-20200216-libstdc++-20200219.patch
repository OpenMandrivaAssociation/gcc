diff -urN gcc-10-20200216/libstdc++-v3/ChangeLog /home/bero/repos/gcc/libstdc++-v3/ChangeLog
--- gcc-10-20200216/libstdc++-v3/ChangeLog	2020-02-16 23:32:14.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/ChangeLog	2020-02-19 17:37:12.637815803 +0100
@@ -1,3 +1,330 @@
+2020-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/memory_resource (polymorphic_allocator::allocate)
+	(polymorphic_allocator::allocate_object): Change type of exception to
+	bad_array_new_length (LWG 3237).
+	* testsuite/20_util/polymorphic_allocator/lwg3237.cc: New test.
+
+	* include/std/type_traits (__cpp_lib_unwrap_ref): Define (LWG 3348).
+	* include/std/version (__cpp_lib_unwrap_ref): Likewise.
+	* testsuite/20_util/unwrap_reference/1.cc: Check macro.
+	* testsuite/20_util/unwrap_reference/3.cc: New test.
+
+	* include/std/numeric (midpoint(T8, T*)): Do not check for complete
+	type during overload resolution, use static assert instead (LWG 3200).
+	* testsuite/26_numerics/midpoint/pointer.cc: Do not test with
+	incomplete type.
+	* testsuite/26_numerics/midpoint/pointer_neg.cc: New test.
+
+	* include/std/span (span(T (&)[N])): Use non-deduced context to
+	prevent first parameter from interfering with class template argument
+	deduction (LWG 3369).
+	* testsuite/23_containers/span/deduction.cc: Add missing 'const'.
+	* testsuite/23_containers/span/lwg3255.cc: Check for construction from
+	rvalues.
+
+	* include/std/span (span::const_iterator, span::const_reverse_iterator)
+	(span::cbegin(), span::cend(), span::crbegin(), span::crend()):
+	Remove (LWG 3320).
+	* testsuite/23_containers/span/everything.cc: Replace uses of cbegin
+	and cend.
+	* testsuite/20_util/specialized_algorithms/destroy/constrained.cc:
+	Likewise.
+	* testsuite/20_util/specialized_algorithms/uninitialized_copy/
+	constrained.cc: Likewise.
+	* testsuite/20_util/specialized_algorithms/
+	uninitialized_default_construct/constrained.cc: Likewise.
+	* testsuite/20_util/specialized_algorithms/uninitialized_fill/
+	constrained.cc: Likewise.
+	* testsuite/20_util/specialized_algorithms/uninitialized_move/
+	constrained.cc: Likewise.
+	* testsuite/20_util/specialized_algorithms/
+	uninitialized_value_construct/constrained.cc: Likewise.
+
+	* include/bits/range_access.h (range_size_t): Define alias template.
+	* include/std/ranges (all_view): Rename to views::all_t (LWG 3335).
+	* testsuite/std/ranges/adaptors/filter.cc: Adjust to new name.
+
+	* include/std/ranges (filter_view, transform_view, take_view)
+	(join_view, split_view, reverse_view): Remove commented-out converting
+	constructors (LWG 3280).
+
+	* include/std/memory (uninitialized_construct_using_allocator): Use
+	std::construct_at (LWG 3321).
+
+	* include/std/memory_resource (polymorphic_allocator::allocate_bytes)
+	(polymorphic_allocator::allocate_object)
+	(polymorphic_allocator::new_object): Add nodiscard attribute (LWG3304).
+
+	LWG 3379. "safe" in several library names is misleading
+	* include/bits/range_access.h (enable_safe_range): Rename to
+	enable_borrowed_range.
+	(__detail::__maybe_safe_range): Rename to __maybe_borrowed_range.
+	(safe_range): Rename to borrowed_range.
+	* include/bits/ranges_algo.h: Adjust to use new names.
+	* include/bits/ranges_algobase.h: Likewise.
+	* include/bits/ranges_uninitialized.h: Likewise.
+	* include/std/ranges: Likewise.
+	(safe_iterator_t): Rename to borrowed_iterator_t.
+	(safe_subrange_t): Rename to borrowed_subrange_t.
+	* include/std/span: Adjust to use new names.
+	* include/std/string_view: Likewise.
+	* include/experimental/string_view: Likewise.
+	* testsuite/std/ranges/access/begin.cc: Likewise.
+	* testsuite/std/ranges/access/cbegin.cc: Likewise.
+	* testsuite/std/ranges/access/cdata.cc: Likewise.
+	* testsuite/std/ranges/access/cend.cc: Likewise.
+	* testsuite/std/ranges/access/crbegin.cc: Likewise.
+	* testsuite/std/ranges/access/crend.cc: Likewise.
+	* testsuite/std/ranges/access/data.cc: Likewise.
+	* testsuite/std/ranges/access/end.cc: Likewise.
+	* testsuite/std/ranges/access/rbegin.cc: Likewise.
+	* testsuite/std/ranges/access/rend.cc: Likewise.
+	* testsuite/std/ranges/safe_range.cc: Likewise.
+	* testsuite/std/ranges/safe_range_types.cc: Likewise.
+	* testsuite/util/testsuite_iterators.h: Likewise.
+
+	* include/std/ranges (tuple_element<0, const subrange<I, S, K>>)
+	(tuple_element<1, const subrange<I, S, K>>): Add partial
+	specializations (LWG 3398).
+	* testsuite/std/ranges/subrange/tuple_like.cc: New test.
+
+	* include/bits/ranges_algo.h (__find_fn, __find_first_of_fn)
+	(__adjacent_find_fn, __remove_if_fn, __remove_copy_if_fn)
+	(__unique_fn, __unique_copy_fn): Remove redundant conversions to bool.
+
+2020-02-18  Patrick Palka  <ppalka@redhat.com>
+
+	P1983R0 Wording for GB301, US296, US292, US291, and US283
+	* include/std/ranges (filter_view::pred): New member function.
+	(join_view::_Iterator::_Iterator): Remove now-redundant comment since
+	P1983R0 fixes the highlighted issue in the same way.
+	(join_view::_Iterator<_Const>): Add friend
+	join_view::_Iterator<!_Const>.
+	(join_view::_M_inner): Remove mutable specifier, effectively reverting
+	the proposed wording changes of P3278.
+	(join_view::begin): Refine the condition for when to return a const
+	iterator.
+	(split_view::_OuterIter::_OuterIter): Adjust constraints.
+	* testsuite/std/ranges/adaptors/filter.cc: Test that filter_view::pred
+	exists and works.
+
+2020-02-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93818
+	* include/std/ranges (_RangeAdaptor): Add deduction guide.
+	(filter_view::_Iterator): Add alias _Vp_iter and use in place of
+	iterator_t<_Vp>.
+	(filter_view::_Iterator::_S_iter_cat()): Add 'typename'.
+	(transform_view::_Iterator): Add alias _Base_iter and use in place of
+	iterator_t<_Base>.
+	(transform_view::_Iterator::_S_iter_cat()): Add 'typename'.
+	(join_view::_Iterator): Add _Outer_iter and _Inner_iter aliases.
+	(join_view::_Iterator::_S_iter_cat()): Add 'typename'.
+	(split_view::_InnerIter::_S_iter_cat()): Likewise.
+
+	* testsuite/20_util/integer_comparisons/equal.cc: Fix invalid
+	assumption that long is wider than int.
+	* testsuite/20_util/integer_comparisons/greater_equal.cc: Likewise.
+	* testsuite/20_util/integer_comparisons/less.cc: Likewise.
+	* testsuite/20_util/integer_comparisons/less_equal.cc: Likewise.
+	* testsuite/20_util/integer_comparisons/not_equal.cc: Likewise.
+
+	P1976R2 Fixed-size span construction from dynamic range
+	* include/std/span (__cpp_lib_span): Update value.
+	(span(It, size_type), span(It, End)): Make conditionally explicit. Add
+	assertion.
+	(span(R&&), span(const span<OType, OExtent>&)): Likewise and relax
+	constraints.
+	(span::first<Count>(), span::last<Count>()): Use explicit type in
+	return statement.
+	(as_bytes, as_writable_bytes): Likewise.
+	* include/std/version (__cpp_lib_span): Update value.
+	* testsuite/23_containers/span/1.cc: Check new value.
+	* testsuite/23_containers/span/2.cc: Check new value.
+	* testsuite/23_containers/span/explicit.cc: New test.
+
+	* include/std/span (span::__is_compatible_array): Simplify alias
+	template by using requires-clause.
+	(span::__is_compatible_ref): New alias template for constraining
+	constructors.
+	(span::__is_compatible_iterator, span::__is_compatible_range): Remove.
+	(span(It, size_type), span(It, End)): Use __is_compatible_ref.
+	(span(T(&)[N], span(array<T, N>&), span(const array<T, N>&)): Remove
+	redundant parentheses.
+	(span(R&&)): Add missing constraints.
+
+	* include/std/span (span): Reorder members and rename template
+	parameters to match declarations in the C++2a working paper.
+
+	P2116R0 Remove tuple-like protocol support from fixed-extent span
+	* include/std/span (get, tuple_size, tuple_element): Remove.
+	* testsuite/23_containers/span/everything.cc: Remove checks for
+	tuple-like API.
+	* testsuite/23_containers/span/get_neg.cc: Remove.
+	* testsuite/23_containers/span/tuple_element_dynamic_neg.cc: Remove.
+	* testsuite/23_containers/span/tuple_element_oob_neg.cc: Remove.
+	* testsuite/23_containers/span/tuple_size_neg.cc: Remove.
+
+2020-02-17  Patrick Palka  <ppalka@redhat.com>
+
+	P2106R0 Alternative wording for GB315 and GB316
+	* include/bits/ranges_algo.h (in_fun_result): New.
+	(for_each_result, for_each_n_result): Change into an alias of
+	in_fun_result.
+	(in_in_result): New.
+	(mismatch_result): Change into an alias of in_in_result.
+	(copy_if_result): Change into an alias of in_out_result.
+	(swap_ranges_result): Change into an alias of in_in_result.
+	(unary_transform_result): Change into an alias of in_out_result.
+	(in_in_out_result): New.
+	(binary_transform_result): Change into an alias of in_in_out_result.
+	(replace_copy_result, replace_copy_if_result, remove_copy_if_result,
+	remove_copy_result, unique_copy_result, reverse_copy_result,
+	rotate_copy_result, partial_sort_copy_result): Change into an alias of
+	in_out_result.
+	(in_out_out_result): New.
+	(partition_copy_result, merge_result): Change into an alias of
+	in_out_out_result.
+	(set_union_result, set_intersection_result): Change into an alias of
+	in_in_out_result.
+	(set_difference_result): Change into an alias of in_out_result.
+	(set_symmetric_difference): Change into an alias of in_in_out_result.
+	(min_max_result): New.
+	(minmax_result, minmax_element_result): Change into an alias of
+	min_max_result.
+	(in_found_result): New.
+	(next_permutation_result, prev_permutation_result): Change into an alias
+	of in_found_result.
+	(__next_permutation_fn::operator(), __prev_permutation_fn::operator()):
+	Adjust following changes to next_permutation_result and
+	prev_permutation_result.
+	* include/bits/ranges_algobase.h (in_out_result): New.
+	(copy_result, move_result, move_backward_result, copy_backward_result,
+	copy_n_result): Change into an alias of in_out_result.
+	* include/bits/ranges_uninitialized.h (uninitialized_copy_result,
+	uninitialized_copy_n_result, uninitialized_move_result,
+	uninitialized_move_n_result): Likewise.
+	* testsuite/25_algorithms/next_permutation/constrained.cc: Adjust uses of
+	structured bindings.
+	* testsuite/25_algorithms/prev_permutation/constrained.cc: Likewise.
+
+	P1243R4 Rangify new algorithms
+	* include/bits/ranges_algo.h (for_each_n_result, __for_each_n_fn,
+	for_each_n, __sample_fn, sample, __clamp_fn, clamp): New.
+	* testsuite/25_algorithms/clamp/constrained.cc: New test.
+	* testsuite/25_algorithms/for_each/constrained.cc: Augment test.
+	* testsuite/25_algorithms/sample/constrained.cc: New test.
+
+2020-02-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	P1964R2 Wording for boolean-testable
+	* include/bits/ranges_algo.h (__find_fn, __find_first_of_fn)
+	(__adjacent_find_fn): Cast result of predicate to bool.
+	* include/std/concepts (__boolean): Remove.
+	(__detail::__boolean_testable_impl, __detail::__boolean_testable): Add
+	new helper concepts.
+	(__detail::__weakly_eq_cmp_with, totally_ordered, totally_ordered_with)
+	(predicate): Use __boolean_testable instead of boolean.
+	* libsupc++/compare (__detail::__partially_ordered, _Synth3way):
+	Likewise.
+
+	P1970R2 Consistency for size() functions: Add ranges::ssize
+	* include/bits/range_access.h (_SSize, ssize): Define for C++20.
+	* testsuite/std/ranges/access/ssize.cc: New test.
+
+	P1956R1 On the names of low-level bit manipulation functions
+	* include/bits/hashtable_policy.h: Update comment.
+	* include/std/bit (__ispow2, __ceil2, __floor2, __log2p1): Rename.
+	(ispow2, ceil2, floor2, log2p1): Likewise.
+	(__cpp_lib_int_pow2): Add feature test macro.
+	* include/std/charconv (__to_chars_len_2): Adjust use of __log2p1.
+	* include/std/memory (assume_aligned): Adjust use of ispow2.
+	* include/std/version (__cpp_lib_int_pow2): Add.
+	* libsupc++/new_opa.cc: Adjust use of __ispow2.
+	* src/c++17/memory_resource.cc: Likewise, and for __ceil2 and __log2p1.
+	* testsuite/17_intro/freestanding.cc: Adjust use of ispow2.
+	* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: Rename to ...
+	* testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc: ... here.
+	* testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc: Rename to ...
+	* testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc: ... here.
+	* testsuite/26_numerics/bit/bit.pow.two/floor2.cc: Rename to ...
+	* testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc: ... here.
+	* testsuite/26_numerics/bit/bit.pow.two/log2p1.cc: Rename to ...
+	* testsuite/26_numerics/bit/bit.pow.two/bit_width.cc: ... here.
+	* testsuite/26_numerics/bit/bit.pow.two/ispow2.cc: Rename to ...
+	* testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc: ... here.
+
+	* include/std/charconv: Add comment.
+
+	PR libstdc++/92546 (partial)
+	* include/bits/random.h (uniform_random_bit_generator): Move definition
+	to <bits/uniform_int_dist.h>.
+	* include/bits/ranges_algo.h: Include <bits/uniform_int_dist.h> instead
+	of <bits/random.h>.
+	* include/bits/ranges_algobase.h: Do not include <cmath>.
+	* include/bits/uniform_int_dist.h (uniform_random_bit_generator):
+	Move here.
+	* include/std/ranges: Do not include <limits>.
+	* testsuite/26_numerics/random/pr60037-neg.cc: Adjust dg-error lineno.
+
+	PR libstdc++/92546 (partial)
+	* include/Makefile.am: Add new header.
+	* include/Makefile.in: Regenerate.
+	* include/bits/int_limits.h: New header.
+	* include/bits/parse_numbers.h (__select_int::_Select_int): Replace
+	numeric_limits with __detail::__int_limits.
+	* include/std/bit (__rotl, __rotr, __countl_zero, __countl_one)
+	(__countr_zero, __countr_one, __popcount, __ceil2, __floor2, __log2p1):
+	Likewise.
+	* include/std/charconv (__to_chars_8, __from_chars_binary)
+	(__from_chars_alpha_to_num, from_chars): Likewise.
+	* include/std/memory_resource (polymorphic_allocator::allocate)
+	(polymorphic_allocator::allocate_object): Likewise.
+	* include/std/string_view (basic_string_view::_S_compare): Likewise.
+	* include/std/utility (in_range): Likewise.
+	* testsuite/20_util/integer_comparisons/in_range_neg.cc: Adjust for
+	extra error about incomplete type __int_limits<bool>.
+	* testsuite/26_numerics/bit/bit.count/countl_one.cc: Include <limits>.
+	* testsuite/26_numerics/bit/bit.count/countl_zero.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.count/countr_one.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.count/countr_zero.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.count/popcount.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.pow.two/floor2.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.pow.two/ispow2.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.pow.two/log2p1.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.rotate/rotl.cc: Likewise.
+	* testsuite/26_numerics/bit/bit.rotate/rotr.cc: Likewise.
+
+	* python/libstdcxx/v6/printers.py (StdCmpCatPrinter.to_string): Update
+	value for partial_ordering::unordered.
+
+	* include/bits/iterator_concepts.h (indirectly_copyable_storable): Add
+	const-qualified expression variations.
+	* include/std/concepts (copyable): Likewise.
+
+	* include/std/type_traits (__is_standard_integer): New helper trait.
+	* include/std/utility (cmp_equal, cmp_not_equal, cmp_less, cmp_greater)
+	(cmp_less_equal, cmp_greater_equal, in_range): Define for C++20.
+	* include/std/version (__cpp_lib_integer_comparison_functions): Define.
+	* testsuite/20_util/integer_comparisons/1.cc: New test.
+	* testsuite/20_util/integer_comparisons/2.cc: New test.
+	* testsuite/20_util/integer_comparisons/equal.cc: New test.
+	* testsuite/20_util/integer_comparisons/equal_neg.cc: New test.
+	* testsuite/20_util/integer_comparisons/greater_equal.cc: New test.
+	* testsuite/20_util/integer_comparisons/greater_equal_neg.cc: New test.
+	* testsuite/20_util/integer_comparisons/greater_neg.cc: New test.
+	* testsuite/20_util/integer_comparisons/in_range.cc: New test.
+	* testsuite/20_util/integer_comparisons/in_range_neg.cc: New test.
+	* testsuite/20_util/integer_comparisons/less.cc: New test.
+	* testsuite/20_util/integer_comparisons/less_equal.cc: New test.
+	* testsuite/20_util/integer_comparisons/less_equal_neg.cc: New test.
+	* testsuite/20_util/integer_comparisons/less_neg.cc: New test.
+	* testsuite/20_util/integer_comparisons/not_equal.cc: New test.
+	* testsuite/20_util/integer_comparisons/not_equal_neg.cc: New test.
+
 2020-02-16  Patrick Palka  <ppalka@redhat.com>
 
 	* include/bits/ranges_algo.h (__lexicographical_compare_fn::operator()):
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/hashtable_policy.h /home/bero/repos/gcc/libstdc++-v3/include/bits/hashtable_policy.h
--- gcc-10-20200216/libstdc++-v3/include/bits/hashtable_policy.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/hashtable_policy.h	2020-02-19 17:37:12.739815808 +0100
@@ -508,7 +508,7 @@
   inline std::size_t
   __clp2(std::size_t __n) noexcept
   {
-    // Equivalent to return __n ? std::ceil2(__n) : 0;
+    // Equivalent to return __n ? std::bit_ceil(__n) : 0;
     if (__n < 2)
       return __n;
     const unsigned __lz = sizeof(size_t) > sizeof(long)
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/int_limits.h /home/bero/repos/gcc/libstdc++-v3/include/bits/int_limits.h
--- gcc-10-20200216/libstdc++-v3/include/bits/int_limits.h	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/int_limits.h	2020-02-19 17:37:12.739815808 +0100
@@ -0,0 +1,74 @@
+// Minimal replacement for numeric_limits of integers. -*- C++ -*-
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/int_limits.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{limits}
+ */
+
+#ifndef _GLIBCXX_INT_LIMITS_H
+#define _GLIBCXX_INT_LIMITS_H 1
+
+#pragma GCC system_header
+
+#if __cplusplus >= 201103L
+#include <bits/c++config.h>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+namespace __detail
+{
+  // This template is used for arbitrary signed and unsigned integer types
+  // (by headers <bit> and <charconv>) and for specific integer types
+  // (by <memory_resource> and <string_view>) but also for char (<charconv>).
+  // For simplicity's sake, all integral types except bool are supported.
+
+  // Lightweight alternative to numeric_limits<signed integer type>.
+  template<typename _Tp, bool = is_signed<_Tp>::value>
+    struct __int_limits
+    {
+      static_assert(is_integral<_Tp>::value, "unsupported specialization");
+      using _Up = typename make_unsigned<_Tp>::type;
+      static constexpr int digits = sizeof(_Tp) * __CHAR_BIT__ - 1;
+      static constexpr _Tp min() noexcept { return _Tp(_Up(1) << digits); }
+      static constexpr _Tp max() noexcept { return _Tp(_Up(~_Up(0)) >> 1); }
+    };
+
+  // Lightweight alternative to numeric_limits<unsigned integer type>.
+  template<typename _Tp>
+    struct __int_limits<_Tp, false>
+    {
+      static_assert(is_integral<_Tp>::value, "unsupported specialization");
+      static constexpr int digits = sizeof(_Tp) * __CHAR_BIT__;
+      static constexpr _Tp min() noexcept { return 0; }
+      static constexpr _Tp max() noexcept { return _Tp(-1); }
+    };
+
+  template<> struct __int_limits<bool>; // not defined
+}
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
+#endif // C++11
+#endif // _GLIBCXX_INT_LIMITS_H
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/iterator_concepts.h /home/bero/repos/gcc/libstdc++-v3/include/bits/iterator_concepts.h
--- gcc-10-20200216/libstdc++-v3/include/bits/iterator_concepts.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/iterator_concepts.h	2020-02-19 17:37:12.740815808 +0100
@@ -693,7 +693,10 @@
 
   template<typename _In, typename _Out>
     concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
+      && indirectly_writable<_Out, iter_value_t<_In>&>
       && indirectly_writable<_Out, const iter_value_t<_In>&>
+      && indirectly_writable<_Out, iter_value_t<_In>&&>
+      && indirectly_writable<_Out, const iter_value_t<_In>&&>
       && copyable<iter_value_t<_In>>
       && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
       && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/parse_numbers.h /home/bero/repos/gcc/libstdc++-v3/include/bits/parse_numbers.h
--- gcc-10-20200216/libstdc++-v3/include/bits/parse_numbers.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/parse_numbers.h	2020-02-19 17:37:12.741815808 +0100
@@ -34,9 +34,9 @@
 
 // From n3642.pdf except I added binary literals and digit separator '\''.
 
-#if __cplusplus > 201103L
+#if __cplusplus >= 201402L
 
-#include <limits>
+#include <bits/int_limits.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
@@ -265,7 +265,7 @@
 
   template<unsigned long long _Val, typename _IntType, typename... _Ints>
     struct _Select_int_base<_Val, _IntType, _Ints...>
-    : conditional_t<(_Val <= std::numeric_limits<_IntType>::max()),
+    : conditional_t<(_Val <= __detail::__int_limits<_IntType>::max()),
 		    integral_constant<_IntType, _Val>,
 		    _Select_int_base<_Val, _Ints...>>
     { };
@@ -289,6 +289,6 @@
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
-#endif // __cplusplus > 201103L
+#endif // C++14
 
 #endif // _GLIBCXX_PARSE_NUMBERS_H
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/random.h /home/bero/repos/gcc/libstdc++-v3/include/bits/random.h
--- gcc-10-20200216/libstdc++-v3/include/bits/random.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/random.h	2020-02-19 17:37:12.742815808 +0100
@@ -33,9 +33,6 @@
 
 #include <vector>
 #include <bits/uniform_int_dist.h>
-#if __cplusplus > 201703L
-# include <concepts>
-#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
@@ -51,18 +48,7 @@
    * @{
    */
 
-#ifdef __cpp_lib_concepts
-  /// Requirements for a uniform random bit generator.
-  template<typename _Gen>
-    concept uniform_random_bit_generator
-      = invocable<_Gen&> && unsigned_integral<invoke_result_t<_Gen&>>
-      && requires
-      {
-	{ _Gen::min() } -> same_as<invoke_result_t<_Gen&>>;
-	{ _Gen::max() } -> same_as<invoke_result_t<_Gen&>>;
-	requires bool_constant<(_Gen::min() < _Gen::max())>::value;
-      };
-#endif
+  // std::uniform_random_bit_generator is defined in <bits/uniform_int_dist.h>
 
   /**
    * @brief A function template for converting the output of a (integral)
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/range_access.h /home/bero/repos/gcc/libstdc++-v3/include/bits/range_access.h
--- gcc-10-20200216/libstdc++-v3/include/bits/range_access.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/range_access.h	2020-02-19 17:37:12.743815808 +0100
@@ -35,6 +35,7 @@
 #if __cplusplus >= 201103L
 #include <initializer_list>
 #include <bits/iterator_concepts.h>
+#include <bits/int_limits.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
@@ -343,7 +344,7 @@
     inline constexpr bool disable_sized_range = false;
 
   template<typename _Tp>
-    inline constexpr bool enable_safe_range = false;
+    inline constexpr bool enable_borrowed_range = false;
 
   namespace __detail
   {
@@ -356,16 +357,17 @@
       using __make_unsigned_like_t
 	= conditional_t<_MaxDiff, __max_size_type, make_unsigned_t<_Tp>>;
 
-    // Part of the constraints of ranges::safe_range
+    // Part of the constraints of ranges::borrowed_range
     template<typename _Tp>
-      concept __maybe_safe_range
-	= is_lvalue_reference_v<_Tp> || enable_safe_range<remove_cvref_t<_Tp>>;
+      concept __maybe_borrowed_range
+	= is_lvalue_reference_v<_Tp>
+	  || enable_borrowed_range<remove_cvref_t<_Tp>>;
 
   } // namespace __detail
 
   namespace __cust_access
   {
-    using std::ranges::__detail::__maybe_safe_range;
+    using std::ranges::__detail::__maybe_borrowed_range;
     using std::__detail::__class_or_enum;
 
     template<typename _Tp>
@@ -406,7 +408,7 @@
 	}
 
     public:
-      template<__maybe_safe_range _Tp>
+      template<__maybe_borrowed_range _Tp>
 	requires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>
 	  || __adl_begin<_Tp>
 	constexpr auto
@@ -458,7 +460,7 @@
 	}
 
     public:
-      template<__maybe_safe_range _Tp>
+      template<__maybe_borrowed_range _Tp>
 	requires is_array_v<remove_reference_t<_Tp>> || __member_end<_Tp>
 	|| __adl_end<_Tp>
 	constexpr auto
@@ -558,7 +560,7 @@
 	}
 
     public:
-      template<__maybe_safe_range _Tp>
+      template<__maybe_borrowed_range _Tp>
 	requires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>
 	constexpr auto
 	operator()(_Tp&& __t) const
@@ -615,7 +617,7 @@
 	}
 
     public:
-      template<__maybe_safe_range _Tp>
+      template<__maybe_borrowed_range _Tp>
 	requires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>
 	constexpr auto
 	operator()(_Tp&& __t) const
@@ -723,6 +725,32 @@
 	}
     };
 
+    struct _SSize
+    {
+      template<typename _Tp>
+	requires requires (_Tp&& __e)
+	  {
+	    _Begin{}(std::forward<_Tp>(__e));
+	    _Size{}(std::forward<_Tp>(__e));
+	  }
+	constexpr auto
+	operator()(_Tp&& __e) const
+	noexcept(noexcept(_Size{}(std::forward<_Tp>(__e))))
+	{
+	  using __iter_type = decltype(_Begin{}(std::forward<_Tp>(__e)));
+	  using __diff_type = iter_difference_t<__iter_type>;
+	  using std::__detail::__int_limits;
+	  auto __size = _Size{}(std::forward<_Tp>(__e));
+	  if constexpr (integral<__diff_type>)
+	    {
+	      if constexpr (__int_limits<__diff_type>::digits
+			    < __int_limits<ptrdiff_t>::digits)
+		return static_cast<ptrdiff_t>(__size);
+	    }
+	  return static_cast<__diff_type>(__size);
+	}
+    };
+
     template<typename _Tp>
       concept __member_empty = requires(_Tp&& __t)
 	{ bool(std::forward<_Tp>(__t).empty()); };
@@ -834,6 +862,7 @@
     inline constexpr __cust_access::_CRBegin crbegin{};
     inline constexpr __cust_access::_CREnd crend{};
     inline constexpr __cust_access::_Size size{};
+    inline constexpr __cust_access::_SSize ssize{};
     inline constexpr __cust_access::_Empty empty{};
     inline constexpr __cust_access::_Data data{};
     inline constexpr __cust_access::_CData cdata{};
@@ -847,9 +876,10 @@
 	ranges::end(__t);
       };
 
-  /// [range.range] The safe_range concept.
+  /// [range.range] The borrowed_range concept.
   template<typename _Tp>
-    concept safe_range = range<_Tp> && __detail::__maybe_safe_range<_Tp>;
+    concept borrowed_range
+      = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;
 
   template<range _Range>
     using iterator_t = decltype(ranges::begin(std::declval<_Range&>()));
@@ -875,6 +905,9 @@
     concept sized_range = range<_Tp>
       && requires(_Tp& __t) { ranges::size(__t); };
 
+  template<sized_range _Range>
+    using range_size_t = decltype(ranges::size(std::declval<_Range&>()));
+
   // [range.refinements]
 
   /// A range for which ranges::begin returns an output iterator.
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/ranges_algobase.h /home/bero/repos/gcc/libstdc++-v3/include/bits/ranges_algobase.h
--- gcc-10-20200216/libstdc++-v3/include/bits/ranges_algobase.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/ranges_algobase.h	2020-02-19 17:37:12.743815808 +0100
@@ -32,7 +32,6 @@
 
 #if __cplusplus > 201703L
 
-#include <cmath>
 #include <compare>
 #include <iterator>
 // #include <bits/range_concepts.h>
@@ -158,7 +157,7 @@
   inline constexpr __equal_fn equal{};
 
   template<typename _Iter, typename _Out>
-    struct copy_result
+    struct in_out_result
     {
       [[no_unique_address]] _Iter in;
       [[no_unique_address]] _Out out;
@@ -166,24 +165,29 @@
       template<typename _Iter2, typename _Out2>
 	requires convertible_to<const _Iter&, _Iter2>
 	  && convertible_to<const _Out&, _Out2>
-	operator copy_result<_Iter2, _Out2>() const &
+	constexpr
+	operator in_out_result<_Iter2, _Out2>() const &
 	{ return {in, out}; }
 
       template<typename _Iter2, typename _Out2>
 	requires convertible_to<_Iter, _Iter2>
 	  && convertible_to<_Out, _Out2>
-	operator copy_result<_Iter2, _Out2>() &&
+	constexpr
+	operator in_out_result<_Iter2, _Out2>() &&
 	{ return {std::move(in), std::move(out)}; }
     };
 
   template<typename _Iter, typename _Out>
-    using move_result = copy_result<_Iter, _Out>;
+    using copy_result = in_out_result<_Iter, _Out>;
+
+  template<typename _Iter, typename _Out>
+    using move_result = in_out_result<_Iter, _Out>;
 
   template<typename _Iter1, typename _Iter2>
-    using move_backward_result = copy_result<_Iter1, _Iter2>;
+    using move_backward_result = in_out_result<_Iter1, _Iter2>;
 
   template<typename _Iter1, typename _Iter2>
-    using copy_backward_result = copy_result<_Iter1, _Iter2>;
+    using copy_backward_result = in_out_result<_Iter1, _Iter2>;
 
   template<bool _IsMove,
 	   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
@@ -306,7 +310,7 @@
 
     template<input_range _Range, weakly_incrementable _Out>
       requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr copy_result<safe_iterator_t<_Range>, _Out>
+      constexpr copy_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -331,7 +335,7 @@
 
     template<input_range _Range, weakly_incrementable _Out>
       requires indirectly_movable<iterator_t<_Range>, _Out>
-      constexpr move_result<safe_iterator_t<_Range>, _Out>
+      constexpr move_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -448,7 +452,7 @@
 
     template<bidirectional_range _Range, bidirectional_iterator _Iter>
       requires indirectly_copyable<iterator_t<_Range>, _Iter>
-      constexpr copy_backward_result<safe_iterator_t<_Range>, _Iter>
+      constexpr copy_backward_result<borrowed_iterator_t<_Range>, _Iter>
       operator()(_Range&& __r, _Iter __result) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -473,7 +477,7 @@
 
     template<bidirectional_range _Range, bidirectional_iterator _Iter>
       requires indirectly_movable<iterator_t<_Range>, _Iter>
-      constexpr move_backward_result<safe_iterator_t<_Range>, _Iter>
+      constexpr move_backward_result<borrowed_iterator_t<_Range>, _Iter>
       operator()(_Range&& __r, _Iter __result) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -484,7 +488,7 @@
   inline constexpr __move_backward_fn move_backward{};
 
   template<typename _Iter, typename _Out>
-    using copy_n_result = copy_result<_Iter, _Out>;
+    using copy_n_result = in_out_result<_Iter, _Out>;
 
   struct __copy_n_fn
   {
@@ -573,7 +577,7 @@
       }
 
     template<typename _Tp, output_range<const _Tp&> _Range>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, const _Tp& __value) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r), __value);
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/ranges_algo.h /home/bero/repos/gcc/libstdc++-v3/include/bits/ranges_algo.h
--- gcc-10-20200216/libstdc++-v3/include/bits/ranges_algo.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/ranges_algo.h	2020-02-19 17:37:12.743815808 +0100
@@ -33,7 +33,7 @@
 #if __cplusplus > 201703L
 
 #include <bits/ranges_algobase.h>
-#include <bits/random.h> // concept uniform_random_bit_generator
+#include <bits/uniform_int_dist.h> // concept uniform_random_bit_generator
 
 #if __cpp_lib_concepts
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -152,7 +152,7 @@
   inline constexpr __none_of_fn none_of{};
 
   template<typename _Iter, typename _Fp>
-    struct for_each_result
+    struct in_fun_result
     {
       [[no_unique_address]] _Iter in;
       [[no_unique_address]] _Fp fun;
@@ -160,15 +160,20 @@
       template<typename _Iter2, typename _F2p>
 	requires convertible_to<const _Iter&, _Iter2>
 	  && convertible_to<const _Fp&, _F2p>
-	operator for_each_result<_Iter2, _F2p>() const &
+	constexpr
+	operator in_fun_result<_Iter2, _F2p>() const &
 	{ return {in, fun}; }
 
       template<typename _Iter2, typename _F2p>
 	requires convertible_to<_Iter, _Iter2> && convertible_to<_Fp, _F2p>
-	operator for_each_result<_Iter2, _F2p>() &&
+	constexpr
+	operator in_fun_result<_Iter2, _F2p>() &&
 	{ return {std::move(in), std::move(fun)}; }
     };
 
+  template<typename _Iter, typename _Fp>
+    using for_each_result = in_fun_result<_Iter, _Fp>;
+
   struct __for_each_fn
   {
     template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
@@ -185,7 +190,7 @@
     template<input_range _Range, typename _Proj = identity,
 	     indirectly_unary_invocable<projected<iterator_t<_Range>, _Proj>>
 	       _Fun>
-      constexpr for_each_result<safe_iterator_t<_Range>, _Fun>
+      constexpr for_each_result<borrowed_iterator_t<_Range>, _Fun>
       operator()(_Range&& __r, _Fun __f, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -195,6 +200,39 @@
 
   inline constexpr __for_each_fn for_each{};
 
+  template<typename _Iter, typename _Fp>
+    using for_each_n_result = in_fun_result<_Iter, _Fp>;
+
+  struct __for_each_n_fn
+  {
+    template<input_iterator _Iter, typename _Proj = identity,
+	     indirectly_unary_invocable<projected<_Iter, _Proj>> _Fun>
+      constexpr for_each_n_result<_Iter, _Fun>
+      operator()(_Iter __first, iter_difference_t<_Iter> __n,
+		 _Fun __f, _Proj __proj = {}) const
+      {
+	if constexpr (random_access_iterator<_Iter>)
+	  {
+	    if (__n <= 0)
+	      return {std::move(__first), std::move(__f)};
+	    auto __last = __first + __n;
+	    return ranges::for_each(std::move(__first), std::move(__last),
+				    std::move(__f), std::move(__proj));
+	  }
+	else
+	  {
+	    while (__n-- > 0)
+	      {
+		std::__invoke(__f, std::__invoke(__proj, *__first));
+		++__first;
+	      }
+	    return {std::move(__first), std::move(__f)};
+	  }
+      }
+  };
+
+  inline constexpr __for_each_n_fn for_each_n{};
+
   struct __find_fn
   {
     template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
@@ -215,7 +253,7 @@
       requires indirect_binary_predicate<ranges::equal_to,
 					 projected<iterator_t<_Range>, _Proj>,
 					 const _Tp*>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -243,7 +281,7 @@
     template<input_range _Range, typename _Proj = identity,
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -271,7 +309,7 @@
     template<input_range _Range, typename _Proj = identity,
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -307,7 +345,7 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
 				     _Pred, _Proj1, _Proj2>
-      constexpr safe_iterator_t<_Range1>
+      constexpr borrowed_iterator_t<_Range1>
       operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
       {
@@ -383,7 +421,7 @@
   inline constexpr __count_if_fn count_if{};
 
   template<typename _Iter1, typename _Iter2>
-    struct mismatch_result
+    struct in_in_result
     {
       [[no_unique_address]] _Iter1 in1;
       [[no_unique_address]] _Iter2 in2;
@@ -391,16 +429,21 @@
       template<typename _IIter1, typename _IIter2>
 	requires convertible_to<const _Iter1&, _IIter1>
 	  && convertible_to<const _Iter2&, _IIter2>
-	operator mismatch_result<_IIter1, _IIter2>() const &
+	constexpr
+	operator in_in_result<_IIter1, _IIter2>() const &
 	{ return {in1, in2}; }
 
       template<typename _IIter1, typename _IIter2>
 	requires convertible_to<_Iter1, _IIter1>
 	  && convertible_to<_Iter2, _IIter2>
-	operator mismatch_result<_IIter1, _IIter2>() &&
+	constexpr
+	operator in_in_result<_IIter1, _IIter2>() &&
 	{ return {std::move(in1), std::move(in2)}; }
     };
 
+  template<typename _Iter1, typename _Iter2>
+    using mismatch_result = in_in_result<_Iter1, _Iter2>;
+
   struct __mismatch_fn
   {
     template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
@@ -493,7 +536,7 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
 				     _Pred, _Proj1, _Proj2>
-      constexpr safe_subrange_t<_Range1>
+      constexpr borrowed_subrange_t<_Range1>
       operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
       {
@@ -582,7 +625,7 @@
 	     typename _Pred = ranges::equal_to, typename _Proj = identity>
       requires indirectly_comparable<iterator_t<_Range>, const _Tp*,
 				     _Pred, _Proj>
-      constexpr safe_subrange_t<_Range>
+      constexpr borrowed_subrange_t<_Range>
       operator()(_Range&& __r, range_difference_t<_Range> __count,
 	       const _Tp& __value, _Pred __pred = {}, _Proj __proj = {}) const
       {
@@ -658,7 +701,7 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
 				     _Pred, _Proj1, _Proj2>
-      constexpr safe_subrange_t<_Range1>
+      constexpr borrowed_subrange_t<_Range1>
       operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
       {
@@ -699,7 +742,7 @@
 	     indirect_binary_predicate<
 	       projected<iterator_t<_Range>, _Proj>,
 	       projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Pred __pred = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -797,7 +840,7 @@
   inline constexpr __is_permutation_fn is_permutation{};
 
   template<typename _Iter, typename _Out>
-    using copy_if_result = copy_result<_Iter, _Out>;
+    using copy_if_result = in_out_result<_Iter, _Out>;
 
   struct __copy_if_fn
   {
@@ -823,7 +866,7 @@
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr copy_if_result<safe_iterator_t<_Range>, _Out>
+      constexpr copy_if_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result,
 		 _Pred __pred, _Proj __proj = {}) const
       {
@@ -836,7 +879,7 @@
   inline constexpr __copy_if_fn copy_if{};
 
   template<typename _Iter1, typename _Iter2>
-    using swap_ranges_result = mismatch_result<_Iter1, _Iter2>;
+    using swap_ranges_result = in_in_result<_Iter1, _Iter2>;
 
   struct __swap_ranges_fn
   {
@@ -855,8 +898,8 @@
 
     template<input_range _Range1, input_range _Range2>
       requires indirectly_swappable<iterator_t<_Range1>, iterator_t<_Range2>>
-      constexpr swap_ranges_result<safe_iterator_t<_Range1>,
-				   safe_iterator_t<_Range2>>
+      constexpr swap_ranges_result<borrowed_iterator_t<_Range1>,
+				   borrowed_iterator_t<_Range2>>
       operator()(_Range1&& __r1, _Range2&& __r2) const
       {
 	return (*this)(ranges::begin(__r1), ranges::end(__r1),
@@ -867,10 +910,10 @@
   inline constexpr __swap_ranges_fn swap_ranges{};
 
   template<typename _Iter, typename _Out>
-    using unary_transform_result = copy_result<_Iter, _Out>;
+    using unary_transform_result = in_out_result<_Iter, _Out>;
 
   template<typename _Iter1, typename _Iter2, typename _Out>
-    struct binary_transform_result
+    struct in_in_out_result
     {
       [[no_unique_address]] _Iter1 in1;
       [[no_unique_address]] _Iter2 in2;
@@ -880,17 +923,22 @@
 	requires convertible_to<const _Iter1&, _IIter1>
 	  && convertible_to<const _Iter2&, _IIter2>
 	  && convertible_to<const _Out&, _OOut>
-	operator binary_transform_result<_IIter1, _IIter2, _OOut>() const &
+	constexpr
+	operator in_in_out_result<_IIter1, _IIter2, _OOut>() const &
 	{ return {in1, in2, out}; }
 
       template<typename _IIter1, typename _IIter2, typename _OOut>
 	requires convertible_to<_Iter1, _IIter1>
 	  && convertible_to<_Iter2, _IIter2>
 	  && convertible_to<_Out, _OOut>
-	operator binary_transform_result<_IIter1, _IIter2, _OOut>() &&
+	constexpr
+	operator in_in_out_result<_IIter1, _IIter2, _OOut>() &&
 	{ return {std::move(in1), std::move(in2), std::move(out)}; }
     };
 
+  template<typename _Iter1, typename _Iter2, typename _Out>
+    using binary_transform_result = in_in_out_result<_Iter1, _Iter2, _Out>;
+
   struct __transform_fn
   {
     template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
@@ -913,7 +961,7 @@
       requires indirectly_writable<_Out,
 				   indirect_result_t<_Fp&,
 				     projected<iterator_t<_Range>, _Proj>>>
-      constexpr unary_transform_result<safe_iterator_t<_Range>, _Out>
+      constexpr unary_transform_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result, _Fp __op, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -950,8 +998,8 @@
 				   indirect_result_t<_Fp&,
 				     projected<iterator_t<_Range1>, _Proj1>,
 				     projected<iterator_t<_Range2>, _Proj2>>>
-      constexpr binary_transform_result<safe_iterator_t<_Range1>,
-					safe_iterator_t<_Range2>, _Out>
+      constexpr binary_transform_result<borrowed_iterator_t<_Range1>,
+					borrowed_iterator_t<_Range2>, _Out>
       operator()(_Range1&& __r1, _Range2&& __r2, _Out __result, _Fp __binary_op,
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
       {
@@ -988,7 +1036,7 @@
 	&& indirect_binary_predicate<ranges::equal_to,
 				     projected<iterator_t<_Range>, _Proj>,
 				     const _Tp1*>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r,
 		 const _Tp1& __old_value, const _Tp2& __new_value,
 		 _Proj __proj = {}) const
@@ -1020,7 +1068,7 @@
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires indirectly_writable<iterator_t<_Range>, const _Tp&>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r,
 		 _Pred __pred, const _Tp& __new_value, _Proj __proj = {}) const
       {
@@ -1032,7 +1080,7 @@
   inline constexpr __replace_if_fn replace_if{};
 
   template<typename _Iter, typename _Out>
-    using replace_copy_result = copy_result<_Iter, _Out>;
+    using replace_copy_result = in_out_result<_Iter, _Out>;
 
   struct __replace_copy_fn
   {
@@ -1061,7 +1109,7 @@
 	&& indirect_binary_predicate<ranges::equal_to,
 				     projected<iterator_t<_Range>, _Proj>,
 				     const _Tp1*>
-      constexpr replace_copy_result<safe_iterator_t<_Range>, _Out>
+      constexpr replace_copy_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result,
 		 const _Tp1& __old_value, const _Tp2& __new_value,
 		 _Proj __proj = {}) const
@@ -1075,7 +1123,7 @@
   inline constexpr __replace_copy_fn replace_copy{};
 
   template<typename _Iter, typename _Out>
-    using replace_copy_if_result = copy_result<_Iter, _Out>;
+    using replace_copy_if_result = in_out_result<_Iter, _Out>;
 
   struct __replace_copy_if_fn
   {
@@ -1102,7 +1150,7 @@
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr replace_copy_if_result<safe_iterator_t<_Range>, _Out>
+      constexpr replace_copy_if_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result,
 		 _Pred __pred, const _Tp& __new_value, _Proj __proj = {}) const
       {
@@ -1146,7 +1194,7 @@
 
     template<typename _Range, copy_constructible _Fp>
       requires invocable<_Fp&> && output_range<_Range, invoke_result_t<_Fp&>>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Fp __gen) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__gen));
@@ -1171,7 +1219,7 @@
 	auto __result = __first;
 	++__first;
 	for (; __first != __last; ++__first)
-	  if (!(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
+	  if (!std::__invoke(__pred, std::__invoke(__proj, *__first)))
 	    {
 	      *__result = std::move(*__first);
 	      ++__result;
@@ -1184,7 +1232,7 @@
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
+      constexpr borrowed_subrange_t<_Range>
       operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1217,7 +1265,7 @@
 	&& indirect_binary_predicate<ranges::equal_to,
 				     projected<iterator_t<_Range>, _Proj>,
 				     const _Tp*>
-      constexpr safe_subrange_t<_Range>
+      constexpr borrowed_subrange_t<_Range>
       operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1228,7 +1276,7 @@
   inline constexpr __remove_fn remove{};
 
   template<typename _Iter, typename _Out>
-    using remove_copy_if_result = copy_result<_Iter, _Out>;
+    using remove_copy_if_result = in_out_result<_Iter, _Out>;
 
   struct __remove_copy_if_fn
   {
@@ -1241,7 +1289,7 @@
 		 _Pred __pred, _Proj __proj = {}) const
       {
 	for (; __first != __last; ++__first)
-	  if (!(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
+	  if (!std::__invoke(__pred, std::__invoke(__proj, *__first)))
 	    {
 	      *__result = *__first;
 	      ++__result;
@@ -1254,7 +1302,7 @@
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr remove_copy_if_result<safe_iterator_t<_Range>, _Out>
+      constexpr remove_copy_if_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result,
 		 _Pred __pred, _Proj __proj = {}) const
       {
@@ -1267,7 +1315,7 @@
   inline constexpr __remove_copy_if_fn remove_copy_if{};
 
   template<typename _Iter, typename _Out>
-    using remove_copy_result = copy_result<_Iter, _Out>;
+    using remove_copy_result = in_out_result<_Iter, _Out>;
 
   struct __remove_copy_fn
   {
@@ -1296,7 +1344,7 @@
 	&& indirect_binary_predicate<ranges::equal_to,
 				     projected<iterator_t<_Range>, _Proj>,
 				     const _Tp*>
-      constexpr remove_copy_result<safe_iterator_t<_Range>, _Out>
+      constexpr remove_copy_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result,
 		 const _Tp& __value, _Proj __proj = {}) const
       {
@@ -1324,9 +1372,9 @@
 	auto __dest = __first;
 	++__first;
 	while (++__first != __last)
-	  if (!(bool)std::__invoke(__comp,
-				   std::__invoke(__proj, *__dest),
-				   std::__invoke(__proj, *__first)))
+	  if (!std::__invoke(__comp,
+			     std::__invoke(__proj, *__dest),
+			     std::__invoke(__proj, *__first)))
 	    *++__dest = std::move(*__first);
 	return {++__dest, __first};
       }
@@ -1335,7 +1383,7 @@
 	     indirect_equivalence_relation<
 	       projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
       requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
+      constexpr borrowed_subrange_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1346,7 +1394,7 @@
   inline constexpr __unique_fn unique{};
 
   template<typename _Iter, typename _Out>
-    using unique_copy_result = copy_result<_Iter, _Out>;
+    using unique_copy_result = in_out_result<_Iter, _Out>;
 
   struct __unique_copy_fn
   {
@@ -1372,9 +1420,9 @@
 	    auto __next = __first;
 	    *__result = *__next;
 	    while (++__next != __last)
-	      if (!(bool)std::__invoke(__comp,
-				       std::__invoke(__proj, *__first),
-				       std::__invoke(__proj, *__next)))
+	      if (!std::__invoke(__comp,
+				 std::__invoke(__proj, *__first),
+				 std::__invoke(__proj, *__next)))
 		{
 		  __first = __next;
 		  *++__result = *__first;
@@ -1386,9 +1434,9 @@
 	  {
 	    *__result = *__first;
 	    while (++__first != __last)
-	      if (!(bool)std::__invoke(__comp,
-				       std::__invoke(__proj, *__result),
-				       std::__invoke(__proj, *__first)))
+	      if (!std::__invoke(__comp,
+				 std::__invoke(__proj, *__result),
+				 std::__invoke(__proj, *__first)))
 		  *++__result = *__first;
 	    return {std::move(__first), std::move(++__result)};
 	  }
@@ -1419,7 +1467,7 @@
 	    || (input_iterator<_Out>
 		&& same_as<range_value_t<_Range>, iter_value_t<_Out>>)
 	    || indirectly_copyable_storable<iterator_t<_Range>, _Out>)
-      constexpr unique_copy_result<safe_iterator_t<_Range>, _Out>
+      constexpr unique_copy_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
@@ -1471,7 +1519,7 @@
 
     template<bidirectional_range _Range>
       requires permutable<iterator_t<_Range>>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r));
@@ -1481,7 +1529,7 @@
   inline constexpr __reverse_fn reverse{};
 
   template<typename _Iter, typename _Out>
-    using reverse_copy_result = copy_result<_Iter, _Out>;
+    using reverse_copy_result = in_out_result<_Iter, _Out>;
 
   struct __reverse_copy_fn
   {
@@ -1504,7 +1552,7 @@
 
     template<bidirectional_range _Range, weakly_incrementable _Out>
       requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr reverse_copy_result<safe_iterator_t<_Range>, _Out>
+      constexpr reverse_copy_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, _Out __result) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1651,7 +1699,7 @@
 
     template<forward_range _Range>
       requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
+      constexpr borrowed_subrange_t<_Range>
       operator()(_Range&& __r, iterator_t<_Range> __middle) const
       {
 	return (*this)(ranges::begin(__r), std::move(__middle),
@@ -1662,7 +1710,7 @@
   inline constexpr __rotate_fn rotate{};
 
   template<typename _Iter, typename _Out>
-    using rotate_copy_result = copy_result<_Iter, _Out>;
+    using rotate_copy_result = in_out_result<_Iter, _Out>;
 
   struct __rotate_copy_fn
   {
@@ -1684,7 +1732,7 @@
 
     template<forward_range _Range, weakly_incrementable _Out>
       requires indirectly_copyable<iterator_t<_Range>, _Out>
-      constexpr rotate_copy_result<safe_iterator_t<_Range>, _Out>
+      constexpr rotate_copy_result<borrowed_iterator_t<_Range>, _Out>
       operator()(_Range&& __r, iterator_t<_Range> __middle, _Out __result) const
       {
 	return (*this)(ranges::begin(__r), std::move(__middle),
@@ -1694,6 +1742,64 @@
 
   inline constexpr __rotate_copy_fn rotate_copy{};
 
+  struct __sample_fn
+  {
+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
+	     weakly_incrementable _Out, typename _Gen>
+      requires (forward_iterator<_Iter> || random_access_iterator<_Out>)
+	&& indirectly_copyable<_Iter, _Out>
+	&& uniform_random_bit_generator<remove_reference_t<_Gen>>
+      _Out
+      operator()(_Iter __first, _Sent __last, _Out __out,
+		 iter_difference_t<_Iter> __n, _Gen&& __g) const
+      {
+	if constexpr (forward_iterator<_Iter>)
+	  {
+	    // FIXME: Forwarding to std::sample here requires computing __lasti
+	    // which may take linear time.
+	    auto __lasti = ranges::next(__first, __last);
+	    return std::sample(std::move(__first), std::move(__lasti),
+			       std::move(__out), __n, std::forward<_Gen>(__g));
+	  }
+	else
+	  {
+	    using __distrib_type
+	      = uniform_int_distribution<iter_difference_t<_Iter>>;
+	    using __param_type = typename __distrib_type::param_type;
+	    __distrib_type __d{};
+	    iter_difference_t<_Iter> __sample_sz = 0;
+	    while (__first != __last && __sample_sz != __n)
+	      {
+		__out[__sample_sz++] = *__first;
+		++__first;
+	      }
+	    for (auto __pop_sz = __sample_sz; __first != __last;
+		++__first, (void) ++__pop_sz)
+	      {
+		const auto __k = __d(__g, __param_type{0, __pop_sz});
+		if (__k < __n)
+		  __out[__k] = *__first;
+	      }
+	    return __out + __sample_sz;
+	  }
+      }
+
+    template<input_range _Range, weakly_incrementable _Out, typename _Gen>
+      requires (forward_range<_Range> || random_access_iterator<_Out>)
+	&& indirectly_copyable<iterator_t<_Range>, _Out>
+	&& uniform_random_bit_generator<remove_reference_t<_Gen>>
+      _Out
+      operator()(_Range&& __r, _Out __out,
+		 range_difference_t<_Range> __n, _Gen&& __g) const
+      {
+	return (*this)(ranges::begin(__r), ranges::end(__r),
+		       std::move(__out), __n,
+		       std::forward<_Gen>(__g));
+      }
+  };
+
+  inline constexpr __sample_fn sample{};
+
 #ifdef _GLIBCXX_USE_C99_STDINT_TR1
   struct __shuffle_fn
   {
@@ -1712,7 +1818,7 @@
     template<random_access_range _Range, typename _Gen>
       requires permutable<iterator_t<_Range>>
 	&& uniform_random_bit_generator<remove_reference_t<_Gen>>
-      safe_iterator_t<_Range>
+      borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Gen&& __g) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1741,7 +1847,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1769,7 +1875,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1797,7 +1903,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1825,7 +1931,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1862,7 +1968,7 @@
 	     typename _Proj = identity,
 	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1920,7 +2026,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1948,7 +2054,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      safe_iterator_t<_Range>
+      borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -1989,7 +2095,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, iterator_t<_Range> __middle,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
@@ -2002,7 +2108,7 @@
   inline constexpr __partial_sort_fn partial_sort{};
 
   template<typename _Iter, typename _Out>
-    using partial_sort_copy_result = copy_result<_Iter, _Out>;
+    using partial_sort_copy_result = in_out_result<_Iter, _Out>;
 
   struct __partial_sort_copy_fn
   {
@@ -2062,8 +2168,8 @@
 	&& indirect_strict_weak_order<_Comp,
 				      projected<iterator_t<_Range1>, _Proj1>,
 				      projected<iterator_t<_Range2>, _Proj2>>
-      constexpr partial_sort_copy_result<safe_iterator_t<_Range1>,
-					 safe_iterator_t<_Range2>>
+      constexpr partial_sort_copy_result<borrowed_iterator_t<_Range1>,
+					 borrowed_iterator_t<_Range2>>
       operator()(_Range1&& __r, _Range2&& __out, _Comp __comp = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
       {
@@ -2101,7 +2207,7 @@
     template<forward_range _Range, typename _Proj = identity,
 	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -2164,7 +2270,7 @@
     template<random_access_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, iterator_t<_Range> __nth,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
@@ -2208,7 +2314,7 @@
 	     indirect_strict_weak_order<const _Tp*,
 					projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r,
 		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
       {
@@ -2252,7 +2358,7 @@
 	     indirect_strict_weak_order<const _Tp*,
 					projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r,
 		 const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const
       {
@@ -2312,7 +2418,7 @@
 	     indirect_strict_weak_order<const _Tp*,
 					projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr safe_subrange_t<_Range>
+      constexpr borrowed_subrange_t<_Range>
       operator()(_Range&& __r, const _Tp& __value,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
@@ -2448,7 +2554,7 @@
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires permutable<iterator_t<_Range>>
-      constexpr safe_subrange_t<_Range>
+      constexpr borrowed_subrange_t<_Range>
       operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -2479,7 +2585,7 @@
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
       requires permutable<iterator_t<_Range>>
-      safe_subrange_t<_Range>
+      borrowed_subrange_t<_Range>
       operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -2489,28 +2595,33 @@
 
   inline constexpr __stable_partition_fn stable_partition{};
 
-  template<typename _Iter, typename _Out1, typename _O2>
-    struct partition_copy_result
+  template<typename _Iter, typename _Out1, typename _Out2>
+    struct in_out_out_result
     {
       [[no_unique_address]] _Iter  in;
       [[no_unique_address]] _Out1 out1;
-      [[no_unique_address]] _O2 out2;
+      [[no_unique_address]] _Out2 out2;
 
       template<typename _IIter, typename _OOut1, typename _OOut2>
 	requires convertible_to<const _Iter&, _IIter>
 	  && convertible_to<const _Out1&, _OOut1>
-	  && convertible_to<const _O2&, _OOut2>
-	operator partition_copy_result<_IIter, _OOut1, _OOut2>() const &
+	  && convertible_to<const _Out2&, _OOut2>
+	constexpr
+	operator in_out_out_result<_IIter, _OOut1, _OOut2>() const &
 	{ return {in, out1, out2}; }
 
       template<typename _IIter, typename _OOut1, typename _OOut2>
 	requires convertible_to<_Iter, _IIter>
 	  && convertible_to<_Out1, _OOut1>
-	  && convertible_to<_O2, _OOut2>
-	operator partition_copy_result<_IIter, _OOut1, _OOut2>() &&
+	  && convertible_to<_Out2, _OOut2>
+	constexpr
+	operator in_out_out_result<_IIter, _OOut1, _OOut2>() &&
 	{ return {std::move(in), std::move(out1), std::move(out2)}; }
     };
 
+  template<typename _Iter, typename _Out1, typename _Out2>
+    using partition_copy_result = in_out_out_result<_Iter, _Out1, _Out2>;
+
   struct __partition_copy_fn
   {
     template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
@@ -2547,7 +2658,7 @@
 	       _Pred>
       requires indirectly_copyable<iterator_t<_Range>, _Out1>
 	&& indirectly_copyable<iterator_t<_Range>, _O2>
-      constexpr partition_copy_result<safe_iterator_t<_Range>, _Out1, _O2>
+      constexpr partition_copy_result<borrowed_iterator_t<_Range>, _Out1, _O2>
       operator()(_Range&& __r, _Out1 out_true, _O2 out_false,
 		 _Pred __pred, _Proj __proj = {}) const
       {
@@ -2590,7 +2701,7 @@
     template<forward_range _Range, typename _Proj = identity,
 	     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
 	       _Pred>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -2601,7 +2712,7 @@
   inline constexpr __partition_point_fn partition_point{};
 
   template<typename _Iter1, typename _Iter2, typename _Out>
-    using merge_result = binary_transform_result<_Iter1, _Iter2, _Out>;
+    using merge_result = in_in_out_result<_Iter1, _Iter2, _Out>;
 
   struct __merge_fn
   {
@@ -2645,8 +2756,8 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
 			 _Comp, _Proj1, _Proj2>
-      constexpr merge_result<safe_iterator_t<_Range1>,
-			     safe_iterator_t<_Range2>,
+      constexpr merge_result<borrowed_iterator_t<_Range1>,
+			     borrowed_iterator_t<_Range2>,
 			     _Out>
       operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
 		 _Comp __comp = {},
@@ -2680,7 +2791,7 @@
     template<bidirectional_range _Range,
 	     typename _Comp = ranges::less, typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      safe_iterator_t<_Range>
+      borrowed_iterator_t<_Range>
       operator()(_Range&& __r, iterator_t<_Range> __middle,
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
@@ -2743,7 +2854,7 @@
   inline constexpr __includes_fn includes{};
 
   template<typename _Iter1, typename _Iter2, typename _Out>
-    using set_union_result = binary_transform_result<_Iter1, _Iter2, _Out>;
+    using set_union_result = in_in_out_result<_Iter1, _Iter2, _Out>;
 
   struct __set_union_fn
   {
@@ -2795,8 +2906,8 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
 			 _Comp, _Proj1, _Proj2>
-      constexpr set_union_result<safe_iterator_t<_Range1>,
-				 safe_iterator_t<_Range2>, _Out>
+      constexpr set_union_result<borrowed_iterator_t<_Range1>,
+				 borrowed_iterator_t<_Range2>, _Out>
       operator()(_Range1&& __r1, _Range2&& __r2,
 		 _Out __result, _Comp __comp = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
@@ -2811,8 +2922,7 @@
   inline constexpr __set_union_fn set_union{};
 
   template<typename _Iter1, typename _Iter2, typename _Out>
-    using set_intersection_result
-      = binary_transform_result<_Iter1, _Iter2, _Out>;
+    using set_intersection_result = in_in_out_result<_Iter1, _Iter2, _Out>;
 
   struct __set_intersection_fn
   {
@@ -2854,8 +2964,8 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
 			 _Comp, _Proj1, _Proj2>
-      constexpr set_intersection_result<safe_iterator_t<_Range1>,
-					safe_iterator_t<_Range2>, _Out>
+      constexpr set_intersection_result<borrowed_iterator_t<_Range1>,
+					borrowed_iterator_t<_Range2>, _Out>
       operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
 		 _Comp __comp = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
@@ -2870,7 +2980,7 @@
   inline constexpr __set_intersection_fn set_intersection{};
 
   template<typename _Iter, typename _Out>
-    using set_difference_result = copy_result<_Iter, _Out>;
+    using set_difference_result = in_out_result<_Iter, _Out>;
 
   struct __set_difference_fn
   {
@@ -2912,7 +3022,7 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
 			 _Comp, _Proj1, _Proj2>
-      constexpr set_difference_result<safe_iterator_t<_Range1>, _Out>
+      constexpr set_difference_result<borrowed_iterator_t<_Range1>, _Out>
       operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
 		 _Comp __comp = {},
 		 _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
@@ -2928,7 +3038,7 @@
 
   template<typename _Iter1, typename _Iter2, typename _Out>
     using set_symmetric_difference_result
-      = binary_transform_result<_Iter1, _Iter2, _Out>;
+      = in_in_out_result<_Iter1, _Iter2, _Out>;
 
   struct __set_symmetric_difference_fn
   {
@@ -2978,8 +3088,8 @@
 	     typename _Proj1 = identity, typename _Proj2 = identity>
       requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out,
 			 _Comp, _Proj1, _Proj2>
-      constexpr set_symmetric_difference_result<safe_iterator_t<_Range1>,
-						safe_iterator_t<_Range2>,
+      constexpr set_symmetric_difference_result<borrowed_iterator_t<_Range1>,
+						borrowed_iterator_t<_Range2>,
 						_Out>
       operator()(_Range1&& __r1, _Range2&& __r2, _Out __result,
 		 _Comp __comp = {},
@@ -3102,23 +3212,52 @@
 
   inline constexpr __max_fn max{};
 
+  struct __clamp_fn
+  {
+    template<typename _Tp, typename _Proj = identity,
+	     indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp
+	       = ranges::less>
+      constexpr const _Tp&
+      operator()(const _Tp& __val, const _Tp& __lo, const _Tp& __hi,
+		 _Comp __comp = {}, _Proj __proj = {}) const
+      {
+	__glibcxx_assert(!(std::__invoke(__comp,
+					 std::__invoke(__proj, __hi),
+					 std::__invoke(__proj, __lo))));
+	auto&& __proj_val = std::__invoke(__proj, __val);
+	if (std::__invoke(__comp, __proj_val, std::__invoke(__proj, __lo)))
+	  return __lo;
+	else if (std::__invoke(__comp, std::__invoke(__proj, __hi), __proj_val))
+	  return __hi;
+	else
+	  return __val;
+      }
+  };
+
+  inline constexpr __clamp_fn clamp{};
+
   template<typename _Tp>
-    struct minmax_result
+    struct min_max_result
     {
       [[no_unique_address]] _Tp min;
       [[no_unique_address]] _Tp max;
 
       template<typename _Tp2>
 	requires convertible_to<const _Tp&, _Tp2>
-	operator minmax_result<_Tp2>() const &
+	constexpr
+	operator min_max_result<_Tp2>() const &
 	{ return {min, max}; }
 
       template<typename _Tp2>
 	requires convertible_to<_Tp, _Tp2>
-	operator minmax_result<_Tp2>() &&
+	constexpr
+	operator min_max_result<_Tp2>() &&
 	{ return {std::move(min), std::move(max)}; }
     };
 
+  template<typename _Tp>
+    using minmax_result = min_max_result<_Tp>;
+
   struct __minmax_fn
   {
     template<typename _Tp, typename _Proj = identity,
@@ -3204,7 +3343,7 @@
     template<forward_range _Range, typename _Proj = identity,
 	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -3241,7 +3380,7 @@
     template<forward_range _Range, typename _Proj = identity,
 	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -3252,7 +3391,7 @@
   inline constexpr __max_element_fn max_element{};
 
   template<typename _Iter>
-    using minmax_element_result = minmax_result<_Iter>;
+    using minmax_element_result = min_max_result<_Iter>;
 
   struct __minmax_element_fn
   {
@@ -3286,7 +3425,7 @@
     template<forward_range _Range, typename _Proj = identity,
 	     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
 	       _Comp = ranges::less>
-      constexpr minmax_element_result<safe_iterator_t<_Range>>
+      constexpr minmax_element_result<borrowed_iterator_t<_Range>>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -3401,12 +3540,27 @@
   inline constexpr __lexicographical_compare_fn lexicographical_compare;
 
   template<typename _Iter>
-    struct next_permutation_result
+    struct in_found_result
     {
+      [[no_unique_address]] _Iter in;
       bool found;
-      _Iter in;
+
+      template<typename _Iter2>
+	requires convertible_to<const _Iter&, _Iter2>
+	constexpr
+	operator in_found_result<_Iter2>() const &
+	{ return {in, found}; }
+
+      template<typename _Iter2>
+	requires convertible_to<_Iter, _Iter2>
+	constexpr
+	operator in_found_result<_Iter2>() &&
+	{ return {std::move(in), found}; }
     };
 
+  template<typename _Iter>
+    using next_permutation_result = in_found_result<_Iter>;
+
   struct __next_permutation_fn
   {
     template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
@@ -3417,12 +3571,12 @@
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
 	if (__first == __last)
-	  return {false, std::move(__first)};
+	  return {std::move(__first), false};
 
 	auto __i = __first;
 	++__i;
 	if (__i == __last)
-	  return {false, std::move(__i)};
+	  return {std::move(__i), false};
 
 	auto __lasti = ranges::next(__first, __last);
 	__i = __lasti;
@@ -3443,12 +3597,12 @@
 		  ;
 		ranges::iter_swap(__i, __j);
 		ranges::reverse(__ii, __last);
-		return {true, std::move(__lasti)};
+		return {std::move(__lasti), true};
 	      }
 	    if (__i == __first)
 	      {
 		ranges::reverse(__first, __last);
-		return {false, std::move(__lasti)};
+		return {std::move(__lasti), false};
 	      }
 	  }
       }
@@ -3456,7 +3610,7 @@
     template<bidirectional_range _Range, typename _Comp = ranges::less,
 	     typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr next_permutation_result<safe_iterator_t<_Range>>
+      constexpr next_permutation_result<borrowed_iterator_t<_Range>>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
@@ -3467,7 +3621,7 @@
   inline constexpr __next_permutation_fn next_permutation{};
 
   template<typename _Iter>
-    using prev_permutation_result = next_permutation_result<_Iter>;
+    using prev_permutation_result = in_found_result<_Iter>;
 
   struct __prev_permutation_fn
   {
@@ -3479,12 +3633,12 @@
 		 _Comp __comp = {}, _Proj __proj = {}) const
       {
 	if (__first == __last)
-	  return {false, std::move(__first)};
+	  return {std::move(__first), false};
 
 	auto __i = __first;
 	++__i;
 	if (__i == __last)
-	  return {false, std::move(__i)};
+	  return {std::move(__i), false};
 
 	auto __lasti = ranges::next(__first, __last);
 	__i = __lasti;
@@ -3505,12 +3659,12 @@
 		  ;
 		ranges::iter_swap(__i, __j);
 		ranges::reverse(__ii, __last);
-		return {true, std::move(__lasti)};
+		return {std::move(__lasti), true};
 	      }
 	    if (__i == __first)
 	      {
 		ranges::reverse(__first, __last);
-		return {false, std::move(__lasti)};
+		return {std::move(__lasti), false};
 	      }
 	  }
       }
@@ -3518,7 +3672,7 @@
     template<bidirectional_range _Range, typename _Comp = ranges::less,
 	     typename _Proj = identity>
       requires sortable<iterator_t<_Range>, _Comp, _Proj>
-      constexpr prev_permutation_result<safe_iterator_t<_Range>>
+      constexpr prev_permutation_result<borrowed_iterator_t<_Range>>
       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r),
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/ranges_uninitialized.h /home/bero/repos/gcc/libstdc++-v3/include/bits/ranges_uninitialized.h
--- gcc-10-20200216/libstdc++-v3/include/bits/ranges_uninitialized.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/ranges_uninitialized.h	2020-02-19 17:37:12.743815808 +0100
@@ -88,7 +88,7 @@
 
     template<__detail::__nothrow_input_range _Range>
       requires destructible<range_value_t<_Range>>
-      constexpr safe_iterator_t<_Range>
+      constexpr borrowed_iterator_t<_Range>
       operator()(_Range&& __r) const noexcept;
   };
 
@@ -159,7 +159,7 @@
 
     template<__detail::__nothrow_forward_range _Range>
       requires default_initializable<range_value_t<_Range>>
-      safe_iterator_t<_Range>
+      borrowed_iterator_t<_Range>
       operator()(_Range&& __r) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r));
@@ -217,7 +217,7 @@
 
     template<__detail::__nothrow_forward_range _Range>
       requires default_initializable<range_value_t<_Range>>
-      safe_iterator_t<_Range>
+      borrowed_iterator_t<_Range>
       operator()(_Range&& __r) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r));
@@ -253,7 +253,7 @@
     uninitialized_value_construct_n;
 
   template<typename _Iter, typename _Out>
-    using uninitialized_copy_result = copy_result<_Iter, _Out>;
+    using uninitialized_copy_result = in_out_result<_Iter, _Out>;
 
   struct __uninitialized_copy_fn
   {
@@ -290,8 +290,8 @@
     template<input_range _IRange, __detail::__nothrow_forward_range _ORange>
       requires constructible_from<range_value_t<_ORange>,
 				  range_reference_t<_IRange>>
-      uninitialized_copy_result<safe_iterator_t<_IRange>,
-				safe_iterator_t<_ORange>>
+      uninitialized_copy_result<borrowed_iterator_t<_IRange>,
+				borrowed_iterator_t<_ORange>>
       operator()(_IRange&& __inr, _ORange&& __outr) const
       {
 	return (*this)(ranges::begin(__inr), ranges::end(__inr),
@@ -302,7 +302,7 @@
   inline constexpr __uninitialized_copy_fn uninitialized_copy{};
 
   template<typename _Iter, typename _Out>
-    using uninitialized_copy_n_result = uninitialized_copy_result<_Iter, _Out>;
+    using uninitialized_copy_n_result = in_out_result<_Iter, _Out>;
 
   struct __uninitialized_copy_n_fn
   {
@@ -337,7 +337,7 @@
   inline constexpr __uninitialized_copy_n_fn uninitialized_copy_n{};
 
   template<typename _Iter, typename _Out>
-    using uninitialized_move_result = uninitialized_copy_result<_Iter, _Out>;
+    using uninitialized_move_result = in_out_result<_Iter, _Out>;
 
   struct __uninitialized_move_fn
   {
@@ -377,8 +377,8 @@
     template<input_range _IRange, __detail::__nothrow_forward_range _ORange>
       requires constructible_from<range_value_t<_ORange>,
 	       range_rvalue_reference_t<_IRange>>
-      uninitialized_move_result<safe_iterator_t<_IRange>,
-				safe_iterator_t<_ORange>>
+      uninitialized_move_result<borrowed_iterator_t<_IRange>,
+				borrowed_iterator_t<_ORange>>
       operator()(_IRange&& __inr, _ORange&& __outr) const
       {
 	return (*this)(ranges::begin(__inr), ranges::end(__inr),
@@ -389,7 +389,7 @@
   inline constexpr __uninitialized_move_fn uninitialized_move{};
 
   template<typename _Iter, typename _Out>
-    using uninitialized_move_n_result = uninitialized_copy_result<_Iter, _Out>;
+    using uninitialized_move_n_result = in_out_result<_Iter, _Out>;
 
   struct __uninitialized_move_n_fn
   {
@@ -450,7 +450,7 @@
 
     template<__detail::__nothrow_forward_range _Range, typename _Tp>
       requires constructible_from<range_value_t<_Range>, const _Tp&>
-      safe_iterator_t<_Range>
+      borrowed_iterator_t<_Range>
       operator()(_Range&& __r, const _Tp& __x) const
       {
 	return (*this)(ranges::begin(__r), ranges::end(__r), __x);
@@ -531,7 +531,7 @@
 
   template<__detail::__nothrow_input_range _Range>
     requires destructible<range_value_t<_Range>>
-    constexpr safe_iterator_t<_Range>
+    constexpr borrowed_iterator_t<_Range>
     __destroy_fn::operator()(_Range&& __r) const noexcept
     {
       return (*this)(ranges::begin(__r), ranges::end(__r));
diff -urN gcc-10-20200216/libstdc++-v3/include/bits/uniform_int_dist.h /home/bero/repos/gcc/libstdc++-v3/include/bits/uniform_int_dist.h
--- gcc-10-20200216/libstdc++-v3/include/bits/uniform_int_dist.h	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/bits/uniform_int_dist.h	2020-02-19 17:37:12.749815808 +0100
@@ -33,11 +33,27 @@
 
 #include <type_traits>
 #include <limits>
+#if __cplusplus > 201703L
+# include <concepts>
+#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+#ifdef __cpp_lib_concepts
+  /// Requirements for a uniform random bit generator.
+  template<typename _Gen>
+    concept uniform_random_bit_generator
+      = invocable<_Gen&> && unsigned_integral<invoke_result_t<_Gen&>>
+      && requires
+      {
+	{ _Gen::min() } -> same_as<invoke_result_t<_Gen&>>;
+	{ _Gen::max() } -> same_as<invoke_result_t<_Gen&>>;
+	requires bool_constant<(_Gen::min() < _Gen::max())>::value;
+      };
+#endif
+
   namespace __detail
   {
     /* Determine whether number is a power of 2.  */
diff -urN gcc-10-20200216/libstdc++-v3/include/experimental/string_view /home/bero/repos/gcc/libstdc++-v3/include/experimental/string_view
--- gcc-10-20200216/libstdc++-v3/include/experimental/string_view	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/experimental/string_view	2020-02-19 17:37:12.758815808 +0100
@@ -694,11 +694,11 @@
 #if __cpp_lib_concepts
   namespace ranges
   {
-    template<typename> extern inline const bool enable_safe_range;
-    // Opt-in to safe_range concept
+    template<typename> extern inline const bool enable_borrowed_range;
+    // Opt-in to borrowed_range concept
     template<typename _CharT, typename _Traits>
       inline constexpr bool
-	enable_safe_range<experimental::basic_string_view<_CharT, _Traits>>
+	enable_borrowed_range<experimental::basic_string_view<_CharT, _Traits>>
 	  = true;
   }
 #endif
diff -urN gcc-10-20200216/libstdc++-v3/include/Makefile.am /home/bero/repos/gcc/libstdc++-v3/include/Makefile.am
--- gcc-10-20200216/libstdc++-v3/include/Makefile.am	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/Makefile.am	2020-02-19 17:37:12.734815807 +0100
@@ -129,6 +129,7 @@
 	${bits_srcdir}/hashtable.h \
 	${bits_srcdir}/hashtable_policy.h \
 	${bits_srcdir}/indirect_array.h \
+	${bits_srcdir}/int_limits.h \
 	${bits_srcdir}/invoke.h \
 	${bits_srcdir}/ios_base.h \
 	${bits_srcdir}/istream.tcc \
diff -urN gcc-10-20200216/libstdc++-v3/include/Makefile.in /home/bero/repos/gcc/libstdc++-v3/include/Makefile.in
--- gcc-10-20200216/libstdc++-v3/include/Makefile.in	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/Makefile.in	2020-02-19 17:37:12.734815807 +0100
@@ -474,6 +474,7 @@
 	${bits_srcdir}/hashtable.h \
 	${bits_srcdir}/hashtable_policy.h \
 	${bits_srcdir}/indirect_array.h \
+	${bits_srcdir}/int_limits.h \
 	${bits_srcdir}/invoke.h \
 	${bits_srcdir}/ios_base.h \
 	${bits_srcdir}/istream.tcc \
diff -urN gcc-10-20200216/libstdc++-v3/include/std/bit /home/bero/repos/gcc/libstdc++-v3/include/std/bit
--- gcc-10-20200216/libstdc++-v3/include/std/bit	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/bit	2020-02-19 17:37:12.779815809 +0100
@@ -34,7 +34,7 @@
 #if __cplusplus >= 201402L
 
 #include <type_traits>
-#include <limits>
+#include <bits/int_limits.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
@@ -55,7 +55,7 @@
     constexpr _Tp
     __rotl(_Tp __x, int __s) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      constexpr auto _Nd = __detail::__int_limits<_Tp>::digits;
       const int __r = __s % _Nd;
       if (__r == 0)
 	return __x;
@@ -69,7 +69,7 @@
     constexpr _Tp
     __rotr(_Tp __x, int __s) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      constexpr auto _Nd = __detail::__int_limits<_Tp>::digits;
       const int __r = __s % _Nd;
       if (__r == 0)
 	return __x;
@@ -83,14 +83,15 @@
     constexpr int
     __countl_zero(_Tp __x) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      using std::__detail::__int_limits;
+      constexpr auto _Nd = __int_limits<_Tp>::digits;
 
       if (__x == 0)
         return _Nd;
 
-      constexpr auto _Nd_ull = numeric_limits<unsigned long long>::digits;
-      constexpr auto _Nd_ul = numeric_limits<unsigned long>::digits;
-      constexpr auto _Nd_u = numeric_limits<unsigned>::digits;
+      constexpr auto _Nd_ull = __int_limits<unsigned long long>::digits;
+      constexpr auto _Nd_ul = __int_limits<unsigned long>::digits;
+      constexpr auto _Nd_u = __int_limits<unsigned>::digits;
 
       if _GLIBCXX17_CONSTEXPR (_Nd <= _Nd_u)
 	{
@@ -118,7 +119,7 @@
 	      constexpr int __diff = (2 * _Nd_ull) - _Nd;
 	      return __builtin_clzll(__high) - __diff;
 	    }
-	  constexpr auto __max_ull = numeric_limits<unsigned long long>::max();
+	  constexpr auto __max_ull = __int_limits<unsigned long long>::max();
 	  unsigned long long __low = __x & __max_ull;
 	  return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 	}
@@ -128,8 +129,8 @@
     constexpr int
     __countl_one(_Tp __x) noexcept
     {
-      if (__x == numeric_limits<_Tp>::max())
-        return numeric_limits<_Tp>::digits;
+      if (__x == __detail::__int_limits<_Tp>::max())
+	return __detail::__int_limits<_Tp>::digits;
       return std::__countl_zero<_Tp>((_Tp)~__x);
     }
 
@@ -137,14 +138,15 @@
     constexpr int
     __countr_zero(_Tp __x) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      using std::__detail::__int_limits;
+      constexpr auto _Nd = __int_limits<_Tp>::digits;
 
       if (__x == 0)
         return _Nd;
 
-      constexpr auto _Nd_ull = numeric_limits<unsigned long long>::digits;
-      constexpr auto _Nd_ul = numeric_limits<unsigned long>::digits;
-      constexpr auto _Nd_u = numeric_limits<unsigned>::digits;
+      constexpr auto _Nd_ull = __int_limits<unsigned long long>::digits;
+      constexpr auto _Nd_ul = __int_limits<unsigned long>::digits;
+      constexpr auto _Nd_u = __int_limits<unsigned>::digits;
 
       if _GLIBCXX17_CONSTEXPR (_Nd <= _Nd_u)
 	return __builtin_ctz(__x);
@@ -157,7 +159,7 @@
 	  static_assert(_Nd <= (2 * _Nd_ull),
 			"Maximum supported integer size is 128-bit");
 
-	  constexpr auto __max_ull = numeric_limits<unsigned long long>::max();
+	  constexpr auto __max_ull = __int_limits<unsigned long long>::max();
 	  unsigned long long __low = __x & __max_ull;
 	  if (__low != 0)
 	    return __builtin_ctzll(__low);
@@ -170,8 +172,8 @@
     constexpr int
     __countr_one(_Tp __x) noexcept
     {
-      if (__x == numeric_limits<_Tp>::max())
-        return numeric_limits<_Tp>::digits;
+      if (__x == __detail::__int_limits<_Tp>::max())
+	return __detail::__int_limits<_Tp>::digits;
       return std::__countr_zero((_Tp)~__x);
     }
 
@@ -179,14 +181,15 @@
     constexpr int
     __popcount(_Tp __x) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      using std::__detail::__int_limits;
+      constexpr auto _Nd = __int_limits<_Tp>::digits;
 
       if (__x == 0)
         return 0;
 
-      constexpr auto _Nd_ull = numeric_limits<unsigned long long>::digits;
-      constexpr auto _Nd_ul = numeric_limits<unsigned long>::digits;
-      constexpr auto _Nd_u = numeric_limits<unsigned>::digits;
+      constexpr auto _Nd_ull = __int_limits<unsigned long long>::digits;
+      constexpr auto _Nd_ul = __int_limits<unsigned long>::digits;
+      constexpr auto _Nd_u = __int_limits<unsigned>::digits;
 
       if _GLIBCXX17_CONSTEXPR (_Nd <= _Nd_u)
 	return __builtin_popcount(__x);
@@ -199,7 +202,7 @@
 	  static_assert(_Nd <= (2 * _Nd_ull),
 			"Maximum supported integer size is 128-bit");
 
-	  constexpr auto __max_ull = numeric_limits<unsigned long long>::max();
+	  constexpr auto __max_ull = __int_limits<unsigned long long>::max();
 	  unsigned long long __low = __x & __max_ull;
 	  unsigned long long __high = __x >> _Nd_ull;
 	  return __builtin_popcountll(__low) + __builtin_popcountll(__high);
@@ -208,14 +211,15 @@
 
   template<typename _Tp>
     constexpr bool
-    __ispow2(_Tp __x) noexcept
+    __has_single_bit(_Tp __x) noexcept
     { return std::__popcount(__x) == 1; }
 
   template<typename _Tp>
     constexpr _Tp
-    __ceil2(_Tp __x) noexcept
+    __bit_ceil(_Tp __x) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      using std::__detail::__int_limits;
+      constexpr auto _Nd = __int_limits<_Tp>::digits;
       if (__x == 0 || __x == 1)
         return 1;
       auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));
@@ -226,7 +230,7 @@
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
       if (!__builtin_is_constant_evaluated())
 	{
-	  __glibcxx_assert( __shift_exponent != numeric_limits<_Tp>::digits );
+	  __glibcxx_assert( __shift_exponent != __int_limits<_Tp>::digits );
 	}
 #endif
       using __promoted_type = decltype(__x << 1);
@@ -245,9 +249,9 @@
 
   template<typename _Tp>
     constexpr _Tp
-    __floor2(_Tp __x) noexcept
+    __bit_floor(_Tp __x) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      constexpr auto _Nd = __detail::__int_limits<_Tp>::digits;
       if (__x == 0)
         return 0;
       return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
@@ -255,9 +259,9 @@
 
   template<typename _Tp>
     constexpr _Tp
-    __log2p1(_Tp __x) noexcept
+    __bit_width(_Tp __x) noexcept
     {
-      constexpr auto _Nd = numeric_limits<_Tp>::digits;
+      constexpr auto _Nd = __detail::__int_limits<_Tp>::digits;
       return _Nd - std::__countl_zero(__x);
     }
 
@@ -321,29 +325,31 @@
 
   // [bit.pow.two], integral powers of 2
 
+#define __cpp_lib_int_pow2 202002L
+
   /// True if `x` is a power of two, false otherwise.
   template<typename _Tp>
     constexpr _If_is_unsigned_integer<_Tp, bool>
-    ispow2(_Tp __x) noexcept
-    { return std::__ispow2(__x); }
+    has_single_bit(_Tp __x) noexcept
+    { return std::__has_single_bit(__x); }
 
   /// The smallest power-of-two not less than `x`.
   template<typename _Tp>
     constexpr _If_is_unsigned_integer<_Tp>
-    ceil2(_Tp __x) noexcept
-    { return std::__ceil2(__x); }
+    bit_ceil(_Tp __x) noexcept
+    { return std::__bit_ceil(__x); }
 
   /// The largest power-of-two not greater than `x`.
   template<typename _Tp>
     constexpr _If_is_unsigned_integer<_Tp>
-    floor2(_Tp __x) noexcept
-    { return std::__floor2(__x); }
+    bit_floor(_Tp __x) noexcept
+    { return std::__bit_floor(__x); }
 
   /// The smallest integer greater than the base-2 logarithm of `x`.
   template<typename _Tp>
     constexpr _If_is_unsigned_integer<_Tp>
-    log2p1(_Tp __x) noexcept
-    { return std::__log2p1(__x); }
+    bit_width(_Tp __x) noexcept
+    { return std::__bit_width(__x); }
 
 #define __cpp_lib_endian 201907L
 
diff -urN gcc-10-20200216/libstdc++-v3/include/std/charconv /home/bero/repos/gcc/libstdc++-v3/include/std/charconv
--- gcc-10-20200216/libstdc++-v3/include/std/charconv	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/charconv	2020-02-19 17:37:12.779815809 +0100
@@ -31,14 +31,18 @@
 
 #pragma GCC system_header
 
+// As an extension we support <charconv> in C++14, but this header should not
+// be included by any other library headers in C++14 mode. This ensures that
+// the names defined in this header are not added to namespace std unless a
+// user explicitly includes <charconv> in C++14 code.
 #if __cplusplus >= 201402L
 
 #include <type_traits>
-#include <limits>
-#include <bit>			// for __log2p1
+#include <bit>			// for __bit_width
 #include <cctype>		// for isdigit
 #include <bits/charconv.h>	// for __to_chars_len, __to_chars_10_impl
 #include <bits/error_constants.h> // for std::errc
+#include <bits/int_limits.h>
 
 // Define when floating point is supported: #define __cpp_lib_to_chars 201611L
 
@@ -97,7 +101,7 @@
   template<typename _Tp>
     constexpr unsigned
     __to_chars_len_2(_Tp __value) noexcept
-    { return std::__log2p1(__value); }
+    { return std::__bit_width(__value); }
 
   // Generic implementation for arbitrary bases.
   template<typename _Tp>
@@ -222,7 +226,7 @@
       to_chars_result __res;
       unsigned __len;
 
-      if _GLIBCXX17_CONSTEXPR (numeric_limits<_Tp>::digits <= 16)
+      if _GLIBCXX17_CONSTEXPR (__detail::__int_limits<_Tp>::digits <= 16)
 	{
 	  __len = __val > 077777u ? 6u
 	    : __val > 07777u ? 5u
@@ -410,7 +414,7 @@
 	  __i++;
 	}
       __first += __i;
-      return __i <= numeric_limits<_Tp>::digits;
+      return __i <= __detail::__int_limits<_Tp>::digits;
     }
 
   /// std::from_chars implementation for integers in bases 3 to 10.
@@ -529,7 +533,7 @@
     case 'Z':
       return 35;
     }
-    return std::numeric_limits<unsigned char>::max();
+    return __detail::__int_limits<unsigned char>::max();
   }
 
   /// std::from_chars implementation for integers in bases 11 to 26.
@@ -616,10 +620,10 @@
 		}
 	      else
 		{
-		  if _GLIBCXX17_CONSTEXPR
-		    (numeric_limits<_Up>::max() > numeric_limits<_Tp>::max())
+		  if _GLIBCXX17_CONSTEXPR (__detail::__int_limits<_Up>::max()
+		      > __detail::__int_limits<_Tp>::max())
 		    {
-		      if (__val > numeric_limits<_Tp>::max())
+		      if (__val > __detail::__int_limits<_Tp>::max())
 			__res.ec = errc::result_out_of_range;
 		      else
 			__value = __val;
diff -urN gcc-10-20200216/libstdc++-v3/include/std/concepts /home/bero/repos/gcc/libstdc++-v3/include/std/concepts
--- gcc-10-20200216/libstdc++-v3/include/std/concepts	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/concepts	2020-02-19 17:37:12.780815809 +0100
@@ -251,34 +251,26 @@
 
   template<typename _Tp>
     concept copyable = copy_constructible<_Tp> && movable<_Tp>
-      && assignable_from<_Tp&, const _Tp&>;
+      && assignable_from<_Tp&, _Tp&> && assignable_from<_Tp&, const _Tp&>
+      && assignable_from<_Tp&, const _Tp>;
 
   template<typename _Tp>
     concept semiregular = copyable<_Tp> && default_initializable<_Tp>;
 
   // [concepts.compare], comparison concepts
 
-  /// [concept.boolean], concept boolean
-  template<typename _Bp>
-    concept boolean
-      = movable<remove_cvref_t<_Bp>>
-      && requires(__detail::__cref<_Bp> __b1, __detail::__cref<_Bp> __b2,
-		  const bool __a) {
-	{ __b1 } -> convertible_to<bool>;
-	{ !__b1 } -> convertible_to<bool>;
-	{ __b1 && __b2 } -> same_as<bool>;
-	{ __b1 && __a  } -> same_as<bool>;
-	{ __a  && __b2 } -> same_as<bool>;
-	{ __b1 || __b2 } -> same_as<bool>;
-	{ __b1 || __a  } -> same_as<bool>;
-	{ __a  || __b2 } -> same_as<bool>;
-	{ __b1 == __b2 } -> convertible_to<bool>;
-	{ __b1 == __a  } -> convertible_to<bool>;
-	{ __a  == __b2 } -> convertible_to<bool>;
-	{ __b1 != __b2 } -> convertible_to<bool>;
-	{ __b1 != __a  } -> convertible_to<bool>;
-	{ __a  != __b2 } -> convertible_to<bool>;
-      };
+  // [concept.booleantestable], Boolean testability
+  namespace __detail
+  {
+    template<typename _Tp>
+      concept __boolean_testable_impl = convertible_to<_Tp, bool>;
+
+    template<typename _Tp>
+      concept __boolean_testable
+	= __boolean_testable_impl<_Tp>
+	  && requires(_Tp&& __t)
+	  { { !static_cast<_Tp&&>(__t) } -> __boolean_testable_impl; };
+  } // namespace __detail
 
   // [concept.equalitycomparable], concept equality_comparable
 
@@ -287,10 +279,10 @@
     template<typename _Tp, typename _Up>
       concept __weakly_eq_cmp_with
 	= requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
-	  { __t == __u } -> boolean;
-	  { __t != __u } -> boolean;
-	  { __u == __t } -> boolean;
-	  { __u != __t } -> boolean;
+	  { __t == __u } -> __boolean_testable;
+	  { __t != __u } -> __boolean_testable;
+	  { __u == __t } -> __boolean_testable;
+	  { __u != __t } -> __boolean_testable;
 	};
   } // namespace __detail
 
@@ -310,10 +302,10 @@
     concept totally_ordered
       = equality_comparable<_Tp>
       && requires(__detail::__cref<_Tp> __a, __detail::__cref<_Tp> __b) {
-	{ __a <  __b } -> boolean;
-	{ __a >  __b } -> boolean;
-	{ __a <= __b } -> boolean;
-	{ __a >= __b } -> boolean;
+	{ __a <  __b } -> __detail::__boolean_testable;
+	{ __a >  __b } -> __detail::__boolean_testable;
+	{ __a <= __b } -> __detail::__boolean_testable;
+	{ __a >= __b } -> __detail::__boolean_testable;
       };
 
   template<typename _Tp, typename _Up>
@@ -324,14 +316,14 @@
 					    __detail::__cref<_Up>>>
       && equality_comparable_with<_Tp, _Up>
       && requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
-	{ __t <  __u } -> boolean;
-	{ __t >  __u } -> boolean;
-	{ __t <= __u } -> boolean;
-	{ __t >= __u } -> boolean;
-	{ __u <  __t } -> boolean;
-	{ __u >  __t } -> boolean;
-	{ __u <= __t } -> boolean;
-	{ __u >= __t } -> boolean;
+	{ __t <  __u } -> __detail::__boolean_testable;
+	{ __t >  __u } -> __detail::__boolean_testable;
+	{ __t <= __u } -> __detail::__boolean_testable;
+	{ __t >= __u } -> __detail::__boolean_testable;
+	{ __u <  __t } -> __detail::__boolean_testable;
+	{ __u >  __t } -> __detail::__boolean_testable;
+	{ __u <= __t } -> __detail::__boolean_testable;
+	{ __u >= __t } -> __detail::__boolean_testable;
       };
 
   template<typename _Tp>
@@ -350,7 +342,7 @@
   /// [concept.predicate], concept predicate
   template<typename _Fn, typename... _Args>
     concept predicate = regular_invocable<_Fn, _Args...>
-      && boolean<invoke_result_t<_Fn, _Args...>>;
+      && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;
 
   /// [concept.relation], concept relation
   template<typename _Rel, typename _Tp, typename _Up>
diff -urN gcc-10-20200216/libstdc++-v3/include/std/memory /home/bero/repos/gcc/libstdc++-v3/include/std/memory
--- gcc-10-20200216/libstdc++-v3/include/std/memory	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/memory	2020-02-19 17:37:12.782815809 +0100
@@ -93,7 +93,7 @@
 #if __cplusplus >= 201103L
 #include <cstdint>
 #if __cplusplus > 201703L
-# include <bit>			// for ispow2
+# include <bit>			// for has_single_bit
 # include <new>			// for placement operator new
 # include <tuple>		// for tuple, make_tuple, make_from_tuple
 #endif
@@ -191,7 +191,7 @@
     [[nodiscard,__gnu__::__always_inline__]]
     constexpr _Tp* assume_aligned(_Tp* __ptr)
     {
-      static_assert(std::ispow2(_Align));
+      static_assert(std::has_single_bit(_Align));
       _GLIBCXX_DEBUG_ASSERT((std::uintptr_t)__ptr % _Align == 0);
       return static_cast<_Tp*>(__builtin_assume_aligned(__ptr, _Align));
     }
@@ -387,9 +387,10 @@
     uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,
 					    _Args&&... __args)
     {
-      void* __vp = const_cast<void*>(static_cast<const volatile void*>(__p));
-      return ::new(__vp) _Tp(std::make_obj_using_allocator<_Tp>(__a,
-	    std::forward<_Args>(__args)...));
+      return std::apply([&](auto&&... __xs) {
+	return std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);
+      }, std::uses_allocator_construction_args<_Tp>(__a,
+	std::forward<_Args>(__args)...));
     }
 // @}
 
diff -urN gcc-10-20200216/libstdc++-v3/include/std/memory_resource /home/bero/repos/gcc/libstdc++-v3/include/std/memory_resource
--- gcc-10-20200216/libstdc++-v3/include/std/memory_resource	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/memory_resource	2020-02-19 17:37:12.782815809 +0100
@@ -33,13 +33,13 @@
 
 #if __cplusplus >= 201703L
 
-#include <limits>			// numeric_limits
 #include <memory>			// align, allocator_arg_t, __uses_alloc
 #include <utility>			// pair, index_sequence
 #include <vector>			// vector
 #include <cstddef>			// size_t, max_align_t, byte
 #include <shared_mutex>			// shared_mutex
 #include <bits/functexcept.h>
+#include <bits/int_limits.h>
 #include <debug/assertions.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -166,8 +166,8 @@
       allocate(size_t __n)
       __attribute__((__returns_nonnull__))
       {
-	if (__n > (numeric_limits<size_t>::max() / sizeof(_Tp)))
-	  std::__throw_bad_alloc();
+	if (__n > (__detail::__int_limits<size_t>::max() / sizeof(_Tp)))
+	  _GLIBCXX_THROW_OR_ABORT(bad_array_new_length());
 	return static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),
 						       alignof(_Tp)));
       }
@@ -178,7 +178,7 @@
       { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }
 
 #if __cplusplus > 201703L
-      void*
+      [[nodiscard]] void*
       allocate_bytes(size_t __nbytes,
 		     size_t __alignment = alignof(max_align_t))
       { return _M_resource->allocate(__nbytes, __alignment); }
@@ -189,11 +189,11 @@
       { _M_resource->deallocate(__p, __nbytes, __alignment); }
 
       template<typename _Up>
-	_Up*
+	[[nodiscard]] _Up*
 	allocate_object(size_t __n = 1)
 	{
-	  if ((std::numeric_limits<size_t>::max() / sizeof(_Up)) < __n)
-	    __throw_length_error("polymorphic_allocator::allocate_object");
+	  if ((__detail::__int_limits<size_t>::max() / sizeof(_Up)) < __n)
+	    _GLIBCXX_THROW_OR_ABORT(bad_array_new_length());
 	  return static_cast<_Up*>(allocate_bytes(__n * sizeof(_Up),
 						  alignof(_Up)));
 	}
@@ -204,7 +204,7 @@
 	{ deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up)); }
 
       template<typename _Up, typename... _CtorArgs>
-	_Up*
+	[[nodiscard]] _Up*
 	new_object(_CtorArgs&&... __ctor_args)
 	{
 	  _Up* __p = allocate_object<_Up>();
diff -urN gcc-10-20200216/libstdc++-v3/include/std/numeric /home/bero/repos/gcc/libstdc++-v3/include/std/numeric
--- gcc-10-20200216/libstdc++-v3/include/std/numeric	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/numeric	2020-02-19 17:37:12.782815809 +0100
@@ -208,10 +208,10 @@
     }
 
   template<typename _Tp>
-    constexpr
-    enable_if_t<__and_v<is_object<_Tp>, bool_constant<sizeof(_Tp) != 0>>, _Tp*>
+    constexpr enable_if_t<is_object_v<_Tp>, _Tp*>
     midpoint(_Tp* __a, _Tp* __b) noexcept
     {
+      static_assert( sizeof(_Tp) != 0, "type must be complete" );
       return __a  + (__b - __a) / 2;
     }
 _GLIBCXX_END_NAMESPACE_VERSION
diff -urN gcc-10-20200216/libstdc++-v3/include/std/ranges /home/bero/repos/gcc/libstdc++-v3/include/std/ranges
--- gcc-10-20200216/libstdc++-v3/include/std/ranges	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/ranges	2020-02-19 17:37:12.783815809 +0100
@@ -42,7 +42,6 @@
 #include <compare>
 #include <initializer_list>
 #include <iterator>
-#include <limits>
 #include <optional>
 #include <tuple>
 
@@ -94,7 +93,7 @@
   /// A range which can be safely converted to a view.
   template<typename _Tp>
     concept viewable_range = range<_Tp>
-      && (safe_range<_Tp> || view<remove_cvref_t<_Tp>>);
+      && (borrowed_range<_Tp> || view<remove_cvref_t<_Tp>>);
 
   namespace __detail
   {
@@ -295,7 +294,7 @@
       }
 
       template<__detail::__not_same_as<subrange> _Rng>
-	requires safe_range<_Rng>
+	requires borrowed_range<_Rng>
 	  && convertible_to<iterator_t<_Rng>, _It>
 	  && convertible_to<sentinel_t<_Rng>, _Sent>
 	constexpr
@@ -306,7 +305,7 @@
 	    _M_size._M_size = ranges::size(__r);
 	}
 
-      template<safe_range _Rng>
+      template<borrowed_range _Rng>
 	requires convertible_to<iterator_t<_Rng>, _It>
 	  && convertible_to<sentinel_t<_Rng>, _Sent>
 	constexpr
@@ -418,14 +417,14 @@
       -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,
 		  subrange_kind::sized>;
 
-  template<safe_range _Rng>
+  template<borrowed_range _Rng>
     subrange(_Rng&&)
       -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
 		 (sized_range<_Rng>
 		  || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)
 		 ? subrange_kind::sized : subrange_kind::unsized>;
 
-  template<safe_range _Rng>
+  template<borrowed_range _Rng>
     subrange(_Rng&&,
 	     __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)
       -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;
@@ -455,7 +454,7 @@
   template<input_or_output_iterator _It, sentinel_for<_It> _Sent,
 	   subrange_kind _Kind>
     inline constexpr bool
-      enable_safe_range<subrange<_It, _Sent, _Kind>> = true;
+      enable_borrowed_range<subrange<_It, _Sent, _Kind>> = true;
 
 } // namespace ranges
 
@@ -472,14 +471,14 @@
   };
 
   template<range _Range>
-    using safe_iterator_t = conditional_t<safe_range<_Range>,
-					  iterator_t<_Range>,
-					  dangling>;
+    using borrowed_iterator_t = conditional_t<borrowed_range<_Range>,
+					      iterator_t<_Range>,
+					      dangling>;
 
   template<range _Range>
-    using safe_subrange_t = conditional_t<safe_range<_Range>,
-					  subrange<iterator_t<_Range>>,
-					  dangling>;
+    using borrowed_subrange_t = conditional_t<borrowed_range<_Range>,
+					      subrange<iterator_t<_Range>>,
+					      dangling>;
 
   template<typename _Tp> requires is_object_v<_Tp>
     class empty_view
@@ -494,7 +493,7 @@
     };
 
   template<typename _Tp>
-    inline constexpr bool enable_safe_range<empty_view<_Tp>> = true;
+    inline constexpr bool enable_borrowed_range<empty_view<_Tp>> = true;
 
   namespace __detail
   {
@@ -920,7 +919,8 @@
     iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;
 
   template<weakly_incrementable _Winc, semiregular _Bound>
-    inline constexpr bool enable_safe_range<iota_view<_Winc, _Bound>> = true;
+    inline constexpr bool
+      enable_borrowed_range<iota_view<_Winc, _Bound>> = true;
 
 namespace views
 {
@@ -1104,6 +1104,9 @@
       };
 
     template<typename _Callable>
+      _RangeAdaptor(_Callable) -> _RangeAdaptor<_Callable>;
+
+    template<typename _Callable>
       struct _RangeAdaptorClosure : public _RangeAdaptor<_Callable>
       {
 	using _RangeAdaptor<_Callable>::_RangeAdaptor;
@@ -1219,7 +1222,7 @@
     ref_view(_Range&) -> ref_view<_Range>;
 
   template<typename _Tp>
-    inline constexpr bool enable_safe_range<ref_view<_Tp>> = true;
+    inline constexpr bool enable_borrowed_range<ref_view<_Tp>> = true;
 
   namespace views
   {
@@ -1233,10 +1236,11 @@
 	else
 	  return subrange{std::forward<_Range>(__r)};
       };
-  } // namespace views
 
-  template<viewable_range _Range>
-    using all_view = decltype(views::all(declval<_Range>()));
+    template<viewable_range _Range>
+      using all_t = decltype(all(std::declval<_Range>()));
+
+  } // namespace views
 
   // XXX: the following algos are copied from ranges_algo.h to avoid a circular
   // dependency with that header.
@@ -1326,7 +1330,7 @@
 	static constexpr auto
 	_S_iter_cat()
 	{
-	  using _Cat = iterator_traits<iterator_t<_Vp>>::iterator_category;
+	  using _Cat = typename iterator_traits<_Vp_iter>::iterator_category;
 	  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)
 	    return bidirectional_iterator_tag{};
 	  else if constexpr (derived_from<_Cat, forward_iterator_tag>)
@@ -1337,7 +1341,9 @@
 
 	friend filter_view;
 
-	iterator_t<_Vp> _M_current = iterator_t<_Vp>();
+	using _Vp_iter = iterator_t<_Vp>;
+
+	_Vp_iter _M_current = _Vp_iter();
 	filter_view* _M_parent = nullptr;
 
       public:
@@ -1349,17 +1355,17 @@
 	_Iterator() = default;
 
 	constexpr
-	_Iterator(filter_view& __parent, iterator_t<_Vp> __current)
+	_Iterator(filter_view& __parent, _Vp_iter __current)
 	  : _M_current(std::move(__current)),
 	    _M_parent(std::__addressof(__parent))
 	{ }
 
-	constexpr iterator_t<_Vp>
+	constexpr _Vp_iter
 	base() const &
-	  requires copyable<iterator_t<_Vp>>
+	  requires copyable<_Vp_iter>
 	{ return _M_current; }
 
-	constexpr iterator_t<_Vp>
+	constexpr _Vp_iter
 	base() &&
 	{ return std::move(_M_current); }
 
@@ -1367,10 +1373,10 @@
 	operator*() const
 	{ return *_M_current; }
 
-	constexpr iterator_t<_Vp>
+	constexpr _Vp_iter
 	operator->() const
-	  requires __detail::__has_arrow<iterator_t<_Vp>>
-	    && copyable<iterator_t<_Vp>>
+	  requires __detail::__has_arrow<_Vp_iter>
+	    && copyable<_Vp_iter>
 	{ return _M_current; }
 
 	constexpr _Iterator&
@@ -1413,7 +1419,7 @@
 
 	friend constexpr bool
 	operator==(const _Iterator& __x, const _Iterator& __y)
-	  requires equality_comparable<iterator_t<_Vp>>
+	  requires equality_comparable<_Vp_iter>
 	{ return __x._M_current == __y._M_current; }
 
 	friend constexpr range_rvalue_reference_t<_Vp>
@@ -1424,7 +1430,7 @@
 	friend constexpr void
 	iter_swap(const _Iterator& __x, const _Iterator& __y)
 	  noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
-	  requires indirectly_swappable<iterator_t<_Vp>>
+	  requires indirectly_swappable<_Vp_iter>
 	{ ranges::iter_swap(__x._M_current, __y._M_current); }
       };
 
@@ -1465,17 +1471,6 @@
 	: _M_base(std::move(__base)), _M_pred(std::move(__pred))
       { }
 
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range>
-	requires viewable_range<_Range>
-	  && constructible_from<_Vp, all_view<_Range>>
-	constexpr
-	filter_view(_Range&& __r, _Pred __pred)
-	  : _M_base(views::all(std::forward<_Range>(__r))),
-	    _M_pred(std::move(__pred))
-	{ }
-      */
-
       constexpr _Vp
       base() const& requires copy_constructible<_Vp>
       { return _M_base; }
@@ -1484,6 +1479,10 @@
       base() &&
       { return std::move(_M_base); }
 
+      constexpr const _Pred&
+      pred() const
+      { return *_M_pred; }
+
       constexpr _Iterator
       begin()
       {
@@ -1505,7 +1504,7 @@
     };
 
   template<typename _Range, typename _Pred>
-    filter_view(_Range&&, _Pred) -> filter_view<all_view<_Range>, _Pred>;
+    filter_view(_Range&&, _Pred) -> filter_view<views::all_t<_Range>, _Pred>;
 
   namespace views
   {
@@ -1549,7 +1548,8 @@
 	  static constexpr auto
 	  _S_iter_cat()
 	  {
-	    using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;
+	    using _Cat
+              = typename iterator_traits<_Base_iter>::iterator_category;
 	    if constexpr (derived_from<_Cat, contiguous_iterator_tag>)
 	      return random_access_iterator_tag{};
 	    else
@@ -1567,7 +1567,9 @@
 	      return *__i;
 	  }
 
-	  iterator_t<_Base> _M_current = iterator_t<_Base>();
+	  using _Base_iter = iterator_t<_Base>;
+
+	  _Base_iter _M_current = _Base_iter();
 	  _Parent* _M_parent = nullptr;
 
 	public:
@@ -1580,7 +1582,7 @@
 	  _Iterator() = default;
 
 	  constexpr
-	  _Iterator(_Parent& __parent, iterator_t<_Base> __current)
+	  _Iterator(_Parent& __parent, _Base_iter __current)
 	    : _M_current(std::move(__current)),
 	      _M_parent(std::__addressof(__parent))
 	  { }
@@ -1588,16 +1590,16 @@
 	  constexpr
 	  _Iterator(_Iterator<!_Const> __i)
 	    requires _Const
-	      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
+	      && convertible_to<iterator_t<_Vp>, _Base_iter>
 	    : _M_current(std::move(__i._M_current)), _M_parent(__i._M_parent)
 	  { }
 
-	  constexpr iterator_t<_Base>
+	  constexpr _Base_iter
 	  base() const &
-	    requires copyable<iterator_t<_Base>>
+	    requires copyable<_Base_iter>
 	  { return _M_current; }
 
-	  constexpr iterator_t<_Base>
+	  constexpr _Base_iter
 	  base() &&
 	  { return std::move(_M_current); }
 
@@ -1660,7 +1662,7 @@
 
 	  friend constexpr bool
 	  operator==(const _Iterator& __x, const _Iterator& __y)
-	    requires equality_comparable<iterator_t<_Base>>
+	    requires equality_comparable<_Base_iter>
 	  { return __x._M_current == __y._M_current; }
 
 	  friend constexpr bool
@@ -1687,7 +1689,7 @@
 	  friend constexpr auto
 	  operator<=>(const _Iterator& __x, const _Iterator& __y)
 	    requires random_access_range<_Base>
-	      && three_way_comparable<iterator_t<_Base>>
+	      && three_way_comparable<_Base_iter>
 	  { return __x._M_current <=> __y._M_current; }
 #endif
 
@@ -1718,7 +1720,7 @@
 	  friend constexpr void
 	  iter_swap(const _Iterator& __x, const _Iterator& __y)
 	    noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
-	    requires indirectly_swappable<iterator_t<_Base>>
+	    requires indirectly_swappable<_Base_iter>
 	  { return ranges::iter_swap(__x._M_current, __y._M_current); }
 
 	  friend _Sentinel<_Const>;
@@ -1787,17 +1789,6 @@
 	: _M_base(std::move(__base)), _M_fun(std::move(__fun))
       { }
 
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range>
-	requires viewable_range<_Range>
-	  && constructible_from<_Vp, all_view<_Range>>
-	constexpr
-	transform_view(_Range&& __r, _Fp __fun)
-	  : _M_base(views::all(std::forward<_Range>(__r)))
-	{
-	}
-	*/
-
       constexpr _Vp
       base() const& requires copy_constructible<_Vp>
       { return _M_base ; }
@@ -1846,7 +1837,7 @@
     };
 
   template<typename _Range, typename _Fp>
-    transform_view(_Range&&, _Fp) -> transform_view<all_view<_Range>, _Fp>;
+    transform_view(_Range&&, _Fp) -> transform_view<views::all_t<_Range>, _Fp>;
 
   namespace views
   {
@@ -1903,15 +1894,6 @@
 	: _M_base(std::move(base)), _M_count(std::move(__count))
       { }
 
-      /* XXX: P3280 removes this constructor
-      template<viewable_range _Range>
-	requires constructible_from<_Vp, all_view<_Range>>
-      constexpr
-      take_view(_Range&& __r, range_difference_t<_Vp> __count)
-	: _M_base(views::all(std::forward<_Range>(__r))), _M_count(__count)
-      { }
-      */
-
       constexpr _Vp
       base() const& requires copy_constructible<_Vp>
       { return _M_base; }
@@ -1993,7 +1975,7 @@
 
   template<range _Range>
     take_view(_Range&&, range_difference_t<_Range>)
-      -> take_view<all_view<_Range>>;
+      -> take_view<views::all_t<_Range>>;
 
   namespace views
   {
@@ -2085,7 +2067,7 @@
 
   template<typename _Range, typename _Pred>
     take_while_view(_Range&&, _Pred)
-      -> take_while_view<all_view<_Range>, _Pred>;
+      -> take_while_view<views::all_t<_Range>, _Pred>;
 
   namespace views
   {
@@ -2162,7 +2144,7 @@
 
   template<typename _Range>
     drop_view(_Range&&, range_difference_t<_Range>)
-      -> drop_view<all_view<_Range>>;
+      -> drop_view<views::all_t<_Range>>;
 
   namespace views
   {
@@ -2218,7 +2200,7 @@
 
   template<typename _Range, typename _Pred>
     drop_while_view(_Range&&, _Pred)
-      -> drop_while_view<all_view<_Range>, _Pred>;
+      -> drop_while_view<views::all_t<_Range>, _Pred>;
 
   namespace views
   {
@@ -2272,7 +2254,7 @@
 	      }
 
 	    if constexpr (_S_ref_is_glvalue)
-	      _M_inner = iterator_t<range_reference_t<_Base>>();
+	      _M_inner = _Inner_iter();
 	  }
 
 	  static constexpr auto
@@ -2294,10 +2276,9 @@
 	  _S_iter_cat()
 	  {
 	    using _OuterCat
-	      = iterator_traits<iterator_t<_Base>>::iterator_category;
+	      = typename iterator_traits<_Outer_iter>::iterator_category;
 	    using _InnerCat
-	      = iterator_traits<iterator_t<range_reference_t<_Base>>>
-		 ::iterator_category;
+	      = typename iterator_traits<_Inner_iter>::iterator_category;
 	    if constexpr (_S_ref_is_glvalue
 			  && derived_from<_OuterCat, bidirectional_iterator_tag>
 			  && derived_from<_InnerCat, bidirectional_iterator_tag>)
@@ -2313,9 +2294,11 @@
 	      return output_iterator_tag{};
 	  }
 
-	  iterator_t<_Base> _M_outer = iterator_t<_Base>();
-	  iterator_t<range_reference_t<_Base>> _M_inner
-	    = iterator_t<range_reference_t<_Base>>();
+	  using _Outer_iter = iterator_t<_Base>;
+	  using _Inner_iter = iterator_t<range_reference_t<_Base>>;
+
+	  _Outer_iter _M_outer = _Outer_iter();
+	  _Inner_iter _M_inner = _Inner_iter();
 	  _Parent* _M_parent = nullptr;
 
 	public:
@@ -2328,10 +2311,8 @@
 
 	  _Iterator() = default;
 
-	  // XXX: had to change the type of __outer from iterator_t<_Vp> to
-	  // iterator_t<_Base> here, a possible defect in the spec?
 	  constexpr
-	  _Iterator(_Parent& __parent, iterator_t<_Base> __outer)
+	  _Iterator(_Parent& __parent, _Outer_iter __outer)
 	    : _M_outer(std::move(__outer)),
 	      _M_parent(std::__addressof(__parent))
 	  { _M_satisfy(); }
@@ -2339,9 +2320,8 @@
 	  constexpr
 	  _Iterator(_Iterator<!_Const> __i)
 	    requires _Const
-	      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
-	      && convertible_to<iterator_t<_InnerRange>,
-				iterator_t<range_reference_t<_Base>>>
+	      && convertible_to<iterator_t<_Vp>, _Outer_iter>
+	      && convertible_to<iterator_t<_InnerRange>, _Inner_iter>
 	    : _M_outer(std::move(__i._M_outer)), _M_inner(__i._M_inner),
 	      _M_parent(__i._M_parent)
 	  { }
@@ -2350,10 +2330,10 @@
 	  operator*() const
 	  { return *_M_inner; }
 
-	  constexpr iterator_t<_Base>
+	  constexpr _Outer_iter
 	  operator->() const
-	    requires __detail::__has_arrow<iterator_t<_Base>>
-	      && copyable<iterator_t<_Base>>
+	    requires __detail::__has_arrow<_Outer_iter>
+	      && copyable<_Outer_iter>
 	  { return _M_inner; }
 
 	  constexpr _Iterator&
@@ -2413,8 +2393,8 @@
 	  friend constexpr bool
 	  operator==(const _Iterator& __x, const _Iterator& __y)
 	    requires _S_ref_is_glvalue
-	      && equality_comparable<iterator_t<_Base>>
-	      && equality_comparable<iterator_t<range_reference_t<_Base>>>
+	      && equality_comparable<_Outer_iter>
+	      && equality_comparable<_Inner_iter>
 	  {
 	    return (__x._M_outer == __y._M_outer
 		    && __x._M_inner == __y._M_inner);
@@ -2430,6 +2410,7 @@
 	    noexcept(noexcept(ranges::iter_swap(__x._M_inner, __y._M_inner)))
 	  { return ranges::iter_swap(__x._M_inner, __y._M_inner); }
 
+	  friend _Iterator<!_Const>;
 	  friend _Sentinel<_Const>;
 	};
 
@@ -2468,10 +2449,9 @@
       _Vp _M_base = _Vp();
 
       // XXX: _M_inner is "present only when !is_reference_v<_InnerRange>"
-      // Applied P3278 and made this field mutable.
-      [[no_unique_address]] mutable
+      [[no_unique_address]]
 	conditional_t<!is_reference_v<_InnerRange>,
-		      all_view<_InnerRange>, __detail::_Empty> _M_inner;
+		      views::all_t<_InnerRange>, __detail::_Empty> _M_inner;
 
     public:
       join_view() = default;
@@ -2481,16 +2461,6 @@
 	: _M_base(std::move(__base))
       { }
 
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range>
-	requires viewable_range<_Range>
-	  && constructible_from<_Vp, all_view<_Range>>
-      constexpr explicit
-      join_view(_Range&& __r)
-	: _M_base(views::all(std::forward<_Range>(__r)))
-      { }
-      */
-
       constexpr _Vp
       base() const& requires copy_constructible<_Vp>
       { return _M_base; }
@@ -2502,8 +2472,10 @@
       constexpr auto
       begin()
       {
-	return _Iterator<__detail::__simple_view<_Vp>>{*this,
-						       ranges::begin(_M_base)};
+	constexpr bool __use_const
+	  = (__detail::__simple_view<_Vp>
+	     && is_reference_v<range_reference_t<_Vp>>);
+	return _Iterator<__use_const>{*this, ranges::begin(_M_base)};
       }
 
       constexpr auto
@@ -2543,7 +2515,7 @@
     };
 
   template<typename _Range>
-    explicit join_view(_Range&&) -> join_view<all_view<_Range>>;
+    explicit join_view(_Range&&) -> join_view<views::all_t<_Range>>;
 
   namespace views
   {
@@ -2669,7 +2641,7 @@
 	  constexpr
 	  _OuterIter(_OuterIter<!_Const> __i)
 	    requires _Const
-	      && convertible_to<iterator_t<_Vp>, iterator_t<const _Vp>>
+	      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
 	    : _M_parent(__i._M_parent), _M_current(std::move(__i._M_current))
 	  { }
 
@@ -2765,7 +2737,8 @@
 	  static constexpr auto
 	  _S_iter_cat()
 	  {
-	    using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;
+	    using _Cat
+              = typename iterator_traits<iterator_t<_Base>>::iterator_category;
 	    if constexpr (derived_from<_Cat, forward_iterator_tag>)
 	      return forward_iterator_tag{};
 	    else
@@ -2787,7 +2760,8 @@
 	  bool _M_incremented = false;
 
 	public:
-	  using iterator_concept = typename _OuterIter<_Const>::iterator_concept;
+	  using iterator_concept
+	    = typename _OuterIter<_Const>::iterator_concept;
 	  using iterator_category = decltype(_S_iter_cat());
 	  using value_type = range_value_t<_Base>;
 	  using difference_type = range_difference_t<_Base>;
@@ -2864,19 +2838,8 @@
 	: _M_base(std::move(__base)), _M_pattern(std::move(__pattern))
       { }
 
-      /* XXX: P3280 removes this constructor
-      template<input_range _Range, forward_range _Pred>
-	requires constructible_from<_Vp, all_view<_Range>>
-	  && constructible_from<_Pattern, all_view<_Pred>>
-	constexpr
-	split_view(_Range&& __r, _Pred&& __p)
-	  : _M_base(views::all(std::forward<_Range>(__r))),
-	    _M_pattern(views::all(std::forward<_Pred>(__p)))
-      { }
-      */
-
       template<input_range _Range>
-	requires constructible_from<_Vp, all_view<_Range>>
+	requires constructible_from<_Vp, views::all_t<_Range>>
 	  && constructible_from<_Pattern, single_view<range_value_t<_Range>>>
 	constexpr
 	split_view(_Range&& __r, range_value_t<_Range> __e)
@@ -2931,11 +2894,11 @@
 
   template<typename _Range, typename _Pred>
     split_view(_Range&&, _Pred&&)
-      -> split_view<all_view<_Range>, all_view<_Pred>>;
+      -> split_view<views::all_t<_Range>, views::all_t<_Pred>>;
 
   template<input_range _Range>
     split_view(_Range&&, range_value_t<_Range>)
-      -> split_view<all_view<_Range>, single_view<range_value_t<_Range>>>;
+      -> split_view<views::all_t<_Range>, single_view<range_value_t<_Range>>>;
 
   namespace views
   {
@@ -2980,14 +2943,15 @@
 	: _M_base(std::move(__r))
       { }
 
-      /* XXX: P3280 doesn't remove this constructor, but I think it should?
+      /* XXX: LWG 3280 didn't remove this constructor, but I think it should?
       template<viewable_range _Range>
-	requires (!common_range<_Range>) && constructible_from<_Vp, all_view<_Range>>
+	requires (!common_range<_Range>)
+	  && constructible_from<_Vp, views::all_t<_Range>>
 	constexpr explicit
 	common_view(_Range&& __r)
 	  : _M_base(views::all(std::forward<_Range>(__r)))
 	{ }
-	*/
+      */
 
       constexpr _Vp
       base() const& requires copy_constructible<_Vp>
@@ -3047,7 +3011,7 @@
     };
 
   template<typename _Range>
-    common_view(_Range&&) -> common_view<all_view<_Range>>;
+    common_view(_Range&&) -> common_view<views::all_t<_Range>>;
 
   namespace views
   {
@@ -3078,15 +3042,6 @@
 	: _M_base(std::move(__r))
 	{ }
 
-      /* XXX: P3280 removes this constructor
-      template<viewable_range _Range>
-	requires bidirectional_range<_Range> && constructible_from<_Vp, all_view<_Range>>
-	constexpr explicit
-	reverse_view(_Range&& __r)
-	  : _M_base(views::all(std::forward<_Range>(__r)))
-	{ }
-	*/
-
       constexpr _Vp
       base() const& requires copy_constructible<_Vp>
       { return _M_base; }
@@ -3129,7 +3084,7 @@
     };
 
   template<typename _Range>
-    reverse_view(_Range&&) -> reverse_view<all_view<_Range>>;
+    reverse_view(_Range&&) -> reverse_view<views::all_t<_Range>>;
 
   namespace views
   {
@@ -3180,7 +3135,6 @@
 	typename tuple_size<_Tp>::type;
 	requires _Nm < tuple_size_v<_Tp>;
 	typename tuple_element_t<_Nm, _Tp>;
-	// XXX: we applied P3323 here
 	{ std::get<_Nm>(__t) }
 	  -> convertible_to<const tuple_element_t<_Nm, _Tp>&>;
       };
@@ -3403,10 +3357,10 @@
     };
 
   template<typename _Range>
-    using keys_view = elements_view<all_view<_Range>, 0>;
+    using keys_view = elements_view<views::all_t<_Range>, 0>;
 
   template<typename _Range>
-    using values_view = elements_view<all_view<_Range>, 1>;
+    using values_view = elements_view<views::all_t<_Range>, 1>;
 
   namespace views
   {
@@ -3414,7 +3368,8 @@
     inline constexpr __adaptor::_RangeAdaptorClosure elements
       = [] <viewable_range _Range> (_Range&& __r)
       {
-	return elements_view<all_view<_Range>, _Nm>{std::forward<_Range>(__r)};
+	using _El = elements_view<views::all_t<_Range>, _Nm>;
+	return _El{std::forward<_Range>(__r)};
       };
 
     inline constexpr __adaptor::_RangeAdaptorClosure keys = elements<0>;
@@ -3438,6 +3393,14 @@
     struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>>
     { using type = _Sent; };
 
+  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
+    struct tuple_element<0, const ranges::subrange<_Iter, _Sent, _Kind>>
+    { using type = _Iter; };
+
+  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
+    struct tuple_element<1, const ranges::subrange<_Iter, _Sent, _Kind>>
+    { using type = _Sent; };
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 #endif // library concepts
diff -urN gcc-10-20200216/libstdc++-v3/include/std/span /home/bero/repos/gcc/libstdc++-v3/include/std/span
--- gcc-10-20200216/libstdc++-v3/include/std/span	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/span	2020-02-19 17:37:12.783815809 +0100
@@ -48,7 +48,7 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_span 201902L
+#define __cpp_lib_span 202002L
 
   inline constexpr size_t dynamic_extent = static_cast<size_t>(-1);
 
@@ -123,42 +123,30 @@
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 3255. span's array constructor is too strict
       template<typename _Tp, size_t _ArrayExtent>
-	using __is_compatible_array = __and_<
-	  bool_constant<(_Extent == dynamic_extent || _ArrayExtent == _Extent)>,
-	  __is_array_convertible<_Type, _Tp>>;
-
-      template<typename _Iter, typename _Ref = iter_reference_t<_Iter>>
-	using __is_compatible_iterator = __and_<
-	  bool_constant<contiguous_iterator<_Iter>>,
-	  is_lvalue_reference<iter_reference_t<_Iter>>,
-	  is_same<iter_value_t<_Iter>, remove_cvref_t<_Ref>>,
-	  __is_array_convertible<_Type, remove_reference_t<_Ref>>>;
+	requires (_Extent == dynamic_extent || _ArrayExtent == _Extent)
+	using __is_compatible_array = __is_array_convertible<_Type, _Tp>;
 
-      template<typename _Range>
-	using __is_compatible_range
-	  = __is_compatible_iterator<ranges::iterator_t<_Range>>;
+      template<typename _Ref>
+	using __is_compatible_ref
+	  = __is_array_convertible<_Type, remove_reference_t<_Ref>>;
 
     public:
       // member types
-      using value_type             = remove_cv_t<_Type>;
       using element_type           = _Type;
+      using value_type             = remove_cv_t<_Type>;
       using size_type              = size_t;
-      using reference              = element_type&;
-      using const_reference        = const element_type&;
+      using difference_type        = ptrdiff_t;
       using pointer                = _Type*;
       using const_pointer          = const _Type*;
-      using iterator
-	= __gnu_cxx::__normal_iterator<pointer, span>;
-      using const_iterator
-	= __gnu_cxx::__normal_iterator<const_pointer, span>;
+      using reference              = element_type&;
+      using const_reference        = const element_type&;
+      using iterator = __gnu_cxx::__normal_iterator<pointer, span>;
       using reverse_iterator       = std::reverse_iterator<iterator>;
-      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
-      using difference_type        = ptrdiff_t;
 
       // member constants
-      static inline constexpr size_t extent = _Extent;
+      static constexpr size_t extent = _Extent;
 
-      // constructors
+      // constructors, copy and assignment
 
       constexpr
       span() noexcept
@@ -166,74 +154,93 @@
       : _M_extent(0), _M_ptr(nullptr)
       { }
 
-      constexpr
-      span(const span&) noexcept = default;
+      template<contiguous_iterator _It>
+	requires __is_compatible_ref<iter_reference_t<_It>>::value
+	constexpr explicit(extent != dynamic_extent)
+	span(_It __first, size_type __count)
+	noexcept
+	: _M_extent(__count), _M_ptr(std::to_address(__first))
+	{
+	  if constexpr (_Extent != dynamic_extent)
+	    {
+	      __glibcxx_assert(__count == _Extent);
+	    }
+	}
 
-      template<typename _Tp, size_t _ArrayExtent>
-	requires (__is_compatible_array<_Tp, _ArrayExtent>::value)
+      template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
+	requires __is_compatible_ref<iter_reference_t<_It>>::value
+	  && (!is_convertible_v<_End, size_type>)
+	constexpr explicit(extent != dynamic_extent)
+	span(_It __first, _End __last)
+	noexcept(noexcept(__last - __first))
+	: _M_extent(static_cast<size_type>(__last - __first)),
+	  _M_ptr(std::to_address(__first))
+	{
+	  if constexpr (_Extent != dynamic_extent)
+	    {
+	      __glibcxx_assert((__last - __first) == _Extent);
+	    }
+	}
+
+      template<size_t _ArrayExtent>
+	requires (_Extent == dynamic_extent || _ArrayExtent == _Extent)
 	constexpr
-	span(_Tp (&__arr)[_ArrayExtent]) noexcept
+	span(type_identity_t<element_type> (&__arr)[_ArrayExtent]) noexcept
 	: span(static_cast<pointer>(__arr), _ArrayExtent)
 	{ }
 
       template<typename _Tp, size_t _ArrayExtent>
-	requires (__is_compatible_array<_Tp, _ArrayExtent>::value)
+	requires __is_compatible_array<_Tp, _ArrayExtent>::value
 	constexpr
 	span(array<_Tp, _ArrayExtent>& __arr) noexcept
 	: span(static_cast<pointer>(__arr.data()), _ArrayExtent)
 	{ }
 
       template<typename _Tp, size_t _ArrayExtent>
-	  requires (__is_compatible_array<const _Tp, _ArrayExtent>::value)
+	requires __is_compatible_array<const _Tp, _ArrayExtent>::value
 	constexpr
 	span(const array<_Tp, _ArrayExtent>& __arr) noexcept
 	: span(static_cast<pointer>(__arr.data()), _ArrayExtent)
 	{ }
 
-      template<ranges::contiguous_range _Range>
-	requires (_Extent == dynamic_extent)
+      template<typename _Range>
+	requires ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
+	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
 	  && (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
 	  && (!__detail::__is_std_array<remove_cvref_t<_Range>>::value)
-	  && (!is_array_v<remove_reference_t<_Range>>)
-	  && (__is_compatible_range<_Range>::value)
-	constexpr
+	  && (!is_array_v<remove_cvref_t<_Range>>)
+	  && __is_compatible_ref<ranges::range_reference_t<_Range>>::value
+	constexpr explicit(extent != dynamic_extent)
 	span(_Range&& __range)
 	noexcept(noexcept(ranges::data(__range))
 		  && noexcept(ranges::size(__range)))
 	: span(ranges::data(__range), ranges::size(__range))
-	{ }
-
-      template<contiguous_iterator _ContiguousIterator,
-	sized_sentinel_for<_ContiguousIterator> _Sentinel>
-	  requires (__is_compatible_iterator<_ContiguousIterator>::value)
-	    && (!is_convertible_v<_Sentinel, size_type>)
-	constexpr
-	span(_ContiguousIterator __first, _Sentinel __last)
-	noexcept(noexcept(__last - __first))
-	: _M_extent(static_cast<size_type>(__last - __first)),
-	  _M_ptr(std::to_address(__first))
 	{
-	  if (_Extent != dynamic_extent)
-	    __glibcxx_assert((__last - __first) == _Extent);
+	  if constexpr (extent != dynamic_extent)
+	    {
+	      __glibcxx_assert(ranges::size(__range) == extent);
+	    }
 	}
 
-      template<contiguous_iterator _ContiguousIterator>
-	requires (__is_compatible_iterator<_ContiguousIterator>::value)
-	constexpr
-	span(_ContiguousIterator __first, size_type __count)
-	noexcept
-	: _M_extent(__count), _M_ptr(std::to_address(__first))
-	{ __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }
+      constexpr
+      span(const span&) noexcept = default;
 
       template<typename _OType, size_t _OExtent>
-	requires (_Extent == dynamic_extent || _Extent == _OExtent)
+	requires (_Extent == dynamic_extent || _OExtent == dynamic_extent
+		  || _Extent == _OExtent)
 	  && (__is_array_convertible<_Type, _OType>::value)
 	constexpr
+	explicit(extent != dynamic_extent && _OExtent == dynamic_extent)
 	span(const span<_OType, _OExtent>& __s) noexcept
 	: _M_extent(__s.size()), _M_ptr(__s.data())
-	{ }
+	{
+	  if constexpr (extent != dynamic_extent)
+	    {
+	      __glibcxx_assert(__s.size() == extent);
+	    }
+	}
 
-      // assignment
+      ~span() noexcept = default;
 
       constexpr span&
       operator=(const span&) noexcept = default;
@@ -288,34 +295,18 @@
       begin() const noexcept
       { return iterator(this->_M_ptr); }
 
-      constexpr const_iterator
-      cbegin() const noexcept
-      { return const_iterator(this->_M_ptr); }
-
       constexpr iterator
       end() const noexcept
       { return iterator(this->_M_ptr + this->size()); }
 
-      constexpr const_iterator
-      cend() const noexcept
-      { return const_iterator(this->_M_ptr + this->size()); }
-
       constexpr reverse_iterator
       rbegin() const noexcept
       { return reverse_iterator(this->end()); }
 
-      constexpr const_reverse_iterator
-      crbegin() const noexcept
-      { return const_reverse_iterator(this->cend()); }
-
       constexpr reverse_iterator
       rend() const noexcept
       { return reverse_iterator(this->begin()); }
 
-      constexpr const_reverse_iterator
-      crend() const noexcept
-      { return const_reverse_iterator(this->cbegin()); }
-
       // subviews
 
       template<size_t _Count>
@@ -326,7 +317,8 @@
 	    __glibcxx_assert(_Count <= size());
 	  else
 	    static_assert(_Count <= extent);
-	  return { this->data(), _Count };
+	  using _Sp = span<element_type, _Count>;
+	  return _Sp{ this->data(), _Count };
 	}
 
       constexpr span<element_type, dynamic_extent>
@@ -344,7 +336,8 @@
 	    __glibcxx_assert(_Count <= size());
 	  else
 	    static_assert(_Count <= extent);
-	  return { this->data() + (this->size() - _Count), _Count };
+	  using _Sp = span<element_type, _Count>;
+	  return _Sp{ this->data() + (this->size() - _Count), _Count };
 	}
 
       constexpr span<element_type, dynamic_extent>
@@ -360,12 +353,16 @@
 	-> span<element_type, _S_subspan_extent<_Offset, _Count>()>
 	{
 	  if constexpr (_Extent == dynamic_extent)
-	    __glibcxx_assert(_Offset <= size());
+	    {
+	      __glibcxx_assert(_Offset <= size());
+	    }
 	  else
 	    static_assert(_Offset <= extent);
 
+	  using _Sp = span<element_type, _S_subspan_extent<_Offset, _Count>()>;
+
 	  if constexpr (_Count == dynamic_extent)
-	    return { this->data() + _Offset, this->size() - _Offset };
+	    return _Sp{ this->data() + _Offset, this->size() - _Offset };
 	  else
 	    {
 	      if constexpr (_Extent == dynamic_extent)
@@ -378,7 +375,7 @@
 		  static_assert(_Count <= extent);
 		  static_assert(_Count <= (extent - _Offset));
 		}
-	      return { this->data() + _Offset, _Count };
+	      return _Sp{ this->data() + _Offset, _Count };
 	    }
 	}
 
@@ -414,8 +411,8 @@
     span(const array<_Type, _ArrayExtent>&)
       -> span<const _Type, _ArrayExtent>;
 
-  template<contiguous_iterator _Iter, typename _Sentinel>
-    span(_Iter, _Sentinel)
+  template<contiguous_iterator _Iter, typename _End>
+    span(_Iter, _End)
       -> span<remove_reference_t<iter_reference_t<_Iter>>>;
 
   template<typename _Range>
@@ -428,7 +425,11 @@
 	? dynamic_extent : _Extent * sizeof(_Type)>
     as_bytes(span<_Type, _Extent> __sp) noexcept
     {
-      return {reinterpret_cast<const byte*>(__sp.data()), __sp.size_bytes()};
+      auto data = reinterpret_cast<const byte*>(__sp.data());
+      auto size = __sp.size_bytes();
+      constexpr auto extent = _Extent == dynamic_extent
+	? dynamic_extent : _Extent * sizeof(_Type);
+      return span<const byte, extent>{data, size};
     }
 
   template<typename _Type, size_t _Extent>
@@ -437,46 +438,20 @@
        ? dynamic_extent : _Extent * sizeof(_Type)>
     as_writable_bytes(span<_Type, _Extent> __sp) noexcept
     {
-      return {reinterpret_cast<byte*>(__sp.data()), __sp.size_bytes()};
-    }
-
-  // tuple helpers
-  template<size_t _Index, typename _Type, size_t _Extent>
-    constexpr _Type&
-    get(span<_Type, _Extent> __sp) noexcept
-    {
-      static_assert(_Extent != dynamic_extent && _Index < _Extent,
-	"get<I> can only be used with a span of non-dynamic (fixed) extent");
-      return __sp[_Index];
+      auto data = reinterpret_cast<byte*>(__sp.data());
+      auto size = __sp.size_bytes();
+      constexpr auto extent = _Extent == dynamic_extent
+	? dynamic_extent : _Extent * sizeof(_Type);
+      return span<byte, extent>{data, size};
     }
 
-  template<typename _Tp> struct tuple_size;
-  template<size_t __i, typename _Tp> struct tuple_element;
-
-  template<typename _Type, size_t _Extent>
-    struct tuple_size<span<_Type, _Extent>>
-    : public integral_constant<size_t, _Extent>
-    {
-      static_assert(_Extent != dynamic_extent, "tuple_size can only "
-	"be used with a span of non-dynamic (fixed) extent");
-    };
-
-  template<size_t _Index, typename _Type, size_t _Extent>
-    struct tuple_element<_Index, span<_Type, _Extent>>
-    {
-      static_assert(_Extent != dynamic_extent, "tuple_element can only "
-	"be used with a span of non-dynamic (fixed) extent");
-      static_assert(_Index < _Extent, "Index is less than Extent");
-      using type = _Type;
-    };
-
   namespace ranges
   {
-    template<typename> extern inline const bool enable_safe_range;
-    // Opt-in to safe_range concept
+    template<typename> extern inline const bool enable_borrowed_range;
+    // Opt-in to borrowed_range concept
     template<typename _ElementType, size_t _Extent>
       inline constexpr bool
-	enable_safe_range<span<_ElementType, _Extent>> = true;
+	enable_borrowed_range<span<_ElementType, _Extent>> = true;
   }
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff -urN gcc-10-20200216/libstdc++-v3/include/std/string_view /home/bero/repos/gcc/libstdc++-v3/include/std/string_view
--- gcc-10-20200216/libstdc++-v3/include/std/string_view	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/string_view	2020-02-19 17:37:12.784815809 +0100
@@ -37,10 +37,10 @@
 
 #if __cplusplus >= 201703L
 
-#include <limits>
 #include <iosfwd>
 #include <bits/char_traits.h>
 #include <bits/functional_hash.h>
+#include <bits/int_limits.h>
 #include <bits/range_access.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -456,10 +456,10 @@
       _S_compare(size_type __n1, size_type __n2) noexcept
       {
 	const difference_type __diff = __n1 - __n2;
-	if (__diff > std::numeric_limits<int>::max())
-	  return std::numeric_limits<int>::max();
-	if (__diff < std::numeric_limits<int>::min())
-	  return std::numeric_limits<int>::min();
+	if (__diff > __detail::__int_limits<int>::max())
+	  return __detail::__int_limits<int>::max();
+	if (__diff < __detail::__int_limits<int>::min())
+	  return __detail::__int_limits<int>::min();
 	return static_cast<int>(__diff);
       }
 
@@ -727,11 +727,11 @@
 #if __cpp_lib_concepts
   namespace ranges
   {
-    template<typename> extern inline const bool enable_safe_range;
-    // Opt-in to safe_range concept
+    template<typename> extern inline const bool enable_borrowed_range;
+    // Opt-in to borrowed_range concept
     template<typename _CharT, typename _Traits>
       inline constexpr bool
-	enable_safe_range<basic_string_view<_CharT, _Traits>> = true;
+	enable_borrowed_range<basic_string_view<_CharT, _Traits>> = true;
   }
 #endif
 _GLIBCXX_END_NAMESPACE_VERSION
diff -urN gcc-10-20200216/libstdc++-v3/include/std/type_traits /home/bero/repos/gcc/libstdc++-v3/include/std/type_traits
--- gcc-10-20200216/libstdc++-v3/include/std/type_traits	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/type_traits	2020-02-19 17:37:12.784815809 +0100
@@ -622,6 +622,10 @@
 #endif
 	  >;
 
+  // Check if a type is one of the signed or unsigned integer types.
+  template<typename _Tp>
+    using __is_standard_integer
+      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;
 
   // __void_t (std::void_t for C++11)
   template<typename...> using __void_t = void;
@@ -3238,6 +3242,8 @@
   template<typename _Tp>
     using type_identity_t = typename type_identity<_Tp>::type;
 
+#define __cpp_lib_unwrap_ref 201811L
+
   /// Unwrap a reference_wrapper
   template<typename _Tp>
     struct unwrap_reference { using type = _Tp; };
diff -urN gcc-10-20200216/libstdc++-v3/include/std/utility /home/bero/repos/gcc/libstdc++-v3/include/std/utility
--- gcc-10-20200216/libstdc++-v3/include/std/utility	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/utility	2020-02-19 17:37:12.785815810 +0100
@@ -75,6 +75,10 @@
 #include <bits/move.h>
 #include <initializer_list>
 
+#if __cplusplus > 201703L
+#include <bits/int_limits.h>
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -397,6 +401,77 @@
   template<typename _Tp>
     void as_const(const _Tp&&) = delete;
 
+#if __cplusplus > 201703L
+#define __cpp_lib_integer_comparison_functions 202002L
+
+  template<typename _Tp, typename _Up>
+    constexpr bool
+    cmp_equal(_Tp __t, _Up __u) noexcept
+    {
+      static_assert(__is_standard_integer<_Tp>::value);
+      static_assert(__is_standard_integer<_Up>::value);
+
+      if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
+	return __t == __u;
+      else if constexpr (is_signed_v<_Tp>)
+	return __t >= 0 && make_unsigned_t<_Tp>(__t) == __u;
+      else
+	return __u >= 0 && __t == make_unsigned_t<_Up>(__u);
+    }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool
+    cmp_not_equal(_Tp __t, _Up __u) noexcept
+    { return !std::cmp_equal(__t, __u); }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool
+    cmp_less(_Tp __t, _Up __u) noexcept
+    {
+      static_assert(__is_standard_integer<_Tp>::value);
+      static_assert(__is_standard_integer<_Up>::value);
+
+      if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
+	return __t < __u;
+      else if constexpr (is_signed_v<_Tp>)
+	return __t < 0 || make_unsigned_t<_Tp>(__t) < __u;
+      else
+	return __u >= 0 && __t < make_unsigned_t<_Up>(__u);
+    }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool
+    cmp_greater(_Tp __t, _Up __u) noexcept
+    { return std::cmp_less(__u, __t); }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool
+    cmp_less_equal(_Tp __t, _Up __u) noexcept
+    { return !std::cmp_less(__u, __t); }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool
+    cmp_greater_equal(_Tp __t, _Up __u) noexcept
+    { return !std::cmp_less(__t, __u); }
+
+  template<typename _Up, typename _Tp>
+    constexpr bool
+    in_range(_Tp __t) noexcept
+    {
+      static_assert(__is_standard_integer<_Up>::value);
+      static_assert(__is_standard_integer<_Tp>::value);
+      using std::__detail::__int_limits;
+
+      if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
+	return __int_limits<_Up>::min() <= __t
+	  && __t <= __int_limits<_Up>::max();
+      else if constexpr (is_signed_v<_Tp>)
+	return __t >= 0
+	  && make_unsigned_t<_Tp>(__t) <= __int_limits<_Up>::max();
+      else
+	return __t <= make_unsigned_t<_Up>(__int_limits<_Up>::max());
+    }
+#endif // C++20
 #endif // C++17
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff -urN gcc-10-20200216/libstdc++-v3/include/std/version /home/bero/repos/gcc/libstdc++-v3/include/std/version
--- gcc-10-20200216/libstdc++-v3/include/std/version	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/include/std/version	2020-02-19 17:37:12.785815810 +0100
@@ -174,12 +174,15 @@
 # define __cpp_lib_destroying_delete 201806L
 #endif
 #define __cpp_lib_endian 201907L
+#define __cpp_lib_int_pow2 202002L
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
 # define __cpp_lib_is_constant_evaluated 201811L
 #endif
+#define __cpp_lib_unwrap_ref 201811L
 
 #if _GLIBCXX_HOSTED
 #define __cpp_lib_bind_front 201907L
+#define __cpp_lib_integer_comparison_functions 202002L
 #define __cpp_lib_constexpr_algorithms 201806L
 #define __cpp_lib_constexpr_complex 201711L
 #define __cpp_lib_constexpr_dynamic_alloc 201907L
@@ -191,7 +194,7 @@
 #endif
 #define __cpp_lib_list_remove_return_type 201806L
 #define __cpp_lib_math_constants 201907L
-#define __cpp_lib_span 201902L
+#define __cpp_lib_span 202002L
 #if __cpp_impl_three_way_comparison >= 201907L && __cpp_lib_concepts
 # define __cpp_lib_three_way_comparison 201711L
 #endif
diff -urN gcc-10-20200216/libstdc++-v3/libsupc++/compare /home/bero/repos/gcc/libstdc++-v3/libsupc++/compare
--- gcc-10-20200216/libstdc++-v3/libsupc++/compare	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/libsupc++/compare	2020-02-19 17:37:12.791815810 +0100
@@ -416,14 +416,14 @@
       concept __partially_ordered_with
 	= requires(const remove_reference_t<_Tp>& __t,
 		   const remove_reference_t<_Up>& __u) {
-	  { __t <  __u } -> boolean;
-	  { __t >  __u } -> boolean;
-	  { __t <= __u } -> boolean;
-	  { __t >= __u } -> boolean;
-	  { __u <  __t } -> boolean;
-	  { __u >  __t } -> boolean;
-	  { __u <= __t } -> boolean;
-	  { __u >= __t } -> boolean;
+	  { __t <  __u } -> __boolean_testable;
+	  { __t >  __u } -> __boolean_testable;
+	  { __t <= __u } -> __boolean_testable;
+	  { __t >= __u } -> __boolean_testable;
+	  { __u <  __t } -> __boolean_testable;
+	  { __u >  __t } -> __boolean_testable;
+	  { __u <= __t } -> __boolean_testable;
+	  { __u >= __t } -> __boolean_testable;
 	};
   } // namespace __detail
 
@@ -879,8 +879,8 @@
 	operator()(const _Tp& __t, const _Up& __u) const
 	requires requires
 	{
-	  { __t < __u } -> convertible_to<bool>;
-	  { __u < __t } -> convertible_to<bool>;
+	  { __t < __u } -> __boolean_testable;
+	  { __u < __t } -> __boolean_testable;
 	}
 	{
 	  if constexpr (three_way_comparable_with<_Tp, _Up>)
diff -urN gcc-10-20200216/libstdc++-v3/libsupc++/new_opa.cc /home/bero/repos/gcc/libstdc++-v3/libsupc++/new_opa.cc
--- gcc-10-20200216/libstdc++-v3/libsupc++/new_opa.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/libsupc++/new_opa.cc	2020-02-19 17:37:12.794815810 +0100
@@ -115,7 +115,7 @@
 
   /* Alignment must be a power of two.  */
   /* XXX This should be checked by the compiler (PR 86878).  */
-  if (__builtin_expect (!std::__ispow2(align), false))
+  if (__builtin_expect (!std::__has_single_bit(align), false))
     _GLIBCXX_THROW_OR_ABORT(bad_alloc());
 
   /* malloc (0) is unpredictable; avoid it.  */
diff -urN gcc-10-20200216/libstdc++-v3/python/libstdcxx/v6/printers.py /home/bero/repos/gcc/libstdc++-v3/python/libstdcxx/v6/printers.py
--- gcc-10-20200216/libstdc++-v3/python/libstdcxx/v6/printers.py	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/python/libstdcxx/v6/printers.py	2020-02-19 17:37:12.795815810 +0100
@@ -1435,7 +1435,7 @@
         if self.typename == 'strong_ordering' and self.val == 0:
             name = 'equal'
         else:
-            names = {-127:'unordered', -1:'less', 0:'equivalent', 1:'greater'}
+            names = {2:'unordered', -1:'less', 0:'equivalent', 1:'greater'}
             name = names[int(self.val)]
         return 'std::{}::{}'.format(self.typename, name)
 
diff -urN gcc-10-20200216/libstdc++-v3/src/c++17/memory_resource.cc /home/bero/repos/gcc/libstdc++-v3/src/c++17/memory_resource.cc
--- gcc-10-20200216/libstdc++-v3/src/c++17/memory_resource.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/src/c++17/memory_resource.cc	2020-02-19 17:37:12.800815810 +0100
@@ -25,7 +25,7 @@
 #include <memory_resource>
 #include <algorithm>			// lower_bound, rotate
 #include <atomic>
-#include <bit>				// __ceil2, __log2p1
+#include <bit>				// has_single_bit, bit_ceil, bit_width
 #include <new>
 #if ATOMIC_POINTER_LOCK_FREE != 2
 # include <bits/std_mutex.h>	// std::mutex, std::lock_guard
@@ -189,7 +189,7 @@
     allocate(memory_resource* __r, size_t __size, size_t __align,
 	     _Chunk*& __head)
     {
-      __size = std::__ceil2(__size + sizeof(_Chunk));
+      __size = std::__bit_ceil(__size + sizeof(_Chunk));
 
       if constexpr (alignof(_Chunk) > 1)
 	{
@@ -237,8 +237,8 @@
 
   private:
     _Chunk(size_t __size, size_t __align, _Chunk* __next) noexcept
-    : _M_size(std::__log2p1(__size) - 1),
-      _M_align(std::__log2p1(__align) - 1)
+    : _M_size(std::__bit_width(__size) - 1),
+      _M_align(std::__bit_width(__align) - 1)
     {
       __builtin_memcpy(_M_next, &__next, sizeof(__next));
       _M_canary = _M_size | _M_align;
@@ -430,7 +430,7 @@
   private:
     static constexpr unsigned _S_size_digits
       = (numeric_limits<size_type>::digits
-	  + std::__log2p1(bits_per_word) - 1) / 2;
+	  + std::__bit_width(bits_per_word) - 1) / 2;
 
     word* _M_words = nullptr;
     // Number of blocks represented by the bitset:
@@ -553,7 +553,7 @@
     // Alignment must be a power-of-two so we only need to use enough bits
     // to store the power, not the actual value:
     static constexpr unsigned _S_alignbits
-      = std::__log2p1((unsigned)numeric_limits<size_t>::digits - 1);
+      = std::__bit_width((unsigned)numeric_limits<size_t>::digits - 1);
     // Use the remaining bits to store the size:
     static constexpr unsigned _S_sizebits
       = numeric_limits<size_t>::digits - _S_alignbits;
@@ -564,7 +564,7 @@
 
     big_block(size_t bytes, size_t alignment)
     : _M_size(alloc_size(bytes) >> _S_alignbits),
-      _M_align_exp(std::__log2p1(alignment) - 1u)
+      _M_align_exp(std::__bit_width(alignment) - 1u)
     { }
 
     void* pointer = nullptr;
@@ -686,7 +686,7 @@
       const size_t __words = (__blocks + __bits - 1) / __bits;
       const size_t __block_size = block_size();
       size_t __bytes = __blocks * __block_size + __words * sizeof(word);
-      size_t __alignment = std::__ceil2(__block_size);
+      size_t __alignment = std::__bit_ceil(__block_size);
       void* __p = __r->allocate(__bytes, __alignment);
       __try
 	{
@@ -713,7 +713,7 @@
 
     void release(memory_resource* __r)
     {
-      const size_t __alignment = std::__ceil2(block_size());
+      const size_t __alignment = std::__bit_ceil(block_size());
       for (auto& __c : _M_chunks)
 	if (__c._M_p)
 	  __r->deallocate(__c._M_p, __c._M_bytes, __alignment);
@@ -894,7 +894,7 @@
     else
       {
 	// Round to preferred granularity
-	static_assert(std::__ispow2(pool_sizes[0]));
+	static_assert(std::__has_single_bit(pool_sizes[0]));
 	constexpr size_t mask = pool_sizes[0] - 1;
 	opts.largest_required_pool_block += mask;
 	opts.largest_required_pool_block &= ~mask;
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/17_intro/freestanding.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/17_intro/freestanding.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/17_intro/freestanding.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/17_intro/freestanding.cc	2020-02-19 17:37:12.802815810 +0100
@@ -52,7 +52,7 @@
   std::initializer_list<int> ilisti __attribute__((unused));
 
 #if __cplusplus > 201703L
-  static_assert( std::ispow2(256u) );
+  static_assert( std::has_single_bit(256u) );
   static_assert( __cpp_lib_void_t >= 201411L );
 #endif
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/1.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/1.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/1.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/1.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,27 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do preprocess { target c++2a } }
+
+#include <utility>
+
+#ifndef __cpp_lib_integer_comparison_functions
+# error "Feature test macro for comparison functions is missing in <utility>"
+#elif __cpp_lib_integer_comparison_functions < 202002L
+# error "Feature test macro for comparison functions has wrong value in <utility>"
+#endif
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/2.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/2.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/2.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/2.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,27 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do preprocess { target c++2a } }
+
+#include <version>
+
+#ifndef __cpp_lib_integer_comparison_functions
+# error "Feature test macro for comparison functions is missing in <version>"
+#elif __cpp_lib_integer_comparison_functions < 202002L
+# error "Feature test macro for comparison functions has wrong value in <version>"
+#endif
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/equal.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/equal.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/equal.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/equal.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,74 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <utility>
+#include <limits>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  VERIFY( !std::cmp_equal(s, u) );
+}
+
+constexpr bool
+test02()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  if (std::cmp_equal(s, u))
+    throw 1;
+  if (std::cmp_equal(u, s))
+    throw 2;
+  return true;
+}
+
+void
+test03()
+{
+  short ss = -1;
+  int s = -1;
+  VERIFY( std::cmp_equal(s, ss) );
+  VERIFY( std::cmp_equal(ss, s) );
+
+  unsigned int u = (unsigned int) -1;
+  VERIFY( !std::cmp_equal(s, u) );
+  VERIFY( !std::cmp_equal(u, s) );
+  VERIFY( !std::cmp_equal(ss, u) );
+  VERIFY( !std::cmp_equal(u, ss) );
+
+  unsigned long long ul = (unsigned long long) -1;
+  VERIFY( !std::cmp_equal(s, ul) );
+  VERIFY( !std::cmp_equal(ul, s) );
+  VERIFY( !std::cmp_equal(ss, ul) );
+  VERIFY( !std::cmp_equal(ul, ss) );
+  VERIFY( !std::cmp_equal(u, ul) );
+  VERIFY( !std::cmp_equal(ul, u) );
+}
+
+int
+main()
+{
+  test01();
+  static_assert( test02() );
+  test03();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/equal_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/equal_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/equal_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/equal_neg.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,36 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <utility>
+
+bool a = std::cmp_equal('1', 49); // { dg-error "here" }
+bool b = std::cmp_equal(50, '2'); // { dg-error "here" }
+bool c = std::cmp_equal(2, L'2'); // { dg-error "here" }
+bool d = std::cmp_equal(L'2', 2); // { dg-error "here" }
+bool e = std::cmp_equal(true, 1); // { dg-error "here" }
+bool f = std::cmp_equal(0, false); // { dg-error "here" }
+bool g = std::cmp_equal(97, u8'a'); // { dg-error "here" }
+bool h = std::cmp_equal(u8'a', 97); // { dg-error "here" }
+bool i = std::cmp_equal(97, u'a'); // { dg-error "here" }
+bool j = std::cmp_equal(u'a', 97); // { dg-error "here" }
+bool k = std::cmp_equal(97, U'a'); // { dg-error "here" }
+bool l = std::cmp_equal(U'a', 97); // { dg-error "here" }
+
+// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,81 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <utility>
+#include <limits>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  VERIFY( !std::cmp_greater_equal(s, u) );
+  VERIFY( std::cmp_greater_equal(u, s) );
+  u = (unsigned) std::numeric_limits<int>::max() + 1U;
+  VERIFY( !std::cmp_greater_equal(s, u) );
+  VERIFY( std::cmp_greater_equal(u, s) );
+}
+
+constexpr bool
+test02()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  if (std::cmp_greater_equal(s, u))
+    throw 1;
+  if (!std::cmp_greater_equal(u, s))
+    throw 2;
+  return true;
+}
+
+void
+test03()
+{
+  short ss = -1;
+  int s = -1;
+  VERIFY( std::cmp_greater_equal(s, ss) );
+  VERIFY( std::cmp_greater_equal(ss, s) );
+  VERIFY( std::cmp_greater_equal(ss, -2) );
+
+  unsigned int u = (unsigned int) -1;
+  VERIFY( !std::cmp_greater_equal(s, u) );
+  VERIFY( std::cmp_greater_equal(u, s) );
+  VERIFY( !std::cmp_greater_equal(ss, u) );
+  VERIFY( std::cmp_greater_equal(u, ss) );
+  VERIFY( std::cmp_greater_equal(u, -2U) );
+
+  unsigned long long ul = (unsigned long long) -1;
+  VERIFY( !std::cmp_greater_equal(s, ul) );
+  VERIFY( std::cmp_greater_equal(ul, s) );
+  VERIFY( !std::cmp_greater_equal(ss, ul) );
+  VERIFY( std::cmp_greater_equal(ul, ss) );
+  VERIFY( !std::cmp_greater_equal(u, ul) );
+  VERIFY( std::cmp_greater_equal(ul, u) );
+  VERIFY( std::cmp_greater_equal(ul, -2UL) );
+}
+
+int
+main()
+{
+  test01();
+  static_assert( test02() );
+  test03();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,36 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <utility>
+
+bool a = std::cmp_greater_equal('1', 49); // { dg-error "here" }
+bool b = std::cmp_greater_equal(50, '2'); // { dg-error "here" }
+bool c = std::cmp_greater_equal(2, L'2'); // { dg-error "here" }
+bool d = std::cmp_greater_equal(L'2', 2); // { dg-error "here" }
+bool e = std::cmp_greater_equal(true, 1); // { dg-error "here" }
+bool f = std::cmp_greater_equal(0, false); // { dg-error "here" }
+bool g = std::cmp_greater_equal(97, u8'a'); // { dg-error "here" }
+bool h = std::cmp_greater_equal(u8'a', 97); // { dg-error "here" }
+bool i = std::cmp_greater_equal(97, u'a'); // { dg-error "here" }
+bool j = std::cmp_greater_equal(u'a', 97); // { dg-error "here" }
+bool k = std::cmp_greater_equal(97, U'a'); // { dg-error "here" }
+bool l = std::cmp_greater_equal(U'a', 97); // { dg-error "here" }
+
+// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,36 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <utility>
+
+bool a = std::cmp_greater('1', 49); // { dg-error "here" }
+bool b = std::cmp_greater(50, '2'); // { dg-error "here" }
+bool c = std::cmp_greater(2, L'2'); // { dg-error "here" }
+bool d = std::cmp_greater(L'2', 2); // { dg-error "here" }
+bool e = std::cmp_greater(true, 1); // { dg-error "here" }
+bool f = std::cmp_greater(0, false); // { dg-error "here" }
+bool g = std::cmp_greater(97, u8'a'); // { dg-error "here" }
+bool h = std::cmp_greater(u8'a', 97); // { dg-error "here" }
+bool i = std::cmp_greater(97, u'a'); // { dg-error "here" }
+bool j = std::cmp_greater(u'a', 97); // { dg-error "here" }
+bool k = std::cmp_greater(97, U'a'); // { dg-error "here" }
+bool l = std::cmp_greater(U'a', 97); // { dg-error "here" }
+
+// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,81 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <utility>
+#include <limits>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  VERIFY( std::in_range<unsigned int>(u) );
+  VERIFY( !std::in_range<int>(u) );
+  int s = -1;
+  VERIFY( !std::in_range<unsigned int>(s) );
+  s = std::numeric_limits<int>::max();
+  VERIFY( std::in_range<unsigned int>(s) );
+}
+
+constexpr bool
+test02()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  if (std::in_range<int>(u))
+    throw 1;
+  int s = -1;
+  if (std::in_range<unsigned>(s))
+    throw 2;
+  s = std::numeric_limits<int>::max();
+  if (!std::in_range<unsigned>(s))
+    throw 3;
+  return true;
+}
+
+void
+test03()
+{
+  short ss = -1;
+  VERIFY( std::in_range<int>(ss) );
+  VERIFY( !std::in_range<unsigned>(ss) );
+  int s = -1;
+  VERIFY( std::in_range<short>(s) );
+  VERIFY( !std::in_range<unsigned>(s) );
+  VERIFY( !std::in_range<unsigned long>(s) );
+  VERIFY( std::in_range<long>(s) );
+  s = std::numeric_limits<short>::min() - 1;
+  VERIFY( !std::in_range<short>(s) );
+
+  unsigned int u = (unsigned int) -1;
+  VERIFY( !std::in_range<int>(u) );
+  VERIFY( !std::in_range<unsigned short>(u) );
+
+  unsigned long ul = (unsigned long) -1;
+  VERIFY( !std::in_range<unsigned short>(ul) );
+  VERIFY( std::in_range<unsigned long long>(ul) );
+}
+
+int
+main()
+{
+  test01();
+  static_assert( test02() );
+  test03();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/in_range_neg.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,37 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <utility>
+
+bool a = std::in_range<int>('1'); // { dg-error "here" }
+bool b = std::in_range<char>(50); // { dg-error "here" }
+bool c = std::in_range<int>(L'2'); // { dg-error "here" }
+bool d = std::in_range<wchar_t>(2); // { dg-error "here" }
+bool e = std::in_range<int>(true); // { dg-error "here" }
+bool f = std::in_range<bool>(0); // { dg-error "here" }
+bool g = std::in_range<int>(u8'a'); // { dg-error "here" }
+bool h = std::in_range<char8_t>(97); // { dg-error "here" }
+bool i = std::in_range<int>(u'a'); // { dg-error "here" }
+bool j = std::in_range<char16_t>(97); // { dg-error "here" }
+bool k = std::in_range<int>(U'a'); // { dg-error "here" }
+bool l = std::in_range<char32_t>(97); // { dg-error "here" }
+
+// { dg-error "static assertion failed" "" { target *-*-* } 0 }
+// { dg-prune-output "incomplete type" }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,78 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <utility>
+#include <limits>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  VERIFY( std::cmp_less(s, u) );
+  VERIFY( !std::cmp_less(u, s) );
+  u = (unsigned) std::numeric_limits<int>::max() + 1U;
+  VERIFY( std::cmp_less(s, u) );
+  VERIFY( !std::cmp_less(u, s) );
+}
+
+constexpr bool
+test02()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  if (!std::cmp_less(s, u))
+    throw 1;
+  if (std::cmp_less(u, s))
+    throw 2;
+  return true;
+}
+
+void
+test03()
+{
+  short ss = -1;
+  int s = -1;
+  VERIFY( !std::cmp_less(s, ss) );
+  VERIFY( !std::cmp_less(ss, s) );
+
+  unsigned int u = (unsigned int) -1;
+  VERIFY( std::cmp_less(s, u) );
+  VERIFY( !std::cmp_less(u, s) );
+  VERIFY( std::cmp_less(ss, u) );
+  VERIFY( !std::cmp_less(u, ss) );
+
+  unsigned long long ul = (unsigned long long) -1;
+  VERIFY( std::cmp_less(s, ul) );
+  VERIFY( !std::cmp_less(ul, s) );
+  VERIFY( std::cmp_less(ss, ul) );
+  VERIFY( !std::cmp_less(ul, ss) );
+  VERIFY( std::cmp_less(u, ul) );
+  VERIFY( !std::cmp_less(ul, u) );
+}
+
+int
+main()
+{
+  test01();
+  static_assert( test02() );
+  test03();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,81 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <utility>
+#include <limits>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  VERIFY( std::cmp_less_equal(s, u) );
+  VERIFY( !std::cmp_less_equal(u, s) );
+  u = (unsigned) std::numeric_limits<int>::max() + 1U;
+  VERIFY( std::cmp_less_equal(s, u) );
+  VERIFY( !std::cmp_less_equal(u, s) );
+}
+
+constexpr bool
+test02()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  if (!std::cmp_less_equal(s, u))
+    throw 1;
+  if (std::cmp_less_equal(u, s))
+    throw 2;
+  return true;
+}
+
+void
+test03()
+{
+  short ss = -1;
+  int s = -1;
+  VERIFY( std::cmp_less_equal(s, ss) );
+  VERIFY( std::cmp_less_equal(ss, s) );
+  VERIFY( std::cmp_less_equal(-2, ss) );
+
+  unsigned int u = (unsigned int) -1;
+  VERIFY( std::cmp_less_equal(s, u) );
+  VERIFY( !std::cmp_less_equal(u, s) );
+  VERIFY( std::cmp_less_equal(ss, u) );
+  VERIFY( !std::cmp_less_equal(u, ss) );
+  VERIFY( std::cmp_less_equal(-2U, u) );
+
+  unsigned long long ul = (unsigned long long) -1;
+  VERIFY( std::cmp_less_equal(s, ul) );
+  VERIFY( !std::cmp_less_equal(ul, s) );
+  VERIFY( std::cmp_less_equal(ss, ul) );
+  VERIFY( !std::cmp_less_equal(ul, ss) );
+  VERIFY( std::cmp_less_equal(u, ul) );
+  VERIFY( !std::cmp_less_equal(ul, u) );
+  VERIFY( std::cmp_less_equal(-2UL, ul) );
+}
+
+int
+main()
+{
+  test01();
+  static_assert( test02() );
+  test03();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,36 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <utility>
+
+bool a = std::cmp_less_equal('1', 49); // { dg-error "here" }
+bool b = std::cmp_less_equal(50, '2'); // { dg-error "here" }
+bool c = std::cmp_less_equal(2, L'2'); // { dg-error "here" }
+bool d = std::cmp_less_equal(L'2', 2); // { dg-error "here" }
+bool e = std::cmp_less_equal(true, 1); // { dg-error "here" }
+bool f = std::cmp_less_equal(0, false); // { dg-error "here" }
+bool g = std::cmp_less_equal(97, u8'a'); // { dg-error "here" }
+bool h = std::cmp_less_equal(u8'a', 97); // { dg-error "here" }
+bool i = std::cmp_less_equal(97, u'a'); // { dg-error "here" }
+bool j = std::cmp_less_equal(u'a', 97); // { dg-error "here" }
+bool k = std::cmp_less_equal(97, U'a'); // { dg-error "here" }
+bool l = std::cmp_less_equal(U'a', 97); // { dg-error "here" }
+
+// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/less_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/less_neg.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,36 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <utility>
+
+bool a = std::cmp_less('1', 49); // { dg-error "here" }
+bool b = std::cmp_less(50, '2'); // { dg-error "here" }
+bool c = std::cmp_less(2, L'2'); // { dg-error "here" }
+bool d = std::cmp_less(L'2', 2); // { dg-error "here" }
+bool e = std::cmp_less(true, 1); // { dg-error "here" }
+bool f = std::cmp_less(0, false); // { dg-error "here" }
+bool g = std::cmp_less(97, u8'a'); // { dg-error "here" }
+bool h = std::cmp_less(u8'a', 97); // { dg-error "here" }
+bool i = std::cmp_less(97, u'a'); // { dg-error "here" }
+bool j = std::cmp_less(u'a', 97); // { dg-error "here" }
+bool k = std::cmp_less(97, U'a'); // { dg-error "here" }
+bool l = std::cmp_less(U'a', 97); // { dg-error "here" }
+
+// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,75 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <utility>
+#include <limits>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  VERIFY( std::cmp_not_equal(s, u) );
+  VERIFY( std::cmp_not_equal(u, s) );
+}
+
+constexpr bool
+test02()
+{
+  unsigned int u = std::numeric_limits<unsigned int>::max();
+  int s = -1;
+  if (!std::cmp_not_equal(s, u))
+    throw 1;
+  if (!std::cmp_not_equal(u, s))
+    throw 2;
+  return true;
+}
+
+void
+test03()
+{
+  short ss = -1;
+  int s = -1;
+  VERIFY( !std::cmp_not_equal(s, ss) );
+  VERIFY( !std::cmp_not_equal(ss, s) );
+
+  unsigned int u = (unsigned int) -1;
+  VERIFY( std::cmp_not_equal(s, u) );
+  VERIFY( std::cmp_not_equal(u, s) );
+  VERIFY( std::cmp_not_equal(ss, u) );
+  VERIFY( std::cmp_not_equal(u, ss) );
+
+  unsigned long long ul = (unsigned long long) -1;
+  VERIFY( std::cmp_not_equal(s, ul) );
+  VERIFY( std::cmp_not_equal(ul, s) );
+  VERIFY( std::cmp_not_equal(ss, ul) );
+  VERIFY( std::cmp_not_equal(ul, ss) );
+  VERIFY( std::cmp_not_equal(u, ul) );
+  VERIFY( std::cmp_not_equal(ul, u) );
+}
+
+int
+main()
+{
+  test01();
+  static_assert( test02() );
+  test03();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/integer_comparisons/not_equal_neg.cc	2020-02-19 17:37:12.823815811 +0100
@@ -0,0 +1,36 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <utility>
+
+bool a = std::cmp_equal('1', 49); // { dg-error "here" }
+bool b = std::cmp_equal(50, '2'); // { dg-error "here" }
+bool c = std::cmp_equal(2, L'2'); // { dg-error "here" }
+bool d = std::cmp_equal(L'2', 2); // { dg-error "here" }
+bool e = std::cmp_equal(true, 1); // { dg-error "here" }
+bool f = std::cmp_equal(0, false); // { dg-error "here" }
+bool g = std::cmp_equal(97, u8'a'); // { dg-error "here" }
+bool h = std::cmp_equal(u8'a', 97); // { dg-error "here" }
+bool i = std::cmp_equal(97, u'a'); // { dg-error "here" }
+bool j = std::cmp_equal(u'a', 97); // { dg-error "here" }
+bool k = std::cmp_equal(97, U'a'); // { dg-error "here" }
+bool l = std::cmp_equal(U'a', 97); // { dg-error "here" }
+
+// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/polymorphic_allocator/lwg3237.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/polymorphic_allocator/lwg3237.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/polymorphic_allocator/lwg3237.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/polymorphic_allocator/lwg3237.cc	2020-02-19 17:37:12.837815812 +0100
@@ -0,0 +1,55 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <memory_resource>
+#include <testsuite_hooks.h>
+
+struct large { alignas(1024) int i; };
+
+void
+test01()
+{
+  std::pmr::polymorphic_allocator<large> a;
+  large* p = nullptr;
+  try
+  {
+    p = a.allocate(std::size_t(-1) / 256);
+    VERIFY( false );
+  }
+  catch (const std::bad_array_new_length&)
+  {
+  }
+
+  std::pmr::polymorphic_allocator<int> a2;
+  try
+  {
+    p = a2.allocate_object<large>(std::size_t(-1) / 256);
+    VERIFY( false );
+  }
+  catch (const std::bad_array_new_length&)
+  {
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc	2020-02-19 17:37:12.842815812 +0100
@@ -54,7 +54,7 @@
       ranges::uninitialized_default_construct(rx);
       VERIFY( X::count == size );
 
-      auto i = rx.cbegin();
+      auto i = rx.begin();
       if (k == 0)
 	i = ranges::destroy(rx);
       else if (k == 1)
@@ -64,7 +64,7 @@
       else
 	__builtin_abort();
 
-      VERIFY( i == rx.cend() );
+      VERIFY( i == rx.end() );
       VERIFY( X::count == 0 );
     }
 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc	2020-02-19 17:37:12.842815812 +0100
@@ -47,7 +47,7 @@
       auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
       std::span<T> rx((T *)buffer.get(), size);
 
-      ranges::uninitialized_copy_result res = {ix.cbegin(), rx.cbegin()};
+      ranges::uninitialized_copy_result res = {ix.begin(), rx.begin()};
       if (k == 0)
 	res = ranges::uninitialized_copy(ix.begin(), ix.end(),
 					 rx.begin(), rx.end());
@@ -58,33 +58,33 @@
 					   rx.begin(), rx.end());
       else if (k == 3)
 	res = ranges::uninitialized_copy(ix.begin(), ix.end(),
-					 rx.cbegin(), rx.cend());
+					 rx.begin(), rx.end());
       else if (k == 4)
 	res = ranges::uninitialized_copy(ix, std::as_const(rx));
       else if (k == 5)
 	res = ranges::uninitialized_copy_n(ix.begin(), size,
-					   rx.cbegin(), rx.cend());
+					   rx.begin(), rx.end());
       else if (k == 6)
 	res = ranges::uninitialized_copy_n(ix.begin(), size/2,
-					   rx.cbegin(), rx.cend());
+					   rx.begin(), rx.end());
       else if (k == 7)
 	res = ranges::uninitialized_copy_n(ix.begin(), size,
-					   rx.cbegin(), rx.cbegin()+size/2);
+					   rx.begin(), rx.begin()+size/2);
       else
 	__builtin_abort();
 
       if (k == 6 || k == 7)
 	{
-	  VERIFY( ranges::distance(ix.cbegin(), res.in) == size/2 );
-	  VERIFY( ranges::distance(rx.cbegin(), res.out) == size/2 );
+	  VERIFY( ranges::distance(ix.begin(), res.in) == size/2 );
+	  VERIFY( ranges::distance(rx.begin(), res.out) == size/2 );
 	  VERIFY( ranges::equal(ix.begin(), ix.begin()+size/2,
 				rx.begin(), rx.begin()+size/2) );
 	  ranges::destroy(rx.begin(), rx.begin()+size/2);
 	}
       else
 	{
-	  VERIFY( res.in == ix.cend() );
-	  VERIFY( res.out == rx.cend() );
+	  VERIFY( res.in == ix.end() );
+	  VERIFY( res.out == rx.end() );
 	  VERIFY( ranges::equal(ix, rx) );
 	  ranges::destroy(rx);
 	}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc	2020-02-19 17:37:12.843815812 +0100
@@ -53,7 +53,7 @@
 	  ranges::fill(rx, t);
 	}
 
-      auto i = rx.cbegin();
+      auto i = rx.begin();
       if (k == 0)
 	i = ranges::uninitialized_default_construct(rx.begin(), rx.end());
       else if (k == 1)
@@ -63,15 +63,15 @@
       else if constexpr (std::is_fundamental_v<T>)
 	continue;
       else if (k == 3)
-	i = ranges::uninitialized_default_construct(rx.cbegin(), rx.cend());
+	i = ranges::uninitialized_default_construct(rx.begin(), rx.end());
       else if (k == 4)
 	i = ranges::uninitialized_default_construct(std::as_const(rx));
       else if (k == 5)
-	i = ranges::uninitialized_default_construct_n(rx.cbegin(), 1024);
+	i = ranges::uninitialized_default_construct_n(rx.begin(), 1024);
       else
 	__builtin_abort();
 
-      VERIFY( i == rx.cend() );
+      VERIFY( i == rx.end() );
       VERIFY( ranges::find_if(rx, [&t](const T& v) { return t != v; }) == i );
 
       ranges::destroy(rx);
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc	2020-02-19 17:37:12.843815812 +0100
@@ -45,7 +45,7 @@
       auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
       std::span<T> rx((T *)buffer.get(), size);
 
-      auto i = rx.cbegin();
+      auto i = rx.begin();
       if (k == 0)
 	i = ranges::uninitialized_fill(rx.begin(), rx.end(), value);
       else if (k == 1)
@@ -53,15 +53,15 @@
       else if (k == 2)
 	i = ranges::uninitialized_fill_n(rx.begin(), 1024, value);
       else if (k == 3)
-	i = ranges::uninitialized_fill(rx.cbegin(), rx.cend(), value);
+	i = ranges::uninitialized_fill(rx.begin(), rx.end(), value);
       else if (k == 4)
 	i = ranges::uninitialized_fill(std::as_const(rx), value);
       else if (k == 5)
-	i = ranges::uninitialized_fill_n(rx.cbegin(), 1024, value);
+	i = ranges::uninitialized_fill_n(rx.begin(), 1024, value);
       else
 	__builtin_abort();
 
-      VERIFY( i == rx.cend() );
+      VERIFY( i == rx.end() );
       VERIFY( ranges::find_if(rx, [&value](const T& v) { return value != v; }) == i );
 
       ranges::destroy(rx);
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc	2020-02-19 17:37:12.843815812 +0100
@@ -51,7 +51,7 @@
       auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);
       std::span<T> rx((T *)buffer.get(), size);
 
-      ranges::uninitialized_move_result res = {ix.cbegin(), rx.cbegin()};
+      ranges::uninitialized_move_result res = {ix.begin(), rx.begin()};
       if (k == 0)
 	res = ranges::uninitialized_move(ix.begin(), ix.end(),
 					 rx.begin(), rx.end());
@@ -62,33 +62,33 @@
 					   rx.begin(), rx.end());
       else if (k == 3)
 	res = ranges::uninitialized_move(ix.begin(), ix.end(),
-					 rx.cbegin(), rx.cend());
+					 rx.begin(), rx.end());
       else if (k == 4)
 	res = ranges::uninitialized_move(ix, std::as_const(rx));
       else if (k == 5)
 	res = ranges::uninitialized_move_n(ix.begin(), size,
-					   rx.cbegin(), rx.cend());
+					   rx.begin(), rx.end());
       else if (k == 6)
 	res = ranges::uninitialized_move_n(ix.begin(), size/2,
-					   rx.cbegin(), rx.cend());
+					   rx.begin(), rx.end());
       else if (k == 7)
 	res = ranges::uninitialized_move_n(ix.begin(), size,
-					   rx.cbegin(), rx.cbegin()+size/2);
+					   rx.begin(), rx.begin()+size/2);
       else
 	__builtin_abort();
 
       if (k == 6 || k == 7)
 	{
-	  VERIFY( ranges::distance(ix.cbegin(), res.in) == size/2 );
-	  VERIFY( ranges::distance(rx.cbegin(), res.out) == size/2 );
+	  VERIFY( ranges::distance(ix.begin(), res.in) == size/2 );
+	  VERIFY( ranges::distance(rx.begin(), res.out) == size/2 );
 	  VERIFY( ranges::equal(saved_ix.begin(), saved_ix.begin()+size/2,
 				rx.begin(), rx.begin()+size/2) );
 	  ranges::destroy(rx.begin(), rx.begin()+size/2);
 	}
       else
 	{
-	  VERIFY( res.in == ix.cend() );
-	  VERIFY( res.out == rx.cend() );
+	  VERIFY( res.in == ix.end() );
+	  VERIFY( res.out == rx.end() );
 	  VERIFY( ranges::equal(saved_ix, rx) );
 	  ranges::destroy(rx);
 	}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc	2020-02-19 17:37:12.843815812 +0100
@@ -48,7 +48,7 @@
 
       T t{};
 
-      auto i = rx.cbegin();
+      auto i = rx.begin();
       if (k == 0)
 	i = ranges::uninitialized_value_construct(rx.begin(), rx.end());
       else if (k == 1)
@@ -56,15 +56,15 @@
       else if (k == 2)
 	i = ranges::uninitialized_value_construct_n(rx.begin(), 1024);
       else if (k == 3)
-	i = ranges::uninitialized_value_construct(rx.cbegin(), rx.cend());
+	i = ranges::uninitialized_value_construct(rx.begin(), rx.end());
       else if (k == 4)
 	i = ranges::uninitialized_value_construct(std::as_const(rx));
       else if (k == 5)
-	i = ranges::uninitialized_value_construct_n(rx.cbegin(), 1024);
+	i = ranges::uninitialized_value_construct_n(rx.begin(), 1024);
       else
 	__builtin_abort();
 
-      VERIFY( i == rx.cend() );
+      VERIFY( i == rx.end() );
       VERIFY( ranges::find_if(rx, [&t](const T& v) { return t != v; }) == i );
 
       ranges::destroy(rx);
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc	2020-02-19 17:37:12.848815812 +0100
@@ -20,6 +20,12 @@
 
 #include <type_traits>
 
+#ifndef __cpp_lib_unwrap_ref
+# error "Feature-test macro for unwrap_reference missing in <type_traits>"
+#elif __cpp_lib_unwrap_ref != 201811L
+# error "Feature-test macro for unwrap_reference has wrong value in <type_traits>"
+#endif
+
 template<typename T, typename U> struct expect_same;
 template<typename T> struct expect_same<T, T> : std::true_type { };
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/20_util/unwrap_reference/3.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/unwrap_reference/3.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/20_util/unwrap_reference/3.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/20_util/unwrap_reference/3.cc	2020-02-19 17:37:12.848815812 +0100
@@ -0,0 +1,27 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <version>
+
+#ifndef __cpp_lib_unwrap_ref
+# error "Feature-test macro for unwrap_reference missing in <version>"
+#elif __cpp_lib_unwrap_ref != 201811L
+# error "Feature-test macro for unwrap_reference has wrong value in <version>"
+#endif
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/1.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/1.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/1.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/1.cc	2020-02-19 17:37:12.900815815 +0100
@@ -22,6 +22,6 @@
 
 #ifndef __cpp_lib_span
 # error "Feature-test macro for span missing in <span>"
-#elif __cpp_lib_span != 201902L
+#elif __cpp_lib_span != 202002L
 # error "Feature-test macro for span has wrong value in <span>"
 #endif
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/2.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/2.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/2.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/2.cc	2020-02-19 17:37:12.900815815 +0100
@@ -22,6 +22,6 @@
 
 #ifndef __cpp_lib_span
 # error "Feature-test macro for span missing in <version>"
-#elif __cpp_lib_span != 201902L
+#elif __cpp_lib_span != 202002L
 # error "Feature-test macro for span has wrong value in <version>"
 #endif
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/deduction.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/deduction.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/deduction.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/deduction.cc	2020-02-19 17:37:12.900815815 +0100
@@ -73,7 +73,7 @@
   std::span s9(s2);
   static_assert( is_static_span<int, 2>(s9) );
 
-  std::span s10(const_cast<std::span<int, 2>&>(s2));
+  std::span s10(const_cast<const std::span<int, 2>&>(s2));
   static_assert( is_static_span<int, 2>(s10) );
 
   std::span s11(s5);
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/everything.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/everything.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/everything.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/everything.cc	2020-02-19 17:37:12.900815815 +0100
@@ -104,8 +104,6 @@
   static_assert(data_span_first.size() == 3);
   static_assert(data_span_first.front() == 0);
   static_assert(data_span_first.back() == 2);
-  static_assert(std::tuple_size_v<decltype(data_span_first)> == 3);
-  static_assert(std::is_same_v<std::tuple_element_t<0, decltype(data_span_first)>, const int>);
 
   constexpr auto data_span_first_dyn = data_span.first(4);
   static_assert(
@@ -122,8 +120,6 @@
   static_assert(data_span_last.size() == 5);
   static_assert(data_span_last.front() == 4);
   static_assert(data_span_last.back() == 8);
-  static_assert(std::tuple_size_v<decltype(data_span_last)> == 5);
-  static_assert(std::is_same_v<std::tuple_element_t<0, decltype(data_span_last)>, const int>);
 
   constexpr auto data_span_last_dyn = data_span.last(6);
   static_assert(
@@ -166,9 +162,8 @@
   bool really_empty1 = std::empty(shorts);
   bool really_empty2 = shorts.data() == nullptr;
   bool really_empty3 = shorts.begin() == shorts.end();
-  bool really_empty4 = shorts.cbegin() == shorts.cend();
   bool really_empty =
-    really_empty0 && really_empty1 && really_empty2 && really_empty3 && really_empty4;
+    really_empty0 && really_empty1 && really_empty2 && really_empty3;
   (void)really_empty;
   VERIFY(really_empty);
 
@@ -183,10 +178,10 @@
   std::span<const std::byte> muh_byte_span   = std::as_bytes(muh_span);
   std::span<std::byte> muh_mutable_byte_span = std::as_writable_bytes(muh_span);
   std::span<std::byte> muh_original_byte_span(original_bytes, original_bytes + 4);
-  bool definitely_reinterpret_casted0 = std::equal(muh_byte_span.cbegin(), muh_byte_span.cend(),
-    muh_original_byte_span.cbegin(), muh_original_byte_span.cend());
-  bool definitely_reinterpret_casted1 = std::equal(muh_mutable_byte_span.cbegin(),
-    muh_mutable_byte_span.cend(), muh_original_byte_span.cbegin(), muh_original_byte_span.cend());
+  bool definitely_reinterpret_casted0 = std::equal(muh_byte_span.begin(), muh_byte_span.end(),
+    muh_original_byte_span.begin(), muh_original_byte_span.end());
+  bool definitely_reinterpret_casted1 = std::equal(muh_mutable_byte_span.begin(),
+    muh_mutable_byte_span.end(), muh_original_byte_span.begin(), muh_original_byte_span.end());
   bool definitely_reinterpret_casted =
     definitely_reinterpret_casted0 && definitely_reinterpret_casted1;
   (void)definitely_reinterpret_casted;
@@ -194,8 +189,8 @@
 
   std::span<std::byte> muh_original_byte_span_ptr_size(original_bytes, 4);
   bool definitely_equivalent =
-    std::equal(muh_original_byte_span_ptr_size.cbegin(), muh_original_byte_span_ptr_size.cend(),
-      muh_original_byte_span.cbegin(), muh_original_byte_span.cend());
+    std::equal(muh_original_byte_span_ptr_size.begin(), muh_original_byte_span_ptr_size.end(),
+      muh_original_byte_span.begin(), muh_original_byte_span.end());
   (void)definitely_equivalent;
   VERIFY(definitely_equivalent);
 
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/explicit.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/explicit.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/explicit.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/explicit.cc	2020-02-19 17:37:12.900815815 +0100
@@ -0,0 +1,48 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <span>
+
+struct Range
+{
+  int* begin();
+  int* end();
+  unsigned size() const;
+} r;
+
+auto first = std::begin(r), last = std::end(r);
+
+// span(It, size_type)
+std::span<int> s1 = {first, 2};
+std::span<int, 2> s2 = {first, 2}; // { dg-error "could not convert" }
+
+// span(It, End)
+std::span<int> s3 = {first, last};
+std::span<int, 2> s4 = {first, last}; // { dg-error "could not convert" }
+
+// span(R&&)
+std::span<int> s5 = r;
+std::span<int, 2> s6 = r; // { dg-error "conversion from" }
+
+// span(const span<OtherElement, OtherExtent>&)
+std::span<const int> s7 = s5;
+std::span<const int> s8 = s6;
+std::span<const int, 1> s9 = s5.first(1);  // { dg-error "conversion from" }
+std::span<const int, 1> s10 = s7.first(1); // { dg-error "conversion from" }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/get_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/get_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/get_neg.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/get_neg.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-// Copyright (C) 2019-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=c++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <span>
-#include <tuple>
-
-int
-main()
-{
-  std::span<int, std::dynamic_extent> myspan((int*)nullptr, (std::size_t)0);
-  std::get<0>(myspan); // { dg-error "here" }
-}
-// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/lwg3255.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/lwg3255.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/lwg3255.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/lwg3255.cc	2020-02-19 17:37:12.900815815 +0100
@@ -57,10 +57,14 @@
 static_assert( is_constructible_v<span<int>, int(&)[2]> );
 static_assert( is_constructible_v<span<const int>, int(&)[2]> );
 static_assert( is_constructible_v<span<const int>, const int(&)[2]> );
+static_assert( is_constructible_v<span<const int>, int[2]> );
+static_assert( is_constructible_v<span<const int>, const int[2]> );
 
 static_assert( is_constructible_v<span<int>, array<int, 2>&> );
 static_assert( is_constructible_v<span<const int>, array<int, 2>&> );
 static_assert( is_constructible_v<span<const int>, array<const int, 2>&> );
+static_assert( is_constructible_v<span<const int>, array<int, 2>> );
+static_assert( is_constructible_v<span<const int>, array<const int, 2>> );
 
 static_assert( is_constructible_v<span<const int>, const array<int, 2>&> );
 static_assert( is_constructible_v<span<const int>, const array<const int, 2>&> );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/tuple_element_dynamic_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/tuple_element_dynamic_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/tuple_element_dynamic_neg.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/tuple_element_dynamic_neg.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-// Copyright (C) 2019-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=c++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <span>
-#include <tuple>
-
-std::tuple_element<0, std::span<int, std::dynamic_extent>> ts; // { dg-error "here" }
-// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/tuple_element_oob_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/tuple_element_oob_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/tuple_element_oob_neg.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/tuple_element_oob_neg.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-// Copyright (C) 2019-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=c++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <span>
-#include <tuple>
-
-std::tuple_element<3, std::span<int, 2>> te; // { dg-error "here" }
-// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/tuple_size_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/tuple_size_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/23_containers/span/tuple_size_neg.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/23_containers/span/tuple_size_neg.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-// Copyright (C) 2019-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=c++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <span>
-#include <tuple>
-
-std::tuple_size<std::span<int, std::dynamic_extent>> ts; // { dg-error "here" }
-// { dg-error "static assertion failed" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/clamp/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/clamp/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/clamp/constrained.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/clamp/constrained.cc	2020-02-19 17:37:12.918815815 +0100
@@ -0,0 +1,58 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <algorithm>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+using __gnu_test::test_container;
+using __gnu_test::test_range;
+using __gnu_test::input_iterator_wrapper;
+
+namespace ranges = std::ranges;
+
+struct X
+{
+  int i, j;
+};
+
+void
+test01()
+{
+  VERIFY( ranges::clamp(1, 2, 4) == 2 );
+  VERIFY( ranges::clamp(3, 2, 4) == 3 );
+  VERIFY( ranges::clamp(5, 2, 4) == 4 );
+
+  VERIFY( ranges::clamp(1, 4, 2, ranges::greater{}) == 2 );
+  VERIFY( ranges::clamp(3, 4, 2, ranges::greater{}) == 3 );
+  VERIFY( ranges::clamp(5, 4, 2, ranges::greater{}) == 4 );
+
+  VERIFY( ranges::clamp(1, 2, 4, ranges::greater{}, std::negate<>{}) == 2 );
+  VERIFY( ranges::clamp(3, 2, 4, ranges::greater{}, std::negate<>{}) == 3 );
+  VERIFY( ranges::clamp(5, 2, 4, ranges::greater{}, std::negate<>{}) == 4 );
+
+  static_assert(ranges::clamp(X{1,2}, X{1,3}, X{1,4}, {}, &X::i).j == 2);
+}
+
+int
+main()
+{
+  test01();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc	2020-02-19 17:37:12.924815816 +0100
@@ -26,6 +26,7 @@
 using __gnu_test::test_range;
 using __gnu_test::input_iterator_wrapper;
 using __gnu_test::forward_iterator_wrapper;
+using __gnu_test::random_access_iterator_wrapper;
 
 namespace ranges = std::ranges;
 
@@ -75,9 +76,52 @@
   static_assert(f() == 6);
 }
 
+template<template<typename> typename wrapper>
+void
+test03()
+{
+  int x[] = {1,2,3,4,5};
+  test_range<int, wrapper> rx(x);
+  int s = 0;
+  auto func = [&s](int i){ s += i; };
+  auto [i,f] = ranges::for_each_n(rx.begin(), 3, func);
+  VERIFY( i.ptr = x+3 );
+  VERIFY( s == 1+2+3 );
+  f(1);
+  VERIFY( s == 1+2+3+1 );
+
+  s = 0;
+  rx.bounds.first = x;
+  auto [j,g] = ranges::for_each_n(rx.begin(), -1, func);
+  VERIFY( j.ptr == x );
+  VERIFY( s == 0 );
+  g(1);
+  VERIFY( s == 1 );
+
+  s = 0;
+  rx.bounds.first = x;
+  auto [k,h] = ranges::for_each_n(rx.begin(), 5, func, std::negate<>{});
+  VERIFY( k.ptr == x+5 );
+  VERIFY( s == -(1+2+3+4+5) );
+  h(-6);
+  VERIFY( s == -(1+2+3+4+5+6) );
+}
+
+constexpr bool
+test04()
+{
+  int x[] = {1,2,3,4,5};
+  int p = 1;
+  ranges::for_each_n(x+1, 4, [&p](int i){ p*=i; }, [](int i){ return i+1; });
+  return p == 3*4*5*6;
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03<input_iterator_wrapper>();
+  test03<random_access_iterator_wrapper>();
+  static_assert(test04());
 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/next_permutation/constrained.cc	2020-02-19 17:37:12.929815816 +0100
@@ -41,7 +41,7 @@
       for (int j = 0; ; j++)
 	{
 	  auto found1 = std::next_permutation(cx.begin(), cx.end());
-	  auto [found2,last] = ranges::next_permutation(cy.begin(), cy.end());
+	  auto [last,found2] = ranges::next_permutation(cy.begin(), cy.end());
 	  VERIFY( found1 == found2 );
 	  VERIFY( ranges::equal(cx, cy) );
 	  if (!found2)
@@ -55,7 +55,7 @@
 {
   int x[] = {5, 4, 3, 2, 1};
   test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto [found,last] = ranges::next_permutation(rx, ranges::greater{});
+  auto [last,found] = ranges::next_permutation(rx, ranges::greater{});
   VERIFY( found && last == rx.end() );
   VERIFY( last == rx.end() );
   VERIFY( ranges::equal(rx, (int[]){5,4,3,1,2}) );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/prev_permutation/constrained.cc	2020-02-19 17:37:12.931815816 +0100
@@ -41,7 +41,7 @@
       for (int j = 0; ; j++)
 	{
 	  auto found1 = std::prev_permutation(cx.begin(), cx.end());
-	  auto [found2,last] = ranges::prev_permutation(cy.begin(), cy.end());
+	  auto [last,found2] = ranges::prev_permutation(cy.begin(), cy.end());
 	  VERIFY( found1 == found2 );
 	  VERIFY( ranges::equal(cx, cy) );
 	  if (!found2)
@@ -55,7 +55,7 @@
 {
   int x[] = {1, 2, 3, 4, 5};
   test_range<int, bidirectional_iterator_wrapper> rx(x);
-  auto [found,last] = ranges::prev_permutation(rx, ranges::greater{});
+  auto [last,found] = ranges::prev_permutation(rx, ranges::greater{});
   VERIFY( found && last == rx.end() );
   VERIFY( last == rx.end() );
   VERIFY( ranges::equal(rx, (int[]){1,2,3,5,4}) );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/sample/constrained.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/sample/constrained.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/25_algorithms/sample/constrained.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/25_algorithms/sample/constrained.cc	2020-02-19 17:37:12.935815816 +0100
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+// { dg-require-cstdint "" }
+
+#include <algorithm>
+#include <random>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+using __gnu_test::test_range;
+using __gnu_test::forward_iterator_wrapper;
+using __gnu_test::input_iterator_wrapper;
+using __gnu_test::output_iterator_wrapper;
+using __gnu_test::random_access_iterator_wrapper;
+
+namespace ranges = std::ranges;
+
+std::mt19937 rng;
+
+template<template<typename> typename in_wrapper,
+	 template<typename> typename out_wrapper>
+void
+test01()
+{
+  const int x[] = {1,2,3,4,5,6,7,8,9,10};
+  test_range<const int, in_wrapper> rx(x);
+  int y[10];
+  test_range<int, out_wrapper> ry(y);
+  auto out = ranges::sample(rx.begin(), rx.end(), ry.begin(), 20, rng);
+  VERIFY( out.ptr == y+10 );
+  VERIFY( ranges::equal(x, y) );
+
+  for (int i = 0; i < 100; i++)
+    {
+      int z[5] = {0};
+      test_range<int, out_wrapper> rz(z);
+      rx.bounds.first = x;
+      auto out = ranges::sample(rx, rz.begin(), 5, rng);
+      VERIFY( out.ptr == z+5 );
+      ranges::sort(z);
+      VERIFY( ranges::adjacent_find(z) == out.ptr );
+      VERIFY( ranges::includes(x, z) );
+    }
+}
+
+int
+main()
+{
+  test01<forward_iterator_wrapper, output_iterator_wrapper>();
+  test01<input_iterator_wrapper, random_access_iterator_wrapper>();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_one.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_one.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_one.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_one.cc	2020-02-19 17:37:12.939815816 +0100
@@ -19,6 +19,7 @@
 // { dg-do compile { target c++2a } }
 
 #include <bit>
+#include <limits>
 
 template<typename UInt>
 constexpr auto
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_zero.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_zero.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_zero.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countl_zero.cc	2020-02-19 17:37:12.939815816 +0100
@@ -19,6 +19,7 @@
 // { dg-do compile { target c++2a } }
 
 #include <bit>
+#include <limits>
 
 template<typename UInt>
 constexpr auto
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_one.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_one.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_one.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_one.cc	2020-02-19 17:37:12.939815816 +0100
@@ -19,6 +19,7 @@
 // { dg-do compile { target c++2a } }
 
 #include <bit>
+#include <limits>
 
 template<typename UInt>
 constexpr auto
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_zero.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_zero.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_zero.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/countr_zero.cc	2020-02-19 17:37:12.939815816 +0100
@@ -19,6 +19,7 @@
 // { dg-do compile { target c++2a } }
 
 #include <bit>
+#include <limits>
 
 template<typename UInt>
 constexpr auto
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/popcount.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/popcount.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.count/popcount.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.count/popcount.cc	2020-02-19 17:37:12.939815816 +0100
@@ -19,6 +19,7 @@
 // { dg-do compile { target c++2a } }
 
 #include <bit>
+#include <limits>
 
 template<typename UInt>
 constexpr auto
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc	2020-02-19 17:37:12.939815816 +0100
@@ -0,0 +1,132 @@
+// Copyright (C) 2018-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <bit>
+#include <limits>
+
+template<typename T>
+  constexpr T max = std::numeric_limits<T>::max();
+// Largest representable power of two (i.e. has most significant bit set)
+template<typename T>
+  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);
+
+// Detect whether std::bit_ceil(N) is a constant expression.
+template<auto N, typename = void>
+  struct bit_ceil_valid
+  : std::false_type { };
+
+template<auto N>
+  struct bit_ceil_valid<N, std::void_t<char[(std::bit_ceil(N), 1)]>>
+  : std::true_type { };
+
+template<typename UInt>
+constexpr auto
+test(UInt x)
+-> decltype(std::bit_ceil(x))
+{
+  static_assert( noexcept(std::bit_ceil(x)) );
+
+  static_assert( std::bit_ceil(UInt(0)) == 1 );
+  static_assert( std::bit_ceil(UInt(1)) == 1 );
+  static_assert( std::bit_ceil(UInt(2)) == 2 );
+  static_assert( std::bit_ceil(UInt(3)) == 4 );
+  static_assert( std::bit_ceil(UInt(4)) == 4 );
+  static_assert( std::bit_ceil(UInt(0x11)) == 0x20 );
+  static_assert( std::bit_ceil(UInt(0x20)) == 0x20 );
+
+  if constexpr (std::numeric_limits<UInt>::digits > 8)
+  {
+    static_assert( std::bit_ceil(UInt(0x201)) == 0x400 );
+    static_assert( std::bit_ceil(UInt(0x8ff)) == 0x1000 );
+    static_assert( std::bit_ceil(UInt(0x1000)) == 0x1000 );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 32)
+  {
+    static_assert( std::bit_ceil(UInt(0xabcdef)) == 0x1000000 );
+    static_assert( std::bit_ceil(UInt(0x1000000)) == 0x1000000 );
+    static_assert( std::bit_ceil(UInt(0x1000001)) == 0x2000000 );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 64)
+  {
+    static_assert( std::bit_ceil(UInt(1) << 64) == (UInt(1) << 64) );
+    static_assert( std::bit_ceil(UInt(3) << 64) == (UInt(4) << 64) );
+  }
+
+  constexpr UInt msb = maxpow2<UInt>;
+  static_assert( bit_ceil_valid<msb>() );
+  static_assert( std::bit_ceil( msb ) == msb );
+  static_assert( std::bit_ceil( UInt(msb - 1) ) == msb );
+  static_assert( std::bit_ceil( UInt(msb - 2) ) == msb );
+  static_assert( std::bit_ceil( UInt(msb - 3) ) == msb );
+
+  // P1355R2: not a constant expression if the result is not representable
+  static_assert( !bit_ceil_valid<UInt(msb + 1)>() );
+  static_assert( !bit_ceil_valid<max<UInt>>() );
+  static_assert( !bit_ceil_valid<UInt(max<UInt> - 1)>() );
+  static_assert( !bit_ceil_valid<UInt(max<UInt> - 2)>() );
+
+  return true;
+}
+
+static_assert( test( (unsigned char)0 ) );
+static_assert( test( (unsigned short)0 ) );
+static_assert( test( (unsigned int)0 ) );
+static_assert( test( (unsigned long)0 ) );
+static_assert( test( (unsigned long long)0 ) );
+
+// std::bit_ceil(T) shall not participate in overload resolution
+// unless T is an unsigned integer type.
+struct X { constexpr bool did_not_match() { return true; } };
+constexpr X test(...) { return X{}; }
+static_assert( test( (bool)0 ).did_not_match() );
+static_assert( test( (char)0 ).did_not_match() );
+static_assert( test( (int)0 ).did_not_match() );
+static_assert( test( (char16_t)0 ).did_not_match() );
+static_assert( test( (float)0 ).did_not_match() );
+static_assert( test( (void*)0 ).did_not_match() );
+static_assert( test( X{} ).did_not_match() );
+enum E : unsigned { e };
+static_assert( test( e ).did_not_match() );
+
+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
+static_assert( test( (unsigned __int128)0 ) );
+static_assert( test( (__int128)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_0)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_1)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_2)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_3)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_3)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_3)0 ).did_not_match() );
+#endif
+
+#include <cstddef>
+static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc	2020-02-19 17:37:12.939815816 +0100
@@ -0,0 +1,75 @@
+// Copyright (C) 2019-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a -D_GLIBCXX_ASSERTIONS" }
+// { dg-do run { target c++2a } }
+// { dg-xfail-run-if "__glibcxx_assert in bit_ceil should fail" { *-*-* } }
+
+#include <bit>
+#include <limits>
+
+// P1355R2: not a constant expression if the result is not representable
+
+template<auto N, typename = void>
+  struct bit_ceil_valid
+  : std::false_type { };
+
+template<auto N>
+  struct bit_ceil_valid<N, std::void_t<char[(std::bit_ceil(N), 1)]>>
+  : std::true_type { };
+
+template<typename T>
+  constexpr T max = std::numeric_limits<T>::max();
+template<typename T>
+  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);
+
+static_assert( bit_ceil_valid<maxpow2<unsigned char>>() );
+static_assert( !bit_ceil_valid<maxpow2<unsigned char> + (unsigned char)1>() );
+
+static_assert( !bit_ceil_valid<max<unsigned char>>() );
+static_assert( !bit_ceil_valid<max<unsigned char> - (unsigned char)1>() );
+
+static_assert( bit_ceil_valid<maxpow2<unsigned short>>() );
+static_assert( !bit_ceil_valid<maxpow2<unsigned short> + (unsigned short)1>() );
+static_assert( !bit_ceil_valid<max<unsigned short>>() );
+static_assert( !bit_ceil_valid<max<unsigned short> - (unsigned short)1>() );
+
+static_assert( bit_ceil_valid<maxpow2<unsigned int>>() );
+static_assert( !bit_ceil_valid<maxpow2<unsigned int> + 1u>() );
+static_assert( !bit_ceil_valid<max<unsigned int>>() );
+static_assert( !bit_ceil_valid<max<unsigned int> - 1u>() );
+
+static_assert( bit_ceil_valid<maxpow2<unsigned long>>() );
+static_assert( !bit_ceil_valid<maxpow2<unsigned long> + 1ul>() );
+static_assert( !bit_ceil_valid<max<unsigned long>>() );
+static_assert( !bit_ceil_valid<max<unsigned long> - 1ul>() );
+
+static_assert( bit_ceil_valid<maxpow2<unsigned long long>>() );
+static_assert( !bit_ceil_valid<maxpow2<unsigned long long> + 1ull>() );
+static_assert( !bit_ceil_valid<max<unsigned long long>>() );
+static_assert( !bit_ceil_valid<max<unsigned long long> - 1ull>() );
+
+void
+test01()
+{
+  std::bit_ceil( maxpow2<unsigned> + 1u ); // should fail __glibcxx_assert
+}
+
+int main()
+{
+  test01();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc	2020-02-19 17:37:12.939815816 +0100
@@ -0,0 +1,100 @@
+// Copyright (C) 2018-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <bit>
+#include <limits>
+
+template<typename UInt>
+constexpr auto
+test(UInt x)
+-> decltype(std::bit_floor(x))
+{
+  static_assert( noexcept(std::bit_floor(x)) );
+
+  static_assert( std::bit_floor(UInt(0)) == 0 );
+  static_assert( std::bit_floor(UInt(1)) == 1 );
+  static_assert( std::bit_floor(UInt(2)) == 2 );
+  static_assert( std::bit_floor(UInt(3)) == 2 );
+  static_assert( std::bit_floor(UInt(4)) == 4 );
+  static_assert( std::bit_floor(UInt(0x11)) == 0x10 );
+  static_assert( std::bit_floor(UInt(0x20)) == 0x20 );
+
+  if constexpr (std::numeric_limits<UInt>::digits > 8)
+  {
+    static_assert( std::bit_floor(UInt(0x201)) == 0x200 );
+    static_assert( std::bit_floor(UInt(0x8ff)) == 0x800 );
+    static_assert( std::bit_floor(UInt(0x1000)) == 0x1000 );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 32)
+  {
+    static_assert( std::bit_floor(UInt(0xabcdef)) == 0x800000 );
+    static_assert( std::bit_floor(UInt(0x1000000)) == 0x1000000 );
+    static_assert( std::bit_floor(UInt(0x1000001)) == 0x1000000 );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 64)
+  {
+    static_assert( std::bit_floor(UInt(1) << 64) == (UInt(1) << 64) );
+    static_assert( std::bit_floor(UInt(3) << 64) == (UInt(2) << 64) );
+  }
+
+  return true;
+}
+
+static_assert( test( (unsigned char)0 ) );
+static_assert( test( (unsigned short)0 ) );
+static_assert( test( (unsigned int)0 ) );
+static_assert( test( (unsigned long)0 ) );
+static_assert( test( (unsigned long long)0 ) );
+
+// std::bit_floor(T) shall not participate in overload resolution
+// unless T is an unsigned integer type.
+struct X { constexpr bool did_not_match() { return true; } };
+constexpr X test(...) { return X{}; }
+static_assert( test( (bool)0 ).did_not_match() );
+static_assert( test( (char)0 ).did_not_match() );
+static_assert( test( (int)0 ).did_not_match() );
+static_assert( test( (char16_t)0 ).did_not_match() );
+static_assert( test( (float)0 ).did_not_match() );
+static_assert( test( (void*)0 ).did_not_match() );
+static_assert( test( X{} ).did_not_match() );
+enum E : unsigned { e };
+static_assert( test( e ).did_not_match() );
+
+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
+static_assert( test( (unsigned __int128)0 ) );
+static_assert( test( (__int128)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_0)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_1)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_2)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
+#endif
+
+#include <cstddef>
+static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_width.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_width.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_width.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_width.cc	2020-02-19 17:37:12.939815816 +0100
@@ -0,0 +1,100 @@
+// Copyright (C) 2018-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <bit>
+#include <limits>
+
+template<typename UInt>
+constexpr auto
+test(UInt x)
+-> decltype(std::bit_width(x))
+{
+  static_assert( noexcept(std::bit_width(x)) );
+
+  static_assert( std::bit_width(UInt(0)) == 0 );
+  static_assert( std::bit_width(UInt(1)) == 1 );
+  static_assert( std::bit_width(UInt(2)) == 2 );
+  static_assert( std::bit_width(UInt(3)) == 2 );
+  static_assert( std::bit_width(UInt(4)) == 3 );
+  static_assert( std::bit_width(UInt(0x11)) == 5 );
+  static_assert( std::bit_width(UInt(0x20)) == 6 );
+
+  if constexpr (std::numeric_limits<UInt>::digits > 8)
+  {
+    static_assert( std::bit_width(UInt(0x201)) == 10 );
+    static_assert( std::bit_width(UInt(0x8ff)) == 12 );
+    static_assert( std::bit_width(UInt(0x1000)) == 13 );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 32)
+  {
+    static_assert( std::bit_width(UInt(0xabcdef)) == 24 );
+    static_assert( std::bit_width(UInt(0x1000000)) == 25 );
+    static_assert( std::bit_width(UInt(0x1000001)) == 25 );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 64)
+  {
+    static_assert( std::bit_width(UInt(1) << 64) == 65 );
+    static_assert( std::bit_width(UInt(3) << 64) == 66 );
+  }
+
+  return true;
+}
+
+static_assert( test( (unsigned char)0 ) );
+static_assert( test( (unsigned short)0 ) );
+static_assert( test( (unsigned int)0 ) );
+static_assert( test( (unsigned long)0 ) );
+static_assert( test( (unsigned long long)0 ) );
+
+// std::bit_width(T) shall not participate in overload resolution
+// unless T is an unsigned integer type.
+struct X { constexpr bool did_not_match() { return true; } };
+constexpr X test(...) { return X{}; }
+static_assert( test( (bool)0 ).did_not_match() );
+static_assert( test( (char)0 ).did_not_match() );
+static_assert( test( (int)0 ).did_not_match() );
+static_assert( test( (char16_t)0 ).did_not_match() );
+static_assert( test( (float)0 ).did_not_match() );
+static_assert( test( (void*)0 ).did_not_match() );
+static_assert( test( X{} ).did_not_match() );
+enum E : unsigned { e };
+static_assert( test( e ).did_not_match() );
+
+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
+static_assert( test( (unsigned __int128)0 ) );
+static_assert( test( (__int128)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_0)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_1)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_2)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
+#endif
+
+#include <cstddef>
+static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-// Copyright (C) 2018-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <bit>
-
-template<typename T>
-  constexpr T max = std::numeric_limits<T>::max();
-// Largest representable power of two (i.e. has most significant bit set)
-template<typename T>
-  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);
-
-// Detect whether std::ceil2(N) is a constant expression.
-template<auto N, typename = void>
-  struct ceil2_valid
-  : std::false_type { };
-
-template<auto N>
-  struct ceil2_valid<N, std::void_t<char[(std::ceil2(N), 1)]>>
-  : std::true_type { };
-
-template<typename UInt>
-constexpr auto
-test(UInt x)
--> decltype(std::ceil2(x))
-{
-  static_assert( noexcept(std::ceil2(x)) );
-
-  static_assert( std::ceil2(UInt(0)) == 1 );
-  static_assert( std::ceil2(UInt(1)) == 1 );
-  static_assert( std::ceil2(UInt(2)) == 2 );
-  static_assert( std::ceil2(UInt(3)) == 4 );
-  static_assert( std::ceil2(UInt(4)) == 4 );
-  static_assert( std::ceil2(UInt(0x11)) == 0x20 );
-  static_assert( std::ceil2(UInt(0x20)) == 0x20 );
-
-  if constexpr (std::numeric_limits<UInt>::digits > 8)
-  {
-    static_assert( std::ceil2(UInt(0x201)) == 0x400 );
-    static_assert( std::ceil2(UInt(0x8ff)) == 0x1000 );
-    static_assert( std::ceil2(UInt(0x1000)) == 0x1000 );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 32)
-  {
-    static_assert( std::ceil2(UInt(0xabcdef)) == 0x1000000 );
-    static_assert( std::ceil2(UInt(0x1000000)) == 0x1000000 );
-    static_assert( std::ceil2(UInt(0x1000001)) == 0x2000000 );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 64)
-  {
-    static_assert( std::ceil2(UInt(1) << 64) == (UInt(1) << 64) );
-    static_assert( std::ceil2(UInt(3) << 64) == (UInt(4) << 64) );
-  }
-
-  constexpr UInt msb = maxpow2<UInt>;
-  static_assert( ceil2_valid<msb>() );
-  static_assert( std::ceil2( msb ) == msb );
-  static_assert( std::ceil2( UInt(msb - 1) ) == msb );
-  static_assert( std::ceil2( UInt(msb - 2) ) == msb );
-  static_assert( std::ceil2( UInt(msb - 3) ) == msb );
-
-  // P1355R2: not a constant expression if the result is not representable
-  static_assert( !ceil2_valid<UInt(msb + 1)>() );
-  static_assert( !ceil2_valid<max<UInt>>() );
-  static_assert( !ceil2_valid<UInt(max<UInt> - 1)>() );
-  static_assert( !ceil2_valid<UInt(max<UInt> - 2)>() );
-
-  return true;
-}
-
-static_assert( test( (unsigned char)0 ) );
-static_assert( test( (unsigned short)0 ) );
-static_assert( test( (unsigned int)0 ) );
-static_assert( test( (unsigned long)0 ) );
-static_assert( test( (unsigned long long)0 ) );
-
-// std::ceil2(T) shall not participate in overload resolution
-// unless T is an unsigned integer type.
-struct X { constexpr bool did_not_match() { return true; } };
-constexpr X test(...) { return X{}; }
-static_assert( test( (bool)0 ).did_not_match() );
-static_assert( test( (char)0 ).did_not_match() );
-static_assert( test( (int)0 ).did_not_match() );
-static_assert( test( (char16_t)0 ).did_not_match() );
-static_assert( test( (float)0 ).did_not_match() );
-static_assert( test( (void*)0 ).did_not_match() );
-static_assert( test( X{} ).did_not_match() );
-enum E : unsigned { e };
-static_assert( test( e ).did_not_match() );
-
-#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
-static_assert( test( (unsigned __int128)0 ) );
-static_assert( test( (__int128)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_0)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_1)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_2)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_3)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_3)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_3)0 ).did_not_match() );
-#endif
-
-#include <cstddef>
-static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-// Copyright (C) 2019-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a -D_GLIBCXX_ASSERTIONS" }
-// { dg-do run { target c++2a } }
-// { dg-xfail-run-if "__glibcxx_assert in ceil2 should fail" { *-*-* } }
-
-#include <bit>
-
-// P1355R2: not a constant expression if the result is not representable
-
-template<auto N, typename = void>
-  struct ceil2_valid
-  : std::false_type { };
-
-template<auto N>
-  struct ceil2_valid<N, std::void_t<char[(std::ceil2(N), 1)]>>
-  : std::true_type { };
-
-template<typename T>
-  constexpr T max = std::numeric_limits<T>::max();
-template<typename T>
-  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);
-
-static_assert( ceil2_valid<maxpow2<unsigned char>>() );
-static_assert( !ceil2_valid<maxpow2<unsigned char> + (unsigned char)1>() );
-
-static_assert( !ceil2_valid<max<unsigned char>>() );
-static_assert( !ceil2_valid<max<unsigned char> - (unsigned char)1>() );
-
-static_assert( ceil2_valid<maxpow2<unsigned short>>() );
-static_assert( !ceil2_valid<maxpow2<unsigned short> + (unsigned short)1>() );
-static_assert( !ceil2_valid<max<unsigned short>>() );
-static_assert( !ceil2_valid<max<unsigned short> - (unsigned short)1>() );
-
-static_assert( ceil2_valid<maxpow2<unsigned int>>() );
-static_assert( !ceil2_valid<maxpow2<unsigned int> + 1u>() );
-static_assert( !ceil2_valid<max<unsigned int>>() );
-static_assert( !ceil2_valid<max<unsigned int> - 1u>() );
-
-static_assert( ceil2_valid<maxpow2<unsigned long>>() );
-static_assert( !ceil2_valid<maxpow2<unsigned long> + 1ul>() );
-static_assert( !ceil2_valid<max<unsigned long>>() );
-static_assert( !ceil2_valid<max<unsigned long> - 1ul>() );
-
-static_assert( ceil2_valid<maxpow2<unsigned long long>>() );
-static_assert( !ceil2_valid<maxpow2<unsigned long long> + 1ull>() );
-static_assert( !ceil2_valid<max<unsigned long long>>() );
-static_assert( !ceil2_valid<max<unsigned long long> - 1ull>() );
-
-void
-test01()
-{
-  std::ceil2( maxpow2<unsigned> + 1u ); // should fail __glibcxx_assert
-}
-
-int main()
-{
-  test01();
-}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/floor2.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/floor2.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/floor2.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/floor2.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-// Copyright (C) 2018-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <bit>
-
-template<typename UInt>
-constexpr auto
-test(UInt x)
--> decltype(std::floor2(x))
-{
-  static_assert( noexcept(std::floor2(x)) );
-
-  static_assert( std::floor2(UInt(0)) == 0 );
-  static_assert( std::floor2(UInt(1)) == 1 );
-  static_assert( std::floor2(UInt(2)) == 2 );
-  static_assert( std::floor2(UInt(3)) == 2 );
-  static_assert( std::floor2(UInt(4)) == 4 );
-  static_assert( std::floor2(UInt(0x11)) == 0x10 );
-  static_assert( std::floor2(UInt(0x20)) == 0x20 );
-
-  if constexpr (std::numeric_limits<UInt>::digits > 8)
-  {
-    static_assert( std::floor2(UInt(0x201)) == 0x200 );
-    static_assert( std::floor2(UInt(0x8ff)) == 0x800 );
-    static_assert( std::floor2(UInt(0x1000)) == 0x1000 );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 32)
-  {
-    static_assert( std::floor2(UInt(0xabcdef)) == 0x800000 );
-    static_assert( std::floor2(UInt(0x1000000)) == 0x1000000 );
-    static_assert( std::floor2(UInt(0x1000001)) == 0x1000000 );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 64)
-  {
-    static_assert( std::floor2(UInt(1) << 64) == (UInt(1) << 64) );
-    static_assert( std::floor2(UInt(3) << 64) == (UInt(2) << 64) );
-  }
-
-  return true;
-}
-
-static_assert( test( (unsigned char)0 ) );
-static_assert( test( (unsigned short)0 ) );
-static_assert( test( (unsigned int)0 ) );
-static_assert( test( (unsigned long)0 ) );
-static_assert( test( (unsigned long long)0 ) );
-
-// std::floor2(T) shall not participate in overload resolution
-// unless T is an unsigned integer type.
-struct X { constexpr bool did_not_match() { return true; } };
-constexpr X test(...) { return X{}; }
-static_assert( test( (bool)0 ).did_not_match() );
-static_assert( test( (char)0 ).did_not_match() );
-static_assert( test( (int)0 ).did_not_match() );
-static_assert( test( (char16_t)0 ).did_not_match() );
-static_assert( test( (float)0 ).did_not_match() );
-static_assert( test( (void*)0 ).did_not_match() );
-static_assert( test( X{} ).did_not_match() );
-enum E : unsigned { e };
-static_assert( test( e ).did_not_match() );
-
-#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
-static_assert( test( (unsigned __int128)0 ) );
-static_assert( test( (__int128)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_0)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_1)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_2)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
-#endif
-
-#include <cstddef>
-static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc	2020-02-19 17:37:12.939815816 +0100
@@ -0,0 +1,148 @@
+// Copyright (C) 2018-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <bit>
+#include <limits>
+
+template<typename UInt>
+constexpr auto
+test(UInt x)
+-> decltype(std::has_single_bit(x))
+{
+  static_assert( noexcept(std::has_single_bit(x)) );
+
+  static_assert( ! std::has_single_bit( (UInt)0 ) );
+  static_assert( ! std::has_single_bit( (UInt)-1 ) );
+  static_assert( ! std::has_single_bit( (UInt)3 ) );
+  static_assert( ! std::has_single_bit( (UInt)0x0f ) );
+  static_assert( ! std::has_single_bit( (UInt)0xff ) );
+  static_assert( ! std::has_single_bit( (UInt)0x0a ) );
+  static_assert( ! std::has_single_bit( (UInt)0xa0 ) );
+
+  constexpr UInt one = 1;
+  static_assert( std::has_single_bit( (UInt)(one << 0) ) );
+
+  static_assert( std::has_single_bit( (UInt)(one << 1) ) );
+  static_assert( std::has_single_bit( (UInt)(one << 2) ) );
+  static_assert( std::has_single_bit( (UInt)(one << 3) ) );
+  static_assert( std::has_single_bit( (UInt)(one << 4) ) );
+  static_assert( std::has_single_bit( (UInt)(one << 5) ) );
+  static_assert( std::has_single_bit( (UInt)(one << 6) ) );
+  static_assert( std::has_single_bit( (UInt)(one << 7) ) );
+
+  if constexpr (std::numeric_limits<UInt>::digits > 8)
+  {
+    static_assert( std::has_single_bit( (UInt)(one << 8) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 9) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 10) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 11) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 12) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 13) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 14) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 15) ) );
+
+    static_assert( ! std::has_single_bit( (UInt)0xf000 ) );
+    static_assert( ! std::has_single_bit( (UInt)0xff00 ) );
+    static_assert( ! std::has_single_bit( (UInt)0xf0f0 ) );
+    static_assert( ! std::has_single_bit( (UInt)0xf00f ) );
+    static_assert( ! std::has_single_bit( (UInt)0x0f0f ) );
+    static_assert( ! std::has_single_bit( (UInt)0x00ff ) );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 16)
+  {
+    static_assert( std::has_single_bit( (UInt)(one << 16) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 17) ) );
+    static_assert( ! std::has_single_bit( (UInt)((one << 16) + 1) ) );
+    static_assert( ! std::has_single_bit( (UInt)((one << 16) + 0x10) ) );
+  }
+
+  // msp340 target has 20-bit __GLIBCXX_TYPE_INT_N_0 type
+  if constexpr (std::numeric_limits<UInt>::digits > 20)
+  {
+    static_assert( std::has_single_bit( (UInt)(one << 20) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 21) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 24) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 28) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 31) ) );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits > 32)
+  {
+    static_assert( std::has_single_bit( (UInt)(one << 32) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 33) ) );
+    static_assert( std::has_single_bit( (UInt)(one << 41) ) );
+
+    static_assert( ! std::has_single_bit( (UInt)((one << 32) + 1) ) );
+    static_assert( ! std::has_single_bit( (UInt)((one << 32) + (one << 31)) ) );
+    static_assert( ! std::has_single_bit( (UInt)((one << 33) + 1) ) );
+    static_assert( ! std::has_single_bit( (UInt)((one << 33) + (one << 32)) ) );
+  }
+
+  if constexpr (std::numeric_limits<UInt>::digits == 64)
+  {
+    static_assert( std::has_single_bit( (UInt)(one << 63) ) );
+
+    static_assert( ! std::has_single_bit( (UInt)((one << 63) + 1) ) );
+    static_assert( ! std::has_single_bit( (UInt)((one << 63) + (one << 8)) ) );
+    static_assert( ! std::has_single_bit( (UInt)((one << 63) + (one << 32)) ) );
+  }
+  return true;
+}
+
+static_assert( test( (unsigned char)0 ) );
+static_assert( test( (unsigned short)0 ) );
+static_assert( test( (unsigned int)0 ) );
+static_assert( test( (unsigned long)0 ) );
+static_assert( test( (unsigned long long)0 ) );
+
+// std::has_single_bit(T) shall not participate in overload resolution
+// unless T is an unsigned integer type.
+struct X { constexpr bool did_not_match() { return true; } };
+constexpr X test(...) { return X{}; }
+static_assert( test( (bool)0 ).did_not_match() );
+static_assert( test( (char)0 ).did_not_match() );
+static_assert( test( (int)0 ).did_not_match() );
+static_assert( test( (char16_t)0 ).did_not_match() );
+static_assert( test( (float)0 ).did_not_match() );
+static_assert( test( (void*)0 ).did_not_match() );
+static_assert( test( X{} ).did_not_match() );
+enum E : unsigned { e };
+static_assert( test( e ).did_not_match() );
+
+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
+static_assert( test( (unsigned __int128)0 ) );
+static_assert( test( (__int128)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_0)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_1)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
+#endif
+#if defined(__GLIBCXX_TYPE_INT_N_2)
+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
+#endif
+
+#include <cstddef>
+static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ispow2.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ispow2.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ispow2.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ispow2.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,147 +0,0 @@
-// Copyright (C) 2018-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <bit>
-
-template<typename UInt>
-constexpr auto
-test(UInt x)
--> decltype(std::ispow2(x))
-{
-  static_assert( noexcept(std::ispow2(x)) );
-
-  static_assert( ! std::ispow2( (UInt)0 ) );
-  static_assert( ! std::ispow2( (UInt)-1 ) );
-  static_assert( ! std::ispow2( (UInt)3 ) );
-  static_assert( ! std::ispow2( (UInt)0x0f ) );
-  static_assert( ! std::ispow2( (UInt)0xff ) );
-  static_assert( ! std::ispow2( (UInt)0x0a ) );
-  static_assert( ! std::ispow2( (UInt)0xa0 ) );
-
-  constexpr UInt one = 1;
-  static_assert( std::ispow2( (UInt)(one << 0) ) );
-
-  static_assert( std::ispow2( (UInt)(one << 1) ) );
-  static_assert( std::ispow2( (UInt)(one << 2) ) );
-  static_assert( std::ispow2( (UInt)(one << 3) ) );
-  static_assert( std::ispow2( (UInt)(one << 4) ) );
-  static_assert( std::ispow2( (UInt)(one << 5) ) );
-  static_assert( std::ispow2( (UInt)(one << 6) ) );
-  static_assert( std::ispow2( (UInt)(one << 7) ) );
-
-  if constexpr (std::numeric_limits<UInt>::digits > 8)
-  {
-    static_assert( std::ispow2( (UInt)(one << 8) ) );
-    static_assert( std::ispow2( (UInt)(one << 9) ) );
-    static_assert( std::ispow2( (UInt)(one << 10) ) );
-    static_assert( std::ispow2( (UInt)(one << 11) ) );
-    static_assert( std::ispow2( (UInt)(one << 12) ) );
-    static_assert( std::ispow2( (UInt)(one << 13) ) );
-    static_assert( std::ispow2( (UInt)(one << 14) ) );
-    static_assert( std::ispow2( (UInt)(one << 15) ) );
-
-    static_assert( ! std::ispow2( (UInt)0xf000 ) );
-    static_assert( ! std::ispow2( (UInt)0xff00 ) );
-    static_assert( ! std::ispow2( (UInt)0xf0f0 ) );
-    static_assert( ! std::ispow2( (UInt)0xf00f ) );
-    static_assert( ! std::ispow2( (UInt)0x0f0f ) );
-    static_assert( ! std::ispow2( (UInt)0x00ff ) );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 16)
-  {
-    static_assert( std::ispow2( (UInt)(one << 16) ) );
-    static_assert( std::ispow2( (UInt)(one << 17) ) );
-    static_assert( ! std::ispow2( (UInt)((one << 16) + 1) ) );
-    static_assert( ! std::ispow2( (UInt)((one << 16) + 0x10) ) );
-  }
-
-  // msp340 target has 20-bit __GLIBCXX_TYPE_INT_N_0 type
-  if constexpr (std::numeric_limits<UInt>::digits > 20)
-  {
-    static_assert( std::ispow2( (UInt)(one << 20) ) );
-    static_assert( std::ispow2( (UInt)(one << 21) ) );
-    static_assert( std::ispow2( (UInt)(one << 24) ) );
-    static_assert( std::ispow2( (UInt)(one << 28) ) );
-    static_assert( std::ispow2( (UInt)(one << 31) ) );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 32)
-  {
-    static_assert( std::ispow2( (UInt)(one << 32) ) );
-    static_assert( std::ispow2( (UInt)(one << 33) ) );
-    static_assert( std::ispow2( (UInt)(one << 41) ) );
-
-    static_assert( ! std::ispow2( (UInt)((one << 32) + 1) ) );
-    static_assert( ! std::ispow2( (UInt)((one << 32) + (one << 31)) ) );
-    static_assert( ! std::ispow2( (UInt)((one << 33) + 1) ) );
-    static_assert( ! std::ispow2( (UInt)((one << 33) + (one << 32)) ) );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits == 64)
-  {
-    static_assert( std::ispow2( (UInt)(one << 63) ) );
-
-    static_assert( ! std::ispow2( (UInt)((one << 63) + 1) ) );
-    static_assert( ! std::ispow2( (UInt)((one << 63) + (one << 8)) ) );
-    static_assert( ! std::ispow2( (UInt)((one << 63) + (one << 32)) ) );
-  }
-  return true;
-}
-
-static_assert( test( (unsigned char)0 ) );
-static_assert( test( (unsigned short)0 ) );
-static_assert( test( (unsigned int)0 ) );
-static_assert( test( (unsigned long)0 ) );
-static_assert( test( (unsigned long long)0 ) );
-
-// std::ispow2(T) shall not participate in overload resolution
-// unless T is an unsigned integer type.
-struct X { constexpr bool did_not_match() { return true; } };
-constexpr X test(...) { return X{}; }
-static_assert( test( (bool)0 ).did_not_match() );
-static_assert( test( (char)0 ).did_not_match() );
-static_assert( test( (int)0 ).did_not_match() );
-static_assert( test( (char16_t)0 ).did_not_match() );
-static_assert( test( (float)0 ).did_not_match() );
-static_assert( test( (void*)0 ).did_not_match() );
-static_assert( test( X{} ).did_not_match() );
-enum E : unsigned { e };
-static_assert( test( e ).did_not_match() );
-
-#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
-static_assert( test( (unsigned __int128)0 ) );
-static_assert( test( (__int128)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_0)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_1)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_2)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
-#endif
-
-#include <cstddef>
-static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/log2p1.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/log2p1.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/log2p1.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/log2p1.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-// Copyright (C) 2018-2020 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
-
-#include <bit>
-
-template<typename UInt>
-constexpr auto
-test(UInt x)
--> decltype(std::log2p1(x))
-{
-  static_assert( noexcept(std::log2p1(x)) );
-
-  static_assert( std::log2p1(UInt(0)) == 0 );
-  static_assert( std::log2p1(UInt(1)) == 1 );
-  static_assert( std::log2p1(UInt(2)) == 2 );
-  static_assert( std::log2p1(UInt(3)) == 2 );
-  static_assert( std::log2p1(UInt(4)) == 3 );
-  static_assert( std::log2p1(UInt(0x11)) == 5 );
-  static_assert( std::log2p1(UInt(0x20)) == 6 );
-
-  if constexpr (std::numeric_limits<UInt>::digits > 8)
-  {
-    static_assert( std::log2p1(UInt(0x201)) == 10 );
-    static_assert( std::log2p1(UInt(0x8ff)) == 12 );
-    static_assert( std::log2p1(UInt(0x1000)) == 13 );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 32)
-  {
-    static_assert( std::log2p1(UInt(0xabcdef)) == 24 );
-    static_assert( std::log2p1(UInt(0x1000000)) == 25 );
-    static_assert( std::log2p1(UInt(0x1000001)) == 25 );
-  }
-
-  if constexpr (std::numeric_limits<UInt>::digits > 64)
-  {
-    static_assert( std::log2p1(UInt(1) << 64) == 65 );
-    static_assert( std::log2p1(UInt(3) << 64) == 66 );
-  }
-
-  return true;
-}
-
-static_assert( test( (unsigned char)0 ) );
-static_assert( test( (unsigned short)0 ) );
-static_assert( test( (unsigned int)0 ) );
-static_assert( test( (unsigned long)0 ) );
-static_assert( test( (unsigned long long)0 ) );
-
-// std::log2p1(T) shall not participate in overload resolution
-// unless T is an unsigned integer type.
-struct X { constexpr bool did_not_match() { return true; } };
-constexpr X test(...) { return X{}; }
-static_assert( test( (bool)0 ).did_not_match() );
-static_assert( test( (char)0 ).did_not_match() );
-static_assert( test( (int)0 ).did_not_match() );
-static_assert( test( (char16_t)0 ).did_not_match() );
-static_assert( test( (float)0 ).did_not_match() );
-static_assert( test( (void*)0 ).did_not_match() );
-static_assert( test( X{} ).did_not_match() );
-enum E : unsigned { e };
-static_assert( test( e ).did_not_match() );
-
-#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128
-static_assert( test( (unsigned __int128)0 ) );
-static_assert( test( (__int128)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_0)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_1)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );
-#endif
-#if defined(__GLIBCXX_TYPE_INT_N_2)
-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );
-static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );
-#endif
-
-#include <cstddef>
-static_assert( test( (std::byte)0 ).did_not_match() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotl.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotl.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotl.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotl.cc	2020-02-19 17:37:12.939815816 +0100
@@ -19,6 +19,7 @@
 // { dg-do compile { target c++2a } }
 
 #include <bit>
+#include <limits>
 
 template<typename UInt>
 constexpr bool
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotr.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotr.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotr.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/bit/bit.rotate/rotr.cc	2020-02-19 17:37:12.939815816 +0100
@@ -19,6 +19,7 @@
 // { dg-do compile { target c++2a } }
 
 #include <bit>
+#include <limits>
 
 template<typename UInt>
 constexpr bool
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/midpoint/pointer.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/midpoint/pointer.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/midpoint/pointer.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/midpoint/pointer.cc	2020-02-19 17:37:12.942815816 +0100
@@ -19,7 +19,6 @@
 // { dg-do run { target c++2a } }
 
 #include <numeric>
-#include <climits>
 #include <testsuite_hooks.h>
 
 const int* p = nullptr;
@@ -36,7 +35,6 @@
 static_assert(no_midpoint<void>());
 static_assert(no_midpoint<int()>());
 static_assert(no_midpoint<int&>());
-static_assert(no_midpoint<struct Incomplete>());
 
 constexpr int ca[3] = {};
 static_assert( std::midpoint(ca, ca+3) == ca+1 );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/midpoint/pointer_neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/midpoint/pointer_neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/midpoint/pointer_neg.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/midpoint/pointer_neg.cc	2020-02-19 17:37:12.942815816 +0100
@@ -0,0 +1,27 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <numeric>
+
+// LWG 3200. midpoint should not constrain T is complete
+struct Incomplete* pinc = 0;
+auto p1 = std::midpoint(pinc, pinc); // { dg-error "here" }
+
+// { dg-error "incomplete type" "" { target *-*-* } 0 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	2020-02-16 23:32:15.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	2020-02-19 17:37:12.948815817 +0100
@@ -10,6 +10,6 @@
 auto x = std::generate_canonical<std::size_t,
 			std::numeric_limits<std::size_t>::digits>(urng);
 
-// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 172 }
+// { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 158 }
 
 // { dg-error "static assertion failed: template argument must be a floating point type" "" { target *-*-* } 3281 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/begin.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/begin.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/begin.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/begin.cc	2020-02-19 17:37:13.047815821 +0100
@@ -85,7 +85,7 @@
 };
 
 // Allow ranges::begin to work with RV&&
-template<> constexpr bool std::ranges::enable_safe_range<RV> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RV> = true;
 
 void
 test03()
@@ -102,7 +102,7 @@
   VERIFY( std::ranges::begin(c) == begin(c) );
 
   RV v{r};
-  // enable_safe_range<RV> allows ranges::begin to work for rvalues,
+  // enable_borrowed_range<RV> allows ranges::begin to work for rvalues,
   // but it will call v.begin() or begin(v) on an lvalue:
   static_assert(same_as<decltype(std::ranges::begin(std::move(v))),
 		decltype(begin(v))>);
@@ -132,7 +132,7 @@
 };
 
 // N.B. this is a lie, begin on an RR rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<RR> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RR> = true;
 
 void
 test04()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/cbegin.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/cbegin.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/cbegin.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/cbegin.cc	2020-02-19 17:37:13.047815821 +0100
@@ -54,7 +54,7 @@
 };
 
 // Allow ranges::begin to work with RV&&
-template<> constexpr bool std::ranges::enable_safe_range<RV> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RV> = true;
 
 void
 test03()
@@ -86,7 +86,7 @@
 };
 
 // N.B. this is a lie, cbegin on an RR rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<RR> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RR> = true;
 
 void
 test04()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/cdata.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/cdata.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/cdata.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/cdata.cc	2020-02-19 17:37:13.047815821 +0100
@@ -57,7 +57,7 @@
 };
 
 // This is a lie, ranges::begin(R&&) returns a dangling iterator.
-template<> constexpr bool std::ranges::enable_safe_range<R> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R> = true;
 
 void
 test03()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/cend.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/cend.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/cend.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/cend.cc	2020-02-19 17:37:13.047815821 +0100
@@ -60,7 +60,7 @@
 };
 
 // Allow ranges::end to work with RV&&
-template<> constexpr bool std::ranges::enable_safe_range<RV> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RV> = true;
 
 void
 test03()
@@ -98,7 +98,7 @@
 };
 
 // N.B. this is a lie, begin/end on an RR rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<RR> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RR> = true;
 
 void
 test04()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/crbegin.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/crbegin.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/crbegin.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/crbegin.cc	2020-02-19 17:37:13.047815821 +0100
@@ -40,7 +40,7 @@
 };
 
 // Allow ranges::end to work with R1V&&
-template<> constexpr bool std::ranges::enable_safe_range<R1V> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R1V> = true;
 
 void
 test01()
@@ -69,7 +69,7 @@
 };
 
 // N.B. this is a lie, rbegin on an R2 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R2> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R2> = true;
 
 void
 test02()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/crend.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/crend.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/crend.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/crend.cc	2020-02-19 17:37:13.047815821 +0100
@@ -34,7 +34,7 @@
 };
 
 // N.B. this is a lie, rend on an R1 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R1> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R1> = true;
 
 void
 test01()
@@ -60,7 +60,7 @@
 };
 
 // N.B. this is a lie, rend on an R2 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R2> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R2> = true;
 
 void
 test02()
@@ -85,7 +85,7 @@
 };
 
 // N.B. this is a lie, rend on an R3 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R3> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R3> = true;
 
 void
 test03()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/data.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/data.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/data.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/data.cc	2020-02-19 17:37:13.047815821 +0100
@@ -61,7 +61,7 @@
 };
 
 // N.B. this is a lie, begin on an R3 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R3> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R3> = true;
 
 void
 test03()
@@ -69,7 +69,7 @@
   R3 r;
   const R3& c = r;
   // r.data() can only be used on an lvalue, but ranges::begin(R3&&) is OK
-  // because R3 satisfies ranges::safe_range.
+  // because R3 satisfies ranges::borrowed_range.
   VERIFY( std::ranges::data(std::move(r)) == std::to_address(std::ranges::begin(std::move(r))) );
   VERIFY( std::ranges::data(std::move(c)) == std::to_address(std::ranges::begin(std::move(c))) );
 }
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/end.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/end.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/end.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/end.cc	2020-02-19 17:37:13.047815821 +0100
@@ -90,7 +90,7 @@
 };
 
 // Allow ranges::begin to work with RV&&
-template<> constexpr bool std::ranges::enable_safe_range<RV> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RV> = true;
 
 void
 test03()
@@ -146,7 +146,7 @@
 };
 
 // N.B. this is a lie, end on an RR rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<RR> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<RR> = true;
 
 void
 test04()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/rbegin.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/rbegin.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/rbegin.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/rbegin.cc	2020-02-19 17:37:13.047815821 +0100
@@ -32,7 +32,7 @@
 };
 
 // N.B. this is a lie, rbegin on an R1 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R1> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R1> = true;
 
 void
 test01()
@@ -56,7 +56,7 @@
 };
 
 // N.B. this is a lie, begin/end on an R2 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R2> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R2> = true;
 
 void
 test02()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/rend.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/rend.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/rend.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/rend.cc	2020-02-19 17:37:13.047815821 +0100
@@ -34,7 +34,7 @@
 };
 
 // N.B. this is a lie, rend on an R1 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R1> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R1> = true;
 
 void
 test01()
@@ -87,7 +87,7 @@
 };
 
 // N.B. this is a lie, begin/end on an R3 rvalue will return a dangling pointer.
-template<> constexpr bool std::ranges::enable_safe_range<R3> = true;
+template<> constexpr bool std::ranges::enable_borrowed_range<R3> = true;
 
 void
 test03()
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/ssize.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/ssize.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/access/ssize.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/access/ssize.cc	2020-02-19 17:37:13.047815821 +0100
@@ -0,0 +1,98 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <ranges>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+using std::ptrdiff_t;
+
+void
+test01()
+{
+  constexpr int a[10] = { };
+  static_assert( std::same_as<decltype(std::ranges::ssize(a)), ptrdiff_t> );
+  static_assert( std::ranges::ssize(a) == 10 );
+  static_assert( noexcept(std::ranges::ssize(a)) );
+
+  int a2[2];
+  static_assert( std::same_as<decltype(std::ranges::ssize(a2)), ptrdiff_t> );
+  VERIFY( std::ranges::ssize(a2) == 2);
+  static_assert( noexcept(std::ranges::ssize(a2)) );
+
+  struct Incomplete;
+  using A = Incomplete[2]; // bounded array of incomplete type
+  extern A& f();
+  static_assert( std::same_as<decltype(std::ranges::ssize(f())), ptrdiff_t> );
+}
+
+void
+test02()
+{
+  int a[3] = { };
+  __gnu_test::test_sized_range<int, __gnu_test::input_iterator_wrapper> ri(a);
+  VERIFY( std::ranges::ssize(ri) == 3 );
+  static_assert( noexcept(std::ranges::ssize(ri)) );
+}
+
+void
+test04()
+{
+  int a[] = { 0, 1 };
+  __gnu_test::test_range<int, __gnu_test::random_access_iterator_wrapper> r(a);
+  VERIFY( std::ranges::ssize(r) == std::ranges::end(r) - std::ranges::begin(r) );
+}
+
+struct R5
+{
+  int size() const noexcept { return 0; }
+  R5* begin() { return this; }
+  R5* end() { return this + 1; }
+};
+
+template<>
+constexpr bool std::ranges::disable_sized_range<R5> = true;
+
+void
+test05()
+{
+  R5 r;
+  VERIFY( std::ranges::ssize(r) == 1 );
+}
+
+void
+test06()
+{
+  auto i = std::views::iota(1ull, 5);
+  auto s = std::ranges::ssize(i);
+  using R = std::ranges::range_difference_t<decltype(i)>;
+  static_assert( std::same_as<decltype(s), R> );
+  VERIFY( s == 4 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test04();
+  test05();
+  test06();
+}
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc	2020-02-19 17:37:13.047815821 +0100
@@ -43,9 +43,11 @@
   static_assert(!ranges::sized_range<R>);
   static_assert(ranges::bidirectional_range<R>);
   static_assert(!ranges::random_access_range<R>);
-  static_assert(ranges::range<ranges::all_view<R>>);
+  static_assert(ranges::range<views::all_t<R>>);
   VERIFY( ranges::equal(v, (int[]){1,3,5}) );
   VERIFY( ranges::equal(v | views::reverse, (int[]){5,3,1}) );
+  VERIFY( v.pred()(3) == true );
+  VERIFY( v.pred()(4) == false );
 }
 
 void
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/safe_range.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/safe_range.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/safe_range.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/safe_range.cc	2020-02-19 17:37:13.048815821 +0100
@@ -21,21 +21,21 @@
 #include <ranges>
 #include <testsuite_iterators.h>
 
-static_assert( std::ranges::safe_range<int(&)[1]> );
-static_assert( std::ranges::safe_range<const int(&)[1]> );
-static_assert( !std::ranges::safe_range<int[1]> );
-static_assert( !std::ranges::safe_range<int*> );
+static_assert( std::ranges::borrowed_range<int(&)[1]> );
+static_assert( std::ranges::borrowed_range<const int(&)[1]> );
+static_assert( !std::ranges::borrowed_range<int[1]> );
+static_assert( !std::ranges::borrowed_range<int*> );
 
 using __gnu_test::test_contiguous_range;
 
-static_assert( !std::ranges::safe_range<test_contiguous_range<int>> );
-static_assert( std::ranges::safe_range<test_contiguous_range<int>&> );
-static_assert( !std::ranges::safe_range<test_contiguous_range<int>&&> );
+static_assert( !std::ranges::borrowed_range<test_contiguous_range<int>> );
+static_assert( std::ranges::borrowed_range<test_contiguous_range<int>&> );
+static_assert( !std::ranges::borrowed_range<test_contiguous_range<int>&&> );
 
 template<>
 constexpr bool
-  std::ranges::enable_safe_range<test_contiguous_range<long>> = true;
+  std::ranges::enable_borrowed_range<test_contiguous_range<long>> = true;
 
-static_assert( std::ranges::safe_range<test_contiguous_range<long>> );
-static_assert( std::ranges::safe_range<test_contiguous_range<long>&> );
-static_assert( std::ranges::safe_range<test_contiguous_range<long>&&> );
+static_assert( std::ranges::borrowed_range<test_contiguous_range<long>> );
+static_assert( std::ranges::borrowed_range<test_contiguous_range<long>&> );
+static_assert( std::ranges::borrowed_range<test_contiguous_range<long>&&> );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/safe_range_types.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/safe_range_types.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/safe_range_types.cc	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/safe_range_types.cc	2020-02-19 17:37:13.048815821 +0100
@@ -25,35 +25,35 @@
 
 template<typename T>
 constexpr bool
-rvalue_is_safe_range()
+rvalue_is_borrowed_range()
 {
-  using std::ranges::safe_range;
+  using std::ranges::borrowed_range;
 
-  // An lvalue range always models safe_range
-  static_assert( safe_range<T&> );
-  static_assert( safe_range<const T&> );
+  // An lvalue range always models borrowed_range
+  static_assert( borrowed_range<T&> );
+  static_assert( borrowed_range<const T&> );
 
   // Result should not depend on addition of const or rvalue-reference.
-  static_assert( safe_range<T&&> == safe_range<T> );
-  static_assert( safe_range<const T> == safe_range<T> );
-  static_assert( safe_range<const T&&> == safe_range<T> );
+  static_assert( borrowed_range<T&&> == borrowed_range<T> );
+  static_assert( borrowed_range<const T> == borrowed_range<T> );
+  static_assert( borrowed_range<const T&&> == borrowed_range<T> );
 
-  return std::ranges::safe_range<T>;
+  return std::ranges::borrowed_range<T>;
 }
 
-static_assert( rvalue_is_safe_range<std::ranges::subrange<int*, int*>>() );
-static_assert( rvalue_is_safe_range<std::ranges::empty_view<int>>() );
-static_assert( rvalue_is_safe_range<std::ranges::iota_view<int>>() );
-static_assert( rvalue_is_safe_range<std::ranges::iota_view<int, int>>() );
-
-static_assert( rvalue_is_safe_range<std::span<int>>() );
-static_assert( rvalue_is_safe_range<std::span<int, 99>>() );
+static_assert( rvalue_is_borrowed_range<std::ranges::subrange<int*, int*>>() );
+static_assert( rvalue_is_borrowed_range<std::ranges::empty_view<int>>() );
+static_assert( rvalue_is_borrowed_range<std::ranges::iota_view<int>>() );
+static_assert( rvalue_is_borrowed_range<std::ranges::iota_view<int, int>>() );
+
+static_assert( rvalue_is_borrowed_range<std::span<int>>() );
+static_assert( rvalue_is_borrowed_range<std::span<int, 99>>() );
 
-static_assert( ! rvalue_is_safe_range<std::string>() );
-static_assert( ! rvalue_is_safe_range<std::wstring>() );
+static_assert( ! rvalue_is_borrowed_range<std::string>() );
+static_assert( ! rvalue_is_borrowed_range<std::wstring>() );
 
-static_assert( rvalue_is_safe_range<std::string_view>() );
-static_assert( rvalue_is_safe_range<std::wstring_view>() );
+static_assert( rvalue_is_borrowed_range<std::string_view>() );
+static_assert( rvalue_is_borrowed_range<std::wstring_view>() );
 
-static_assert( rvalue_is_safe_range<std::experimental::string_view>() );
-static_assert( rvalue_is_safe_range<std::experimental::wstring_view>() );
+static_assert( rvalue_is_borrowed_range<std::experimental::string_view>() );
+static_assert( rvalue_is_borrowed_range<std::experimental::wstring_view>() );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/subrange/tuple_like.cc /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/subrange/tuple_like.cc
--- gcc-10-20200216/libstdc++-v3/testsuite/std/ranges/subrange/tuple_like.cc	1970-01-01 01:00:00.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/std/ranges/subrange/tuple_like.cc	2020-02-19 17:37:13.048815821 +0100
@@ -0,0 +1,52 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <ranges>
+
+using S1 = std::ranges::subrange<int*>;
+using S2 = std::ranges::subrange<long*, void*>;
+
+static_assert( std::tuple_size_v<S1> == 2 );
+static_assert( std::tuple_size_v<S2> == 2 );
+
+static_assert( std::same_as<std::tuple_element_t<0, S1>, int*> );
+static_assert( std::same_as<std::tuple_element_t<1, S1>, int*> );
+// LWG 3398
+static_assert( std::same_as<std::tuple_element_t<0, const S1>, int*> );
+static_assert( std::same_as<std::tuple_element_t<1, const S1>, int*> );
+
+static_assert( std::same_as<std::tuple_element_t<0, S2>, long*> );
+static_assert( std::same_as<std::tuple_element_t<1, S2>, void*> );
+// LWG 3398
+static_assert( std::same_as<std::tuple_element_t<0, const S2>, long*> );
+static_assert( std::same_as<std::tuple_element_t<1, const S2>, void*> );
+
+S1 s1;
+static_assert( std::same_as<decltype(std::get<0>(s1)), int*> );
+static_assert( std::same_as<decltype(std::get<1>(s1)), int*> );
+const S1 c1;
+static_assert( std::same_as<decltype(std::get<0>(c1)), int*> );
+static_assert( std::same_as<decltype(std::get<1>(c1)), int*> );
+S2 s2;
+static_assert( std::same_as<decltype(std::get<0>(s2)), long*> );
+static_assert( std::same_as<decltype(std::get<1>(s2)), void*> );
+const S2 c2;
+static_assert( std::same_as<decltype(std::get<0>(c2)), long*> );
+static_assert( std::same_as<decltype(std::get<1>(c2)), void*> );
diff -urN gcc-10-20200216/libstdc++-v3/testsuite/util/testsuite_iterators.h /home/bero/repos/gcc/libstdc++-v3/testsuite/util/testsuite_iterators.h
--- gcc-10-20200216/libstdc++-v3/testsuite/util/testsuite_iterators.h	2020-02-16 23:32:16.000000000 +0100
+++ /home/bero/repos/gcc/libstdc++-v3/testsuite/util/testsuite_iterators.h	2020-02-19 17:37:13.075815822 +0100
@@ -765,8 +765,8 @@
       = test_sized_range<T, output_iterator_wrapper>;
 
 // test_range and test_sized_range do not own their elements, so they model
-// std::ranges::safe_range.  This file does not define specializations of
-// std::ranges::enable_safe_range, so that individual tests can decide
+// std::ranges::borrowed_range.  This file does not define specializations of
+// std::ranges::enable_borrowed_range, so that individual tests can decide
 // whether or not to do so.
 // This is also true for test_container, although only when it has forward
 // iterators (because output_iterator_wrapper and input_iterator_wrapper are
